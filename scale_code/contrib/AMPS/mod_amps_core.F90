#include "scalelib.h"
!OCL SERIAL
module mod_amps_core
  use scale_io
  use maxdims
  use par_amps
  use com_amps, only: &
     fid_alog, &
     debug
  use mod_amps_const
  use class_Thermo_Var, only: &
     Thermo_Var
  use class_Group, only: &
     Group
  use class_AirGroup, only: &
     AirGroup
  implicit none
  private

  public :: vapor_deposition
  public :: coalescence
  public :: Ice_Nucleation1
  public :: Ice_Nucleation2
  public :: w_terminal_vel
  public :: cal_aptact_var8_vec
  public :: cal_aptact_var8_kc04dep
  public :: mv_ice2liq
  public :: hydrodyn_breakup
  public :: melting_shedding
  public :: cal_Coalescence_Efficiency
  public :: cal_breakup_dis_LL
  public :: diag_t
  public :: diag_pq

  ! threshold solubility to determine the CCN or IN
  real(PS), private, parameter :: min_eps_ccn=1.0e-6_PS


contains

  subroutine vapor_deposition(g,ga,ag,level,mes_rc,ID,JD,KD &
                             ,vigp,rdsd,ihabit_gm_random)
    use scale_prc, only: &
       PRC_abort
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec, &
       random_genvar, &
       get_cmod_inh
    use class_Group, only: &
       vap_igp_aux
    use class_Thermo_Var, only: &
       get_sat_vapor_pres_lk
    ! **********************************************************************
    ! Calculate the vapor deposition and evaporation for ice phase
    ! based on the semidiscrete bin method and postgrowth linear method
    ! proposed by Chen and Lamb (1994).
    ! **********************************************************************
    ! +++ In case of ice group +++
    !
    ! Use the vapor deposition equation:
    !                                  _
    !            dM/dt = 4 pi G(T,P) C fv s
    !
    ! mass (liquid or solid) group
    type (Group), intent(inout)   :: g
    ! thermo variable object
    type (AirGroup), intent(inout)  :: ag
    ! level of complexity
    integer, intent(in)           :: level
    ! error message
    !integer :: em0
    ! message from reality-check
    integer,dimension(*)   :: mes_rc
!tmp    integer,pointer,dimension(:)  :: mes_rc
    ! aerosol group
    type (Group), dimension(*)  :: ga
    !
    integer :: ID(*),JD(*),KD(*)
    !
    ! Inherent Growth parameterization
    type (vap_igp_aux),intent(in) :: vigp

    type(random_genvar),intent(inout) :: rdsd

    ! random generaion: 1, max frequency: 0
    integer, intent(in)           :: ihabit_gm_random
    !
    ! local space
    !
    ! shifted-bin boundaries
    !real(PS), dimension(2)            :: shifted_bound
    real(PS), dimension(mxnbin+1,g%L,2)           :: binb3d
    real(PS), dimension(mxnbin+1)           :: binb4
!    real(PS), pointer, dimension(:,:,:)           :: binb3d
!    real(PS), pointer, dimension(:)           :: binb4


    ! parameter of distribution in each bin
!tmp    real(PS), pointer, dimension(:)           :: par
    !real(DS), dimension(3)           :: par
    !
    ! temporary mass
    real(PS)                                   :: temp_dM
    ! transferred total concentration and mass from bin to bin
    !real(PS)                                   :: trans_dN, trans_dM
    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
!    real(8), pointer, dimension(:,:)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,g%L,1+mxnmasscomp)          :: new_M
!    real(8), pointer, dimension(:,:,:)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,g%L,mxnnonmc)          :: new_Q
!    real(8), pointer, dimension(:,:,:)          :: new_Q

    ! index array to remember bins with nonzero con or mass
!tmp    integer, pointer,  dimension(:)            :: index_bin

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd
!    real(PS), pointer, dimension(:,:)           :: Np
!    real(8), pointer, dimension(:,:)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd
!    real(PS), pointer, dimension(:,:)           :: Mp
!    real(8), pointer, dimension(:,:)           :: Mpd

    ! change of total mass in the bin before mapping
    real(PS), dimension(mxnbin,LMAX)           :: dMcon
!    real(PS), pointer, dimension(:,:)           :: dMcon

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,g%L,mxnmasscomp)      :: ratio_Mp
!    real(PS), pointer, dimension(:,:,:)      :: ratio_Mp

    ! growth mode
    ! 1: polycrystalline crystals
    ! 2: plate
    ! 3: column
    ! 4: rosette
    integer,dimension(mxnbin,LMAX)  :: growth_mode
!    integer, pointer ,dimension(:,:)  :: growth_mode

    ! indication of initial growth where the number of a signe crystal can change.
    !integer :: init_growth

    ! process number for tendency
    integer  :: process=1

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
    real(PS), dimension(mxnbin+1,g%L,mxnnonmc+2)             :: Qp
!    real(PS), pointer, dimension(:,:,:)             :: Qp

    ! ratio of each volume component mass to total volume in the shifted bin.
    ! argument 1 : volume by riming * concentration
    !          2 : volume by aggregation * concentration
!tmp    real(PS), pointer, dimension(:)        :: ratio_Vp
    real(PS), dimension(mxnvol)        :: ratio_Vp
!    real(PS), pointer, dimension(:)        :: ratio_Vp


    ! axis change of an ice crystal in shifted bins
!tmp    real(PS), pointer, dimension(:)            :: d_axis_len
    real(PS), dimension(mxnbin+1,g%L,2)            :: d_axis_len
!    real(PS), pointer, dimension(:,:,:)            :: d_axis_len

    ! volume change in shifted bins
    real(PS), dimension(mxnbin,g%L,mxnvol)            :: d_vol
!    real(PS), pointer, dimension(:,:,:)            :: d_vol

    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
!    real(8), pointer, dimension(:,:)                       :: new_mtend
    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend
!    real(PS), pointer, dimension(:,:)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,g%L,mxnaxis-1) :: axr_p
!    real(PS), pointer, dimension(:,:,:) :: axr_p
    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
!    real(PS), pointer, dimension(:,:)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
!    integer, pointer, dimension(:,:)          :: habit_p
    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
!    real(PS), pointer, dimension(:,:)              :: asr_p
    ! type in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: type_p
!    integer, pointer, dimension(:,:)          :: type_p

    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
!    real(PS), pointer, dimension(:,:)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
!    real(PS), pointer, dimension(:,:)           :: n_exice_p
    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p
!    real(PS), pointer, dimension(:,:)           :: actINF_p

    ! excess vapor density (g/cm^3)
    ! 1st argument : bin number
    !                calculation done with sfc temperature of ice crystal.
    ! The extra index (g%N_BIN+1) is reserved for ambient temperature calculation.
    real(PS), dimension(mxnbin+1,LMAX)            :: ex_vden
!    real(PS), pointer, dimension(:,:)            :: ex_vden


    ! inherent growth ratio
    real(PS),dimension(g%L,2)            :: gamma
    ! coef to modifiy inherent growth ratio by the time step
    real(PS) :: cmod_inh

    ! total number of sub-bins in a collector bin
    integer, dimension(LMAX)                   :: n_all

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,g%L,4)           :: a2d
    real(8) :: a(4)

    ! concentration and mass to be moved into aerosol groups
    !   soluble (1) or insoluble (2) categories
    real(8),dimension(LMAX,2)            :: ap_dN, ap_dM
!    real(8), pointer, dimension(:,:)            :: ap_dN, ap_dM
    !    soluble mass and activated IN
    real(8),dimension(LMAX,2)            :: ap_dMS, ap_dNI, ap_dMV
!    real(8), pointer, dimension(:,:)            :: ap_dMS, ap_dNI, ap_dMV
    ! indication of evaporation due to the mass less than the boundary
    !   the value corresonds to the aerosol category that
    !   particles were transfered due to evaporation
    integer,dimension(mxnbin,LMAX) :: inevp
!    integer, pointer, dimension(:,:) :: inevp

    ! indication of dendritic growth
!tmp    integer,pointer,dimension(:) :: len_switch
    integer,dimension(mxnbin,LMAX,3) :: len_switch
!    integer, pointer, dimension(:,:,:) :: len_switch

    ! indication of wet growth
    integer,dimension(mxnbin,LMAX) :: iwet

    ! used vapor
!tmp    real(PS), dimension(1,LMAX)           :: used_v,used_v2,ratio_v2
    real(8), dimension(mxnbin,LMAX)           :: used_v

    integer,dimension(mxnbin+1,LMAX)             :: error_number

    !real(PS) :: d_mm_hex,mmass_p_hex

    ! maximum realisitc super saturation for wet growth of ice particles
    real(PS),parameter :: max_Sw=0.001D0

    integer,dimension(LMAX) :: icycle_n
    integer,dimension(mxnbin+1,LMAX) :: icond3,icond_noevp,icond_ngb,icond_sft
!    integer,dimension((mxnbin+1)*LMAX) :: ierror

    ! change of mass at mean mass point
    real(PS),dimension(mxnbin,LMAX)                      :: d_mean_mass
    !
    ! bin boundary modification factor.
    real(PS),parameter    :: bbmf=0.2D0

    ! minimum fraction of soluble mass for CCN
    real(PS),parameter :: lmt_frac=0.99999d-5

    integer             :: i,n,j!,IER, TN, tn_nzero, n_nzero, ibin
    integer             :: icat
    real(PS)            :: d_mass_b1, d_mass_b2
    real(PS)            :: dum1, r_new!, mr_n,mr_0

    ! local error message
    integer :: em

    integer :: ievap,jmat
    integer :: i_d_ge_b,i_b_ge_d,i_epslt

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! allocate memory
!tmp    call allocate_vapor

!!c    write(*,'("omp in vap",3I5)') omp_in_parallel(),omp_get_num_threads(),omp_get_thread_num()
!!c    write(*,'("memory loc",3I15)') loc(g),loc(k),loc(new_N)

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!$    ! start initializing pointers
!!$    allocate(binb3d(mxnbin+1,g%L,2))
!!$    allocate(binb4(mxnbin+1))
!!$    allocate(new_N(mxnbin,LMAX),new_M(mxnbin,g%L,1+mxnmasscomp))
!!$    allocate(new_Q(mxnbin,g%L,mxnnonmc))
!!$    allocate(Np(mxnbin+1,LMAX),Npd(mxnbin+1,LMAX))
!!$    allocate(Mp(mxnbin+1,LMAX),Mpd(mxnbin+1,LMAX))
!!$    allocate(dMcon(mxnbin,LMAX))
!!$    allocate(ratio_Mp(mxnbin+1,g%L,mxnmasscomp))
!!$    allocate(growth_mode(mxnbin,LMAX))
!!$    allocate(Qp(mxnbin+1,g%L,mxnnonmc+2))
!!$    allocate(ratio_Vp(mxnvol))
!!$    allocate(d_axis_len(mxnbin+1,g%L,2))
!!$    allocate(d_vol(mxnbin,g%L,mxnvol))
!!$    allocate(new_mtend(mxnbin,LMAX),mtend(mxnbin+1,LMAX))
!!$    allocate(axr_p(mxnbin+1,g%L,mxnaxis-1))
!!$    allocate(den_ip_p(mxnbin+1,LMAX),den_ic_p(mxnbin+1,LMAX))
!!$    allocate(asr_p(mxnbin+1,LMAX))
!!$    allocate(type_p(mxnbin+1,LMAX))
!!$    allocate(habit_p(mxnbin+1,LMAX))
!!$    allocate(rag_p(mxnbin+1,LMAX),rcg_p(mxnbin+1,LMAX))
!!$    allocate(n_exice_p(mxnbin+1,LMAX))
!!$    allocate(actINF_p(mxnbin+1,LMAX))
!!$    allocate(ex_vden(mxnbin+1,LMAX))
!!$    allocate(ap_dN(LMAX,2),ap_dM(LMAX,2))
!!$    allocate(ap_dMS(LMAX,2),ap_dNI(LMAX,2),ap_dMV(LMAX,2))
!!$    allocate(inevp(mxnbin,LMAX))
!!$    allocate(len_switch(mxnbin,g%L,3))
!!$    ! end of initialization of pointers


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization

    if(g%token==1) then
      jmat=rmat
    elseif(g%token==2) then
      jmat=imat
    end if

    em=0

    binb4(1:g%N_binb)=g%binb(1:g%N_binb)

    new_N(:,:)=0.0d+0
    new_mtend(:,:)=0.0d+0
    used_v(:,:)=0.0d+0

    d_mean_mass(:,:)=0.0_PS
    dMcon(:,:)=0.0_PS

    do n = 1, g%L
    do i = 1, g%N_BIN
       binb3d(i,n,1)=g%binb(i)
       binb3d(i,n,2)=g%binb(i+1)
    end do
    end do

    iwet(:,:)=0
    growth_mode(:,:)=0
    inevp(:,:)=0

    Np(:,:)=0.0_PS
    Mp(:,:)=0.0_PS
    Npd(:,:)=0.0d+0
    Mpd(:,:)=0.0d+0
    mtend(:,:)=0.0e+0

    icond3(:,:)=0
    icond_noevp(:,:)=0
    icond_ngb(:,:)=0
    icond_sft(:,:)=0
    error_number(:,:)=0

    new_M(:,:,:) = 0.0d+0

    new_Q(:,:,:) = 0.0d+0

    ratio_Mp(:,:,:) = 0.0_PS

    d_axis_len(:,:,:) = 0.0_PS

    len_switch(:,:,:)=0

    d_vol(:,:,:) = 0.0_PS

    icycle_n(:)=0
    n_all(:)=g%N_BIN

    ! initialize con and mass of aerosol transports
    ap_dN(:,:) = 0.0d+0
    ap_dM(:,:) = 0.0d+0
    ap_dMS(:,:) = 0.0d+0
    ap_dNI(:,:) = 0.0d+0
    ap_dMV(:,:) = 0.0d+0

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! setup for all the grids

    do n=1,g%L
      ! +++ loop over grids +++
      if( mes_rc(n) == 0 ) then
        icycle_n(n)=1
      endif

      ! if the group does not have any hydrometeors, exit.
      ! all processes except cloud droplets requirs hydrometeors to grow or evaporate.
      if( g%mark_cm(n) == 3 ) then
        icycle_n(n)=1
      endif
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! If the hydrometeor is ice, and temperature is warmer than 0C,
      ! it is assumed that thin layer of water immediately form over frozen hydrometeors.
      ! Melting and collision processes still should be also possible.
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      if(g%token == 2.and.level<=5) then
        if( ag%TV(n)%T >= 273.16_PS ) then
          icycle_n(n)=1
        endif
      end if
    enddo

!    do in=1,mxnbin*g%L
!      n=(in-1)/mxnbin+1
!      i=in-(n-1)*mxnbin
    do n = 1, g%L
    do i = 1, g%N_BIN

      ! +++ check of positive ness +++
      if( icycle_n(n)==0.and.&
          g%MS(i,n)%con > 1.0e-30_PS .and. &
          g%MS(i,n)%mass(1) > 1.0e-30_PS) then
        icond3(i,n)=1
        icond_noevp(i,n)=1
      end if
    enddo
    enddo

    if( g%token == 2 ) then
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate the inherent growth ratio
      call cal_inherent_growth_ratio_vec(ag,gamma,vigp)

      ! adjust inherent ratio according to the timestep used.
      !   The timstep adjusted ranges from 20 sec to 0.1 sec.
      !   The regime T<-20 C is less senstive to the inherent growth since the
      !   growth is much weaker.
      do n=1,g%L

        if(ag%TV(n)%T-273.16>-20.0_PS) then
          cmod_inh=get_cmod_inh(g%dt)
        else
          cmod_inh=0.5_PS
        endif
        gamma(n,1) = 10.0_PS**(cmod_inh*log10(gamma(n,1)))
        gamma(n,2) = 10.0_PS**(cmod_inh*log10(gamma(n,2)))

      enddo
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! +++ calculate the excess vapor density +++
      call cal_ex_vapor_density_vec( g, ag, ex_vden)
    end if


    !     Initially all the bins are assumed to have the same type of
    !     distribution.
    if( g%org_dtype == 1 ) then
      !
      ! --- case of linear approx. for the concentration
      !     distribution of a bin ---
      !
      !     Linear method can determine the new parameters only with the
      !     information about the bin; it does not need information about
      !     other bin boundaries.
      !
!      do in=1,g%N_bin*g%L
!        n=(in-1)/g%N_bin+1
!        i=in-(n-1)*g%N_bin
       do n = 1, g%L
       do i = 1, g%N_bin

        if(icond3(i,n)==1) then

          if(g%token==2) then
              if(ag%TV(n)%T<T_0.and.g%MS(i,n)%inmlt==0) then
            ! dry growth
!!c                   d_mean_mass=(g%MS(i,n)%coef(1)*(ag%TV(n)%s_v_n(g%token)+1.0_PS)+g%MS(i,n)%coef(2))*g%dt
              d_mean_mass(i,n)=(g%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(2)/ag%TV(n)%T_n*&
                  (ag%TV(n)%s_v_n(2)+1.0_PS)+&
                   g%MS(i,n)%coef(2)*get_sat_vapor_pres_lk(2,g%MS(i,n)%tmp,ag%estbar,ag%esitbar)/g%MS(i,n)%tmp&
                   )*g%dt
!!c                   write(*,'("dry growth",2I5,8ES15.6)') &
!!c                           i,g%IS(i,k)%habit,ag%TV(n)%s_v_n(1),ag%TV(n)%s_v_n(2),ag%TV(n)%T,g%MS(i,n)%a_len,g%MS(i,n)%c_len,&
!!c                           g%IS(i,k)%d,g%MS(i,n)%tmp,d_mean_mass
            else
              ! wet growth
              d_mean_mass(i,n)=(g%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(1)/ag%TV(n)%T_n*&
                     (ag%TV(n)%s_v_n(1)+1.0_PS)+&
                     g%MS(i,n)%coef(2)*get_sat_vapor_pres_lk(1,g%MS(i,n)%tmp,ag%estbar,ag%esitbar)/g%MS(i,n)%tmp&
                     )*g%dt
!!c                   d_mean_mass=(g%MS(i,n)%coef(1)*(min(max_sw,ag%TV(n)%s_v_n(1))+1.0_PS)+g%MS(i,n)%coef(2))*g%dt
!!c                   write(*,'("wet growth",2I5,8ES15.6)') &
!!c                           i,g%IS(i,k)%habit,ag%TV(n)%s_v_n(1),ag%TV(n)%s_v_n(2),ag%TV(n)%T,g%MS(i,n)%a_len,g%MS(i,n)%c_len,&
!!c                           g%IS(i,k)%d,g%MS(i,n)%tmp,d_mean_mass
            end if
          else
!!c                d_mean_mass=g%MS(i,n)%coef(1)*ag%TV(n)%s_v_n(g%token)*g%dt

            d_mean_mass(i,n)=(g%MS(i,n)%coef(1)*ag%TV(n)%s_v_n(g%token)+&
                       g%MS(i,n)%coef(2))*g%dt

!!c                write(*,'("vap depliq:k,i,j,bin,dm,con,c1,c2,sv",4I5,20ES15.6)') &
!!c                     KD(k),ID(k),JD(k),i,d_mean_mass,g%MS(i,n)%con,&
!!c                     g%MS(i,n)%coef(1),g%MS(i,n)%coef(2),g%MS(i,n)%coef(3),ag%TV(n)%s_v_n(g%token)
          endif

          dMcon(i,n)=g%MS(i,n)%con*d_mean_mass(i,n)
          !     The mass changes at the boundary is approximated by the mass
          !     change at the mean mass point.
          d_mass_b1 = d_mean_mass(i,n) * (g%binb(i)/g%MS(i,n)%mean_mass)**(1.0/3.0)
          d_mass_b2 = d_mean_mass(i,n) * (g%binb(i+1)/g%MS(i,n)%mean_mass)**(1.0/3.0)

!org          d_mass_b1 = d_mean_mass(i,n) * (g%binb(i)/g%MS(i,n)%mean_mass)**(0.333333333333333_PS)
!org          d_mass_b2 = d_mean_mass(i,n) * (g%binb(i+1)/g%MS(i,n)%mean_mass)**(0.333333333333333_PS)

          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! calculate the shifted bin boundaries
          binb3d(i,n,1) = g%binb(i) + d_mass_b1
          binb3d(i,n,2) = g%binb(i+1) + d_mass_b2
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!dbg          write(*,*)"dMcon,d_mass_b1,d_mass_b2",i,n,dMcon(i,n),d_mass_b1,d_mass_b2,binb3d(i,n,1:2)


        endif

        if(real(icond3(i,n),PS_KIND)*d_mean_mass(i,n)<0.0_PS) then
          ! use temp_dM as the total mass of aerosols
          if(level<=3) then
            temp_dM=g%binb(1)*g%MS(i,n)%con
          else
            temp_dM=g%MS(i,n)%mass(jmat)
          end if
          temp_dM=temp_dM-g%MS(i,n)%mass(1)

          r_new=coef3i4p1i3*(max(1.0e-30_RP,(g%MS(i,n)%mean_mass+d_mean_mass(i,n)))&
                          /g%MS(i,n)%den)**(0.333333333333333_PS)


          binb3d(i,n,1)=max(0.0_RP,binb3d(i,n,1))
          binb3d(i,n,2)=max(0.0_RP,binb3d(i,n,2))

          ievap=0
          if(level>=4.and.g%token==1.and.g%MS(i,n)%r_act>r_new) then
            ! haze transfer check
            ievap=1
          elseif(temp_dM*0.99999_RP>=g%MS(i,n)%con*d_mean_mass(i,n)) then
            ! all the water has evaporated.
            ievap=1
          elseif(binb3d(i,n,2)<=g%binb(1) ) then
            ! all the water has evaporated.
            ievap=1
          endif

          if(ievap==1) then
            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! add tendencies for aerosols into each categories by evaporation
!org            call add_tendency_ap(level,g,ga,ag,i,k,g%token,g%MS(i,n)%con,g%MS(i,n)%mass(1),'ev1 vd')
            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            used_v(i,n)=used_v(i,n)+temp_dM  ! i,n is used for vectorization

            ! total evaporation
            icond_noevp(i,n)=0

          end if
        endif

        if(icond_noevp(i,n)==1) then

          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! total concentration in the shifted bin
          Npd(i,n)=real(g%MS(i,n)%con,8)
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! total mass in the shifted bin
          Mpd(i,n)=real(g%MS(i,n)%mass(1),8)+real(dMcon(i,n),8)
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

          Np(i,n)=Npd(i,n)
          Mp(i,n)=Mpd(i,n)

          used_v(i,n)=used_v(i,n)+dMcon(i,n)

          icond_sft(i,n)=1

        endif
      enddo
      enddo

      ! case of total evaporation. do not include these for trans bin
      do i=1,g%N_bin
!CDIR NODEP
!!!!CDIR NOVECTOR
        do n=1,g%L
          if(icond_noevp(i,n)==0.and.icond3(i,n)==1) then
            i_epslt=0.5_PS*(1.0_PS-sign(1.0_PS,g%MS(i,n)%eps_map-lmt_frac))
            icat=i_epslt*2+(1-i_epslt)
            dum1=g%token-1

            ap_dN(n,icat)=ap_dN(n,icat)+g%MS(i,n)%con
            ap_dM(n,icat)=ap_dM(n,icat)+g%MS(i,n)%mass(jmat)
            ap_dMS(n,icat)=ap_dMS(n,icat)+g%MS(i,n)%mass(jmat)*g%MS(i,n)%eps_map

            inevp(i,n)=icat

            ! add to vapor
            ag%TV(n)%dmassdt_v(g%token)=ag%TV(n)%dmassdt_v(g%token)+ &
                max(0.0_PS,(g%MS(i,n)%mass(1)-g%MS(i,n)%mass(jmat)))/g%dt
!!!            if(ap_dN(n)<0.0.or.ap_dM(n)<0.0) then
!!!              write(*,*) "negative ap",i,n,ap_dn(n),ap_dm(n),g%Ms(i,n)%con,g%ms(i,n)%mass(1)
!!!            endif


          endif
        enddo
      enddo


      ! gather the used vapor for vectorization
      do n=1,g%L
      do i=2,g%N_bin
         used_v(1,n)=used_v(1,n)+used_v(i,n)
      enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of
      !     1. ratio of each increased mass components to total mass, and
      !     2. growth in a-axis and c-axis
      call cal_ratio_mass_vd_vec( g, ag, level,icond_noevp, &
                  gamma, ex_vden,d_mean_mass, &
                  dMcon, Mp, ratio_Mp, d_axis_len, d_vol,len_switch,&
                  iwet,mes_rc,rdsd,ihabit_gm_random)

      if( g%token == 2 ) then
        !
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     4. assign quality variables
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
!          ierror(in)=0
         do n = 1, g%L
         do i = 1, g%N_BIN
            if(icond_noevp(i,n)==1.and.ratio_Mp(i,n,imc_m) <= 0.0_PS ) then
               LOG_ERROR("vapor_deposition",*) "ratio_Mp bef ass (dep)",KD(n),ID(n),JD(n),i,ratio_Mp(i,n,1:imc_m)
               LOG_ERROR_CONT(*) "mass,con,alen,clen",Mp(i,n),Np(i,n),d_axis_len(i,n,1:2)
               LOG_ERROR_CONT(*) "dMcon",dMcon(i,n)
               LOG_ERROR_CONT(*) ag%TV(n)%T,ag%TV(n)%T_n,ag%TV(n)%T_m
               LOG_ERROR_CONT(*) ag%TV(n)%s_v(1),ag%TV(n)%s_v(2),ag%TV(n)%s_v_n(1),ag%TV(n)%s_v_n(2)
               call PRC_abort
            endif
        enddo
        enddo

        call assign_Qp_v3_vec(g,icond_noevp,d_axis_len,d_vol,len_switch,iwet &
                             ,Mp,ratio_Mp,Qp)

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     5. ratio of each increased volume components to total volume
!!c     call cal_ratio_vol( g, level, Qp, ratio_Vp)

!!c                if( g%IS(i,k)%d >= 1.0e-3.and.ag%TV(k)%T<-20.0+273.16 ) then
!!c                   write(*,*) "i,k",i,k
!!c                   write(*,'(15ES15.6)') g%MS(i,k)%a_len,g%MS(i,k)%c_len,g%IS(i,k)%d,g%IS(i,k)%ag,g%IS(i,k)%cg,g%IS(i,k)%n_exice&
!!c                    ,g%MS(i,k)%semi_a,g%MS(i,k)%semi_c
!!c                   write(*,'(15ES15.6)') ag%TV(k)%T, g%MS(i,k)%tmp,ag%TV(k)%s_v_n(1),ag%TV(k)%s_v_n(2)&
!!c                    ,d_axis_len
!!c                   write(*,*) "Qp", Qp
!!c                   write(*,'(10I5)') len_switch,g%IS(i,k)%growth_mode,g%IS(i,k)%init_growth,iwet
!!c                end if

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     6. apparent density and others for the shifted bin
        call cal_xxx_p_v5_vec(level,g%L, icond_noevp, n_all, Mp, Np, &
                Qp, ratio_Mp, &
                den_ip_p,asr_p,type_p,&
                den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
                'vap_dep')
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      else
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        !     4. assign quality variables
      end if

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of parameters for linear distribution in the shifted bin
      call cal_lincubprms_vec(mxnbin+1,g%N_BIN,g%L,Npd,Mpd,binb3d  &
                         ,a2d,error_number,"vap_dep_1")

!!!      do n=1,g%L
!!!        if(ap_dN(n)<0.0.or.ap_dM(n)<0.0) then
!!!          write(*,*) "negative ap2:",i,n,ap_dn(n),ap_dm(n)
!!!        endif
!!!      enddo
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! truncation check
      !   if the growth is very small compared to the existing mass
      !   concentration, then, it is simply added to the new bins.
      !   this is for real(4)
      ! these bins do not use shift-bin method
!      do in=1,g%N_bin*g%L
!        n=(in-1)/g%N_bin+1
!        i=in-(n-1)*g%N_bin
      do n = 1, g%L
      do i = 1, g%N_bin
        if(icond_noevp(i,n)==1) then
          if(abs(dMcon(i,n))<=g%MS(i,n)%mass(1)*1.0e-7_PS) then
            icond_sft(i,n)=0
            icond_ngb(i,n)=1
!dbg            write(*,*) "negligible mass growth in these bins",i,n,g%ms(i,n)%mass(1),dmcon(i,n)
          endif
        endif
      enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! turn on the error_number flag not to apply the shift-bin method
!      do in=1,g%N_bin*g%L
!        n=(in-1)/g%N_bin+1
!        i=in-(n-1)*g%N_bin
      do n = 1, g%L
      do i = 1, g%N_bin
        if(icond3(i,n)==0.or.icond_sft(i,n)==0.or.icond_ngb(i,n)==1.or.&
           icond_noevp(i,n)==0) then
          error_number(i,n)=10
        endif
      enddo
      enddo

      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! check of postgrowth method
      ! if post-growth linear method produce an error,
      ! post-growth lienar method with linear growth of bin limits is used.
      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        if(1<=error_number(i,n).and.error_number(i,n)<=4) then
          dum1 = Mpd(i,n)/Npd(i,n)

          i_d_ge_b=0.5_PS*(1.0_PS+sign(1.0_PS,dum1-binb3d(i,n,2)))
          binb3d(i,n,2)=real(i_d_ge_b,PS_KIND)*dum1*(1.0_PS+bbmf) + &
                           (1.0_PS-real(i_d_ge_b))*binb3d(i,n,2)

          i_b_ge_d=0.5_PS*(1.0_PS+sign(1.0_PS,binb3d(i,n,1)-dum1))
          binb3d(i,n,1)=real(i_b_ge_d,PS_KIND)*max(g%binb(1),dum1*(1.0_PS-bbmf)) + &
                           (1.0_PS-real(i_b_ge_d,PS_KIND))*binb3d(i,n,1)

          a(1) = a2d(i,n,1)
          a(2) = a2d(i,n,2)
          a(3) = a2d(i,n,3)
          a(4) = a2d(i,n,4)
          call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                     binb3d(i,n,1),binb3d(i,n,2),a(:), &
                     error_number(i,n))
        endif
      enddo
      enddo

!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        if(1<=error_number(i,n).and.error_number(i,n)<=4) then

          Npd(i,n) = Mpd(i,n)/(0.5_PS*(g%binb(i+1)+g%binb(i)))
          Np(i,n)=Npd(i,n)

          a(1) = a2d(i,n,1)
          a(2) = a2d(i,n,2)
          a(3) = a2d(i,n,3)
          a(4) = a2d(i,n,4)
          call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                      binb3d(i,n,1),binb3d(i,n,2),a(:), &
                      error_number(i,n))
        endif
      enddo
      enddo

!      ierror(1:g%N_BIN*g%L)=0
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        if(1<=error_number(i,n).and.error_number(i,n)<=4) then
           if ( debug ) then
              write(*,*) "Warning: Modified pre-growth linear method also does not work at" &
                   ,i,n
              write(*,*) "       : Ignored con and mass:",Np(i,n),Mp(i,n)
           end if
           error_number(i,n)=10
        endif
      enddo
      enddo
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate the mass tendency of shifted bin
!      do in=1,g%N_bin*g%L
!        n=(in-1)/g%N_bin+1
!        i=in-(n-1)*g%N_bin
      do n = 1, g%L
      do i = 1, g%N_bin
        if(icond_noevp(i,n)==1) then
          mtend(i,n)=(Mp(i,n)/Np(i,n)-g%MS(i,n)%mean_mass)/g%dt
        endif
      enddo
      enddo
      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!!      do n=1,g%L
!!!        if(ap_dN(n)<0.0.or.ap_dM(n)<0.0) then
!!!          write(*,*) "negative ap3:",i,n,ap_dn(n),ap_dm(n)
!!!        endif
!!!      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of transferred concentration and mass into original bins
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call cal_transbin_vec(g%token &
                           ,g%L,g%N_masscom &
                           ,g%N_bin,g%N_bin &
                           ,binb4 &
                           ,error_number &
                           ,a2d,binb3d,mtend &
                           ,new_N,new_M,new_Q &
                           ,new_mtend &
                           ,ratio_Mp,den_ip_p,axr_p,spx_p &
                           ,habit_p,den_ic_p &
                           ,rag_p,rcg_p,n_exice_p &
                           ,actINF_p &
                           ,1,ap_dN,ap_dM,ap_dMS,ap_dNI,ap_dMV,inevp)
      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!c             write(*,'("af callin",5I5,20ES15.6)') KD(k),ID(k),JD(k),i,em,&
!!c                        Np,Mp,shifted_bound(1:2),par(1:3)

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! add the non-moving bins
      call add_samebin_vec(new_N,new_M,new_Q,g%N_bin,g%L,icond_ngb,g%token,&
                    g%n_masscom,g%n_nonmass,Npd,Mpd,ratio_Mp,Qp)


      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! add tendencies for aerosols into each categories by evaporation
      call add_tendency_ap_vec(ga,ag,ap_dN,ap_dM,ap_dMS,ap_dNI,ap_dMV,'af_vd')
!      do in=1,g%N_bin*g%L
!        n=(in-1)/g%N_bin+1
!        i=in-(n-1)*g%N_bin
      do n = 1, g%L
      do i = 1, g%N_bin
        if(icond3(i,n)==1) then
          g%MS(i,n)%inevp=inevp(i,n)
        endif
      enddo
      enddo

      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! check if the density of a solid hydrometeor satisfies
      ! the minimum possible circumscribing sphere.
      call check_csvolume_vec(g, new_N, new_M, new_Q)
      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! assign tendency by vapor deposition
      call assign_tendency_vec( g, process,&
             new_N, new_M, new_Q, new_mtend, &
             g, used_v)
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      if(debug) then
       if(g%token==2) then
!         do in=1,g%N_BIN*g%L
!           n=(in-1)/g%N_BIN+1
!           i=in-(n-1)*g%N_BIN
          do n = 1, g%L
          do i = 1, g%N_BIN
!           ierror(in)=0

!           if(g%MS(i,n)%dvoldt(iccr,process)>0.0_RP.and.&
!              g%MS(i,n)%dvoldt(iacr,process)<0.0_RP) then
!           if(new_Q(i,n,iacr)>1.0e-30_RP.and.&
!              (new_Q(i,n,iccr)/max(1.0e-30_RP,new_q(i,n,iacr)))**(1.0_RP/3.0_RP)>1.01_RP) then
!             ierror(in)=1
!           endif

           if( debug .and. &
                new_N(i,n)>1.0e-30_DS.and.new_Q(i,n,ivcs)>1.0e-30_DS.and.&
                new_M(i,n,1)/max(1.0e-30_DS,new_Q(i,n,ivcs))<1.0e-3_DS) then
!!!           if(new_N(i,n)>1.0e-30_DS.and.new_Q(i,n,ivcs)>1.0e-30_DS) then
!!!
               write(*,*) "vapor den check final:",i,KD(n),ID(n),JD(n) &
                      ,new_M(i,n,1)/new_Q(i,n,ivcs)
               write(*,*) "alen,clen,phi",i,n,new_Q(i,n,iacr),new_q(i,n,iccr) &
                 ,(new_Q(i,n,iccr)/max(1.0e-30_DS,new_q(i,n,iacr)))**(1.0_DS/3.0_DS)
               write(*,*) "n,m",i,n,new_N(i,n),new_M(i,n,1)
               write(*,*) "error_number,icond3,d_mean_mass",error_number(i,n),icond3(i,n),d_mean_mass(i,n)
               write(*,*) "a2d",a2d(i,n,1:4)
               write(*,*) "binb3d",binb3d(i,n,1:2)
               write(*,*) "old alen,clen",g%MS(i,n)%a_len,g%MS(i,n)%c_len
               write(*,*) "old n,m",g%MS(i,n)%con,g%MS(i,n)%mass(1)
               write(*,*) "old den",g%MS(i,n)%den,g%IS(i,n)%V_cs
               write(*,*) "old habit",g%IS(i,n)%sh_type,g%IS(i,n)%habit
               write(*,*) "dcondt:",g%MS(i,n)%dcondt(process)
               write(*,*) "dmassdt:",g%MS(i,n)%dmassdt(1,process)
               write(*,*) "dvoldt_v:",g%MS(i,n)%dvoldt(ivcs,process)
               write(*,*) "dvoldt_a:",g%MS(i,n)%dvoldt(iacr,process)
               write(*,*) "dvoldt_c:",g%MS(i,n)%dvoldt(iccr,process)
           endif
!           if(KD(n)==21.and.JD(n)==4.and.i==3) then
!               write(*,*) "vapor axis check final:",i,KD(n),ID(n),JD(n)
!               write(*,*) "alen,clen,phi",i,n,new_Q(i,n,iacr),new_q(i,n,iccr) &
!                 ,(new_Q(i,n,iccr)/max(1.0e-30_DS,new_q(i,n,iacr)))**(1.0_DS/3.0_DS)
!               write(*,*) "n,m",i,n,new_N(i,n),new_M(i,n,1)
!               write(*,*) "old alen,clen",g%MS(i,n)%a_len,g%MS(i,n)%c_len
!               write(*,*) "old n,m",g%MS(i,n)%con,g%MS(i,n)%mass(1)
!               write(*,*) "old habit",g%IS(i,n)%sh_type,g%IS(i,n)%habit
!               write(*,*) "dcondt:",g%MS(i,n)%dcondt(process)
!               write(*,*) "dmassdt:",g%MS(i,n)%dmassdt(1,process)
!               write(*,*) "dvoldt_a:",g%MS(i,n)%dvoldt(iacr,process)
!               write(*,*) "dvoldt_c:",g%MS(i,n)%dvoldt(iccr,process)
!           endif
         enddo
         enddo
       endif
      endif

    end if

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! deallocate memory
!tmp    call deallocate_vapor
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!tmp  contains
!tmp    subroutine allocate_vapor
!tmp      integer :: item(16)
!tmp      item=0
!tmp      allocate( new_N(g%N_BIN), stat = item(1))
!tmp      allocate( new_M(1+g%N_masscom,g%N_BIN), stat =item(2))
!tmp      allocate( new_Q(g%N_nonmass,g%N_BIN), stat =item(3))
!tmp      allocate( ratio_Mp(g%N_masscom), stat = item(4))
!tmp      allocate( ratio_Vp(g%N_vol), stat = item(5))
!tmp      allocate( ex_vden(g%N_BIN+1), stat = item(6))
!tmp      allocate( Qp(g%N_nonmass+2), stat = item(7))
!tmp      allocate( par(3), stat = item(8))
!tmp      allocate( d_vol(g%N_vol), stat = item(9))
!tmp      allocate( d_axis_len(2), stat = item(10))
!tmp      allocate( new_mtend(g%N_BIN), stat = item(11))
!tmp      allocate( len_switch(3), stat = item(12))
!tmp      allocate( shifted_bound(2), stat = item(13))
!tmp      allocate( axr_p(g%N_axis-1), stat = item(14))
!tmp      allocate( used_v(1), stat = item(15))
!tmp      allocate( gamma(2), stat = item(16))
!tmp      if( any(item/=0) ) Stop 'Allocation failed at vaopr_dep'
!tmp    end subroutine allocate_vapor
!tmp    subroutine deallocate_vapor
!tmp      integer :: item(16)
!tmp      item=0
!tmp      deallocate( gamma, stat = item(15))
!tmp      nullify(gamma)
!tmp      deallocate( used_v, stat = item(15))
!tmp      nullify(used_v)
!tmp      deallocate( axr_p, stat = item(14))
!tmp      nullify(axr_p)
!tmp      deallocate( shifted_bound, stat = item(13))
!tmp      nullify(shifted_bound)
!tmp      deallocate( len_switch, stat = item(12))
!tmp      nullify(len_switch)
!tmp      deallocate( new_mtend, stat = item(11))
!tmp      nullify(new_mtend)
!tmp      deallocate( d_axis_len, stat = item(10))
!tmp      nullify(d_axis_len)
!tmp      deallocate( d_vol, stat = item(9))
!tmp      nullify(d_vol)
!tmp      deallocate( par, stat = item(8))
!tmp      nullify(par)
!tmp      deallocate( Qp, stat = item(7))
!tmp      nullify(Qp)
!tmp      deallocate( ex_vden, stat = item(6))
!tmp      nullify(ex_vden)
!tmp      deallocate( ratio_Vp, stat = item(5))
!tmp      nullify(ratio_Vp)
!tmp      deallocate( ratio_Mp, stat = item(4))
!tmp      nullify(ratio_Mp)
!tmp      deallocate( new_Q, stat =item(3))
!tmp      nullify(new_Q)
!tmp      deallocate( new_M, stat =item(2))
!tmp      nullify(new_M)
!tmp      deallocate( new_N, stat = item(1))
!tmp      nullify(new_N)
!tmp      if( any(item/=0) ) Stop 'Deallocation failed at vaopr_dep'
!tmp    end subroutine deallocate_vapor

!!$    ! start deallocating pointers
!!$    deallocate(binb3d)
!!$    deallocate(binb4)
!!$    deallocate(new_N,new_M)
!!$    deallocate(new_Q)
!!$    deallocate(Np,Npd)
!!$    deallocate(Mp,Mpd)
!!$    deallocate(dMcon)
!!$    deallocate(ratio_Mp)
!!$    deallocate(growth_mode)
!!$    deallocate(Qp)
!!$    deallocate(ratio_Vp)
!!$    deallocate(d_axis_len)
!!$    deallocate(d_vol)
!!$    deallocate(new_mtend,mtend)
!!$    deallocate(axr_p)
!!$    deallocate(den_ip_p,den_ic_p)
!!$    deallocate(asr_p)
!!$    deallocate(type_p)
!!$    deallocate(habit_p)
!!$    deallocate(rag_p,rcg_p)
!!$    deallocate(n_exice_p)
!!$    deallocate(actINF_p)
!!$    deallocate(ex_vden)
!!$    deallocate(ap_dN,ap_dM)
!!$    deallocate(ap_dMS,ap_dNI,ap_dMV)
!!$    deallocate(inevp)
!!$    deallocate(len_switch)
!!$    ! end of deallocation of pointers

  end subroutine vapor_deposition


  subroutine coalescence(g_1, g_2, ag, level,col_level,mes_rc,ibreak &
              ,imin_bk,imax_bk,jmin_bk,jmax_bk,bu_tmass,bu_fd,ID,JD,KD &
              ,adrpdrp,drpdrp &
              ,ahexdrp,hexdrp &
              ,abbcdrp,bbcdrp &
              ,acoldrp,coldrp &
              ,agp1drp,gp1drp &
              ,agp4drp,gp4drp &
              ,agp8drp,gp8drp &
! <<< 2014/10 T. Hashino added for KiD
              ,dM_auto,dM_accr)
    use scale_prc, only: &
       PRC_abort
    use class_Group, only: &
       col_lut_aux
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec
!!!  use parameters, only : split_bins
! >>> 2014/10 T. Hashino added for KiD
    ! **********************************************************************
    ! Calculate the coalescence and riming based on
    ! the semidiscrete bin method and postgrowth linear method
    ! proposed by Chen and Lamb (1994a).
    ! **********************************************************************
    type (Group), intent(inout)   :: g_1, g_2
    type (AirGroup), intent(in) :: ag
!!c    type (Lookup_Table), intent(in) :: lt
    integer, intent(in)           :: level, col_level
    ! message from reality_check
!tmp    integer,pointer,dimension(:)   :: mes_rc
    integer,intent(in),dimension(*)  :: mes_rc
    ! current time
    !real(PS),intent(in) :: cur_time
    ! flag for collisional breakup calculation
    ! 1: implement calculation.
    integer,intent(in)  :: ibreak
    integer,intent(in) :: imin_bk,imax_bk,jmin_bk,jmax_bk
    real(PS),intent(in) :: bu_fd(2,*),bu_tmass(*)  ! 2014/10 T. Hashino modify for KID
    !
    type(col_lut_aux),intent(in) :: adrpdrp
    real(PS),intent(in),dimension(adrpdrp%nr,*) :: drpdrp
    type(col_lut_aux),intent(in) :: ahexdrp,abbcdrp,acoldrp
    real(PS),intent(in),dimension(ahexdrp%nr,*) :: hexdrp
    real(PS),intent(in),dimension(abbcdrp%nr,*) :: bbcdrp
    real(PS),intent(in),dimension(acoldrp%nr,*) :: coldrp
    type(col_lut_aux),intent(in) :: agp1drp,agp4drp,agp8drp
    real(PS),intent(in),dimension(agp1drp%nr,*) :: gp1drp
    real(PS),intent(in),dimension(agp4drp%nr,*) :: gp4drp
    real(PS),intent(in),dimension(agp8drp%nr,*) :: gp8drp
    !
    integer :: ID(*),JD(*),KD(*)
! <<< 2014/10 T. Hashino added for KiD
    real(PS),intent(inout),dimension(*) :: dM_auto,dM_accr

! >>> 2014/10 T. Hashino added for KiD
    !
    ! shifted bin boundaries
!tmp    real(PS), pointer, dimension(:)            :: shifted_bound
    real(PS), dimension(mxnbin+1,g_1%L,2)           :: binb3d
!    real(PS), pointer, dimension(:,:,:)           :: binb3d
    !
    ! change of mass at mean mass point
    !real(PS)                                   :: d_mean_mass
    !
    ! change of total concentration and mass during the time step in each original bin
    ! for group 1
    real(8), dimension(mxnbin,LMAX)            :: new_N_1
    real(8), dimension(mxnbin,g_1%L,1+mxnmasscomp)          :: new_M_1
!    real(8), pointer, dimension(:,:)            :: new_N_1
!    real(8), pointer, dimension(:,:,:)          :: new_M_1

    ! ratio of mass components in original bin to total mass
    ! collected group
!tmp    real(PS), pointer, dimension(:,:)            :: ratio_M_2
    real(PS), dimension(mxnbin,1+mxnmasscomp,LMAX)            :: ratio_M_2
!    real(PS), pointer, dimension(:,:,:)            :: ratio_M_2
    ! mass components of correcter group
!tmp    real(PS), pointer, dimension(:,:)            :: Mc
    real(PS), dimension(mxnbin+1,mxnmasscomp,LMAX)            :: Mc
!    real(PS), pointer, dimension(:,:,:)            :: Mc

    ! rimed mass of a collector hydrometeor
    real(PS)   :: rimed_mass

    ! ratio of each component mass to the total mass in the shifted bin
    ! of collector
    ! ratio_Mp(imr_m) : rime
    ! ratio_Mp(ima_m) : aggregation
!tmp    real(PS), pointer, dimension(:)      :: ratio_Mp
    real(PS), dimension(mxnbin+1,g_1%L,mxnmasscomp)      :: ratio_Mp
!    real(PS), pointer, dimension(:,:,:)      :: ratio_Mp
    ! ratio of volume components to the total mass in the sifted bin
    ! argument 1 : (a-axis length**3) * concentration
    !          2 : (c-axis length**3) * concentration
    !          3 : (d-axis length**3) * concentration
    !          4 : (r-axis length**3) * concentration
    !          5 : volume by riming * concentration
    !          6 : volume by aggregation * concentration
!tmp    real(PS), pointer, dimension(:)      :: ratio_Vp
    real(PS), dimension(mxnvol)      :: ratio_Vp
!    real(PS), pointer, dimension(:)      :: ratio_Vp


    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : (e-axis length**3) * concentration
    !          7 : volume by riming * concentration
    !          8 : volume by aggregation * concentration
    real(8), dimension(mxnbin,g_1%L,mxnnonmc)          :: new_Q_1
!    real(8), pointer, dimension(:,:,:)          :: new_Q_1

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : e-axis length
    !          7 : volume by riming
    !          8 : volume by aggregation
!tmp    real(PS), pointer, dimension(:,:)                     :: Qp
!tmp    real(PS), pointer, dimension(:)                        :: dummy_Vp
    real(PS), dimension(mxnbin+1,g_1%L,mxnnonmc+2)             :: Qp
!    real(PS), pointer, dimension(:,:,:)             :: Qp
!!!    real(PS), dimension(mxnnonmc+2,mxnbin+1,LMAX)             :: dummy_Vp

    ! averaged mass tendency after the time step for the bin
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
!    real(8), pointer, dimension(:,:)                       :: new_mtend
    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend
!    real(PS), pointer, dimension(:,:)                       :: mtend ! precision test, original 8

    ! axis change in shifted bins
!tmp    real(PS), pointer, dimension(:,:)            :: d_axis_len
!    real(PS), dimension(mxnbin+1,g_1%L,2)            :: d_axis_len
!    real(PS), pointer, dimension(:,:,:)            :: d_axis_len
    ! dummy axis change in shifted bins
!tmp    real(PS), pointer, dimension(:)            :: dum_dalen
    !real(PS), dimension(2)            :: dum_dalen

    ! total volume change in shifted bins
!tmp    real(PS), pointer, dimension(:)            :: d_vol
!tmp    real(PS), dimension(:)            :: d_vol

    ! collection Kernel
!tmp    real(PS), pointer, dimension(:,:)          :: KC
    real(PS), dimension(mxnbin,mxnbin,LMAX)          :: KC
!    real(PS), pointer, dimension(:,:,:)          :: KC
    ! coalescence efficiency
!tmp    real(PS), pointer, dimension(:,:)          :: E_coal
    real(PS), dimension(mxnbin,mxnbin,LMAX)          :: E_coal
!    real(PS), pointer, dimension(:,:,:)          :: E_coal

!!c    ! cross section area
!!c    real(PS), pointer, dimension(:,:)          :: carea
!!c    ! terminal velocity difference
!!c    real(PS), pointer, dimension(:,:)          :: vtdif

    ! number of collitional breakup
    real(PS)      :: N_bk
    ! ratio of concentration of fortune fraction to the total concentration in each bin
!tmp    real(PS), pointer, dimension(:) :: rat_Np
    real(PS), dimension(mxnbin) :: rat_Np
!    real(PS), pointer, dimension(:) :: rat_Np

!!c    ! breakup distribution
!!c    real (PS),pointer,dimension(:,:,:,:) :: BD
!!c    ! production of collection Kernel
!!c    real(PS), pointer, dimension(:)          :: prod_K
!!c    ! normalized kernel (conditional probability)
!!c    real(PS), pointer, dimension(:,:)          :: n_K
    !
    ! used concentration and mass for group 1
!tmp    real(PS), pointer, dimension(:)            :: used_N_1
!tmp    real(PS), pointer, dimension(:)            :: used_M_1
!tmp    real(PS),dimension(mxnbin)            :: used_N_1
!tmp    real(PS),dimension(mxnbin)            :: used_M_1
    ! used concentration and mass for group 2
!tmp    real(PS), pointer, dimension(:)            :: used_N_2
!tmp    real(PS), pointer, dimension(:)            :: used_M_2
    real(8),dimension(mxnbin,LMAX)            :: used_N_2
    real(8),dimension(mxnbin,LMAX)            :: used_M_2
!    real(8), pointer, dimension(:,:)            :: used_N_2
!    real(8), pointer, dimension(:,:)            :: used_M_2

    ! used marker
!tmp    integer, pointer, dimension(:)            :: used_marker
    integer,dimension(mxnbin,LMAX)            :: used_marker
!    integer, pointer, dimension(:,:)            :: used_marker
    ! collecting marker
!!c    integer, pointer, dimension(:)            :: collecting_marker

    ! used concentration for collisional breakup
!tmp    real(PS), pointer, dimension(:)            :: used_N_b !,used_M_b
    real(PS), dimension(mxnbin,LMAX)            :: used_N_b !,used_M_b
!    real(PS), pointer, dimension(:,:)            :: used_N_b !,used_M_b
    !real(PS) :: sum_M_b0,sum_M_b

    ! total concentration in the shifted bin
!tmp    real(PS), pointer, dimension(:)           :: Np
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd
!    real(PS), pointer, dimension(:,:)           :: Np
!    real(8), pointer, dimension(:,:)           :: Npd
    ! total mass in the shifted bin
!tmp    real(PS), pointer, dimension(:)           :: Mp
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd
!    real(PS), pointer, dimension(:,:)           :: Mp
!    real(8), pointer, dimension(:,:)           :: Mpd

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
!tmp    real(PS),pointer,dimension(:) :: axr_p
    real(PS),dimension(mxnbin+1,g_1%L,mxnaxis-1) :: axr_p
!    real(PS), pointer, dimension(:,:,:) :: axr_p
    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
!    real(PS), pointer, dimension(:,:)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
!    integer, pointer, dimension(:,:)          :: habit_p
    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
!    real(PS), pointer, dimension(:,:)              :: asr_p
    ! type in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: type_p
!    integer, pointer, dimension(:,:)          :: type_p


    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
!    real(PS), pointer, dimension(:,:)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
!    real(PS), pointer, dimension(:,:)           :: n_exice_p
    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p
!    real(PS), pointer, dimension(:,:)           :: actINF_p



    integer  :: i, ii, j, jj,jmax, k,n!,ij, var_Status
    integer,dimension(mxnbin+1,LMAX)             :: error_number
!    integer, pointer, dimension(:,:)             :: error_number
    ! type of collision-coalescence process
    integer                                    :: pro_type
    ! index of high collection rate group
!tmp    integer, pointer, dimension(:)            :: jbin_h
    integer, dimension(mxnbin,LMAX)            :: jbin_h
!    integer, pointer, dimension(:,:)            :: jbin_h
    ! index of low and medium collection rate group
!tmp    integer, pointer, dimension(:)            :: jbin_lm
    integer, dimension(mxnbin,LMAX)            :: jbin_lm
!    integer, pointer, dimension(:,:)            :: jbin_lm
    ! total number of sub-bins in a collector bin
    integer, dimension(LMAX)                   :: n_all
!    integer, pointer, dimension(:)                   :: n_all


    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,g_1%L,4)           :: a2d
!    real(8), pointer, dimension(:,:,:)           :: a2d
    real(8) :: a(4)

    ! concentration and mass to be moved into aerosol groups
    real(8),dimension(LMAX)            :: ap_dN, ap_dM
!    real(8), pointer, dimension(:)            :: ap_dN, ap_dM

    ! test
    real(PS),dimension(LMAX)      :: mod_ratio
!    real(PS), pointer, dimension(:)      :: mod_ratio
    !integer            :: isum_mod_ratio_m,isum_mod_ratio_n
    real(PS)            :: dM_dum
    real(PS)                         :: ndrop_B, ndrop_F, dum1, p_F
    real(PS),dimension(LMAX)      :: sum_ndrop_B
!    real(PS), pointer, dimension(:)      :: sum_ndrop_B
!tmp    real(PS), pointer, dimension(:)           :: dmass_max
!tmp    real(PS), pointer, dimension(:)           :: dmass_min
    real(PS), dimension(mxnbin+1,LMAX)           :: dmass_max
    real(PS), dimension(mxnbin+1,LMAX)           :: dmass_min
    integer,dimension(LMAX)            ::n_h, n_lm, n_f
    integer,dimension(LMAX)                 :: counter
!    real(PS), pointer, dimension(:,:)           :: dmass_max
!    real(PS), pointer, dimension(:,:)           :: dmass_min
!    integer, pointer, dimension(:)            ::n_h, n_lm, n_f
!    integer, pointer, dimension(:)                 :: counter


    ! total number of collected hydrometeors in j bin by i bin, N_col(i,j)
!tmp    real(PS), pointer, dimension(:,:)   ::  N_col
    real(PS),dimension(mxnbin,mxnbin,LMAX)   ::  N_col
!    real(PS), pointer, dimension(:,:,:)   ::  N_col
    ! ratio of collection to total concentration of collector, N_col/N_i
!tmp    real(PS), pointer, dimension(:)   ::  col_ratio
    real(PS),dimension(mxnbin,LMAX)   ::  col_ratio
!    real(PS), pointer, dimension(:,:)   ::  col_ratio

    ! left over
!tmp    real(PS), pointer, dimension(:)   ::  left_N, left_M
    real(PS), dimension(mxnbin,LMAX)   ::  left_N, left_M
!    real(PS), pointer, dimension(:,:)   ::  left_N, left_M

    ! total mass that each sub bin collects from jth bin
!tmp    real(PS), pointer, dimension(:,:)   ::  dM_col
    real(PS), dimension(mxnbin+1,mxnbin,LMAX)   ::  dM_col
!    real(PS), pointer, dimension(:,:,:)   ::  dM_col
    ! number of drops that each sub bin collects from jth bin
    ! per a parent drop
!tmp    real(PS), pointer, dimension(:,:)   ::  N_drops
    real(PS), dimension(mxnbin+1,mxnbin,LMAX)   ::  N_drops
!    real(PS), pointer, dimension(:,:,:)   ::  N_drops
    ! number of drops that each sub bin i collects from all the bins
    ! per a parent drop
!tmp    real(PS), pointer, dimension(:)   ::  dN_ice
    real(PS), dimension(mxnbin+1,LMAX)   ::  dN_ice
!    real(PS), pointer, dimension(:,:)   ::  dN_ice

    ! checker of collision, 0: no collision, 1: collide
!tmp    integer, pointer, dimension(:,:)       :: checker
    integer, dimension(mxnbin+1,mxnbin,LMAX)       :: checker
!    integer, pointer, dimension(:,:,:)       :: checker

    !real(PS) :: oNp

    ! bin boundary modification factor.
    real(PS),parameter    :: bbmf=0.2D0

    ! minimum collector mass to be considered.
    real(PS),parameter :: amin_mass=4.188790d-12
    integer :: icolbin_min

    !real(PS) :: max_a,max2_a,sum_dum1,sum_dum2,sum_dum3
    !integer :: imax,imax2
    integer :: n_h_max,n_lm_max,n_all_max,n_f_max,n_f_min
    integer :: i_d_ge_b,i_b_ge_d

    integer,parameter :: iter=30
    !integer :: ifix
    integer,dimension(LMAX) :: icycle_n,icond2_n
    integer,dimension(mxnbin,mxnbin,LMAX) :: icycle_ijn
!    integer,dimension((mxnbin+1)*LMAX) :: ierror
    integer,dimension(mxnbin,LMAX) :: icond1
    integer,dimension(mxnbin+1,LMAX) :: icond3
    logical :: idone_n,idone_m
    !real(PS) :: mmass_p_hex

! <<< 2014/10 T. Hashino added for KiD
!    integer :: isplit_bin_liq=10  ! binb(11) -> 25 micron
!    integer :: isplit_bin_liq = 11  ! binb(12) -> 32  micron
!    integer :: isplit_bin_liq = 12  ! binb(13) -> 42  micron
!    integer :: isplit_bin_liq = 13  ! binb(14) -> 55  micron
    real(8), dimension(mxnbin,LMAX)            :: new_N_tmp
    real(8), dimension(mxnbin,g_1%L,1+mxnmasscomp)          :: new_M_tmp
    real(8), dimension(mxnbin,g_1%L,mxnnonmc)          :: new_Q_tmp
    real(PS), dimension(mxnbin+1,LMAX)           :: dMp_auto, dMp_accr, Mp_ini
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend_tmp
    real(PS), dimension(mxnbin+1,LMAX)           :: dmass_max_auto
    real(PS), dimension(mxnbin+1,LMAX)           :: dmass_min_auto
    !real(8)            :: ap_dN_tmp, ap_dM_tmp
! >>> 2014/10 T. Hashino added for KiD

    character (len=5) :: pro_name




!!$    ! start initializing pointers
!!$    allocate(binb3d(mxnbin+1,g_1%L,2))
!!$    allocate(new_N_1(mxnbin,LMAX),new_M_1(mxnbin,g_1%L,1+mxnmasscomp))
!!$    allocate(ratio_M_2(mxnbin,1+mxnmasscomp,LMAX))
!!$    allocate(Mc(mxnbin+1,mxnmasscomp,LMAX))
!!$    allocate(ratio_Mp(mxnbin+1,g_1%L,mxnmasscomp))
!!$    allocate(ratio_Vp(mxnvol))
!!$    allocate(new_Q_1(mxnbin,g_1%L,mxnnonmc))
!!$    allocate(Qp(mxnbin+1,g_1%L,mxnnonmc+2))
!!$    allocate(new_mtend(mxnbin,LMAX),mtend(mxnbin+1,LMAX))
!!$    allocate(d_axis_len(mxnbin+1,g_1%L,2))
!!$    allocate(KC(mxnbin,mxnbin,LMAX))
!!$    allocate(E_coal(mxnbin,mxnbin,LMAX))
!!$    allocate(rat_Np(mxnbin))
!!$    allocate(used_N_2(mxnbin,LMAX),used_M_2(mxnbin,LMAX))
!!$    allocate(used_marker(mxnbin,LMAX))
!!$    allocate(used_N_b(mxnbin,LMAX))
!!$    allocate(Np(mxnbin+1,LMAX),Npd(mxnbin+1,LMAX))
!!$    allocate(Mp(mxnbin+1,LMAX),Mpd(mxnbin+1,LMAX))
!!$    allocate(axr_p(mxnbin+1,g_1%L,mxnaxis-1))
!!$    allocate(den_ip_p(mxnbin+1,LMAX),den_ic_p(mxnbin+1,LMAX))
!!$    allocate(asr_p(mxnbin+1,LMAX))
!!$    allocate(type_p(mxnbin+1,LMAX))
!!$    allocate(habit_p(mxnbin+1,LMAX))
!!$    allocate(rag_p(mxnbin+1,LMAX),rcg_p(mxnbin+1,LMAX))
!!$    allocate(n_exice_p(mxnbin+1,LMAX))
!!$    allocate(actINF_p(mxnbin+1,LMAX))
!!$    allocate(error_number(mxnbin+1,LMAX))
!!$    allocate(jbin_h(mxnbin,LMAX))
!!$    allocate(jbin_lm(mxnbin,LMAX))
!!$    allocate(n_all(LMAX))
!!$    allocate(a2d(mxnbin+1,g_1%L,4))
!!$    allocate(ap_dN(LMAX),ap_dM(LMAX))
!!$    allocate(mod_ratio(LMAX))
!!$    allocate(sum_ndrop_B(LMAX))
!!$    allocate(dmass_max(mxnbin+1,LMAX))
!!$    allocate(dmass_min(mxnbin+1,LMAX))
!!$    allocate(n_h(LMAX),n_lm(LMAX),n_f(LMAX))
!!$    allocate(counter(LMAX))
!!$    allocate(N_col(mxnbin,mxnbin,LMAX))
!!$    allocate(col_ratio(mxnbin,LMAX))
!!$    allocate(left_N(mxnbin,LMAX),left_M(mxnbin,LMAX))
!!$    allocate(dM_col(mxnbin+1,mxnbin,LMAX))
!!$    allocate(N_drops(mxnbin+1,mxnbin,LMAX))
!!$    allocate(dN_ice(mxnbin+1,LMAX))
!!$    allocate(checker(mxnbin+1,mxnbin,LMAX))
!!$    ! end of initialization of pointers

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! determine if the process is
    !                        rain drops catching rain drops        ( pro_type = 2 )
    !                        rain catching cloud droplets          ( pro_type = 8 )
    !                        cloud droplets and ice hydrometeors   ( pro_type = 3 )
    !                        rain drops and ice hydrometeors       ( pro_type = 4 )
    !                        ice hydrometeors and ice hydrometeors.( pro_type = 2 )
    !                        cloud droplets                        ( pro_type = 7 )
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if( g_1%token == g_2%token ) then
       pro_type = 2
       pro_name="agg"//achar(48+g_1%token)
    else if( g_1%token == 2 .and. g_2%token == 1 ) then
       pro_type = 4
       pro_name="rim"
    else if( g_1%token == 2 .and. g_2%token == 11 ) then
       pro_type = 3
    else if( g_1%token == 1 .and. g_2%token == 11 ) then
       pro_type = 9
    else if( g_1%token == 11 .and. g_2%token == 1 ) then
       pro_type = 7
    end if
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if( g_1%token == g_2%token .or. &
         (g_1%token == 2 .and. g_2%token == 1)) then
       !    -----------------------------------------------------------------------
       !    case of hyrometers catching hydrometeors
       !    -----------------------------------------------------------------------

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! figure out the minimum mass bin that can be a collector
       icolbin_min=1
       do i=1,g_1%N_bin
         if(g_1%binb(i+1)<amin_mass) then
           icolbin_min=i
         endif
       enddo
!!!       write(*,*) "icolbin_min is ",icolbin_min
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

! <<< 2014/10 T. Hashino added for KiD
       dM_auto(1:g_1%L)=0.0
       dM_accr(1:g_1%L)=0.0
! >>> 2014/10 T. Hashino added for KiD

!!c       goto 50

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! initialization
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       new_N_1(:,:)=0.0_PS
       new_N_tmp(:,:)=0.0_PS
       new_mtend(:,:)=0.0_PS
       new_mtend_tmp(:,:)=0.0_PS
       used_N_2(:,:)=0.0_PS
       used_M_2(:,:)=0.0_PS
       used_N_b(:,:)=0.0_PS
       used_marker(:,:) = 0

       new_M_1(:,:,:) = 0.0_PS
       new_M_tmp(:,:,:) = 0.0_PS
       ratio_M_2(:,:,:) = 0.0_PS

       new_Q_1(:,:,:) = 0.0_PS
       new_Q_tmp(:,:,:) = 0.0_PS

       N_col(:,:,:) = 0.0_PS
       icycle_ijn(:,:,:)=1

       icycle_n(:)=0

         !  these are not used.
!         ap_dN(n)=0.0e+0
!         ap_dM(n)=0.0e+0

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       do n=1,g_1%L
         if( mes_rc(n) == 0 ) then
           icycle_n(n)=1
         endif
         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! if the group does not have any hydrometeors, exit.
         ! all processes except autoconversion of cloud droplets requirs both groups.
         if( g_1%mark_cm(n) == 3 ) then
           icycle_n(n)=1
         else if( g_2%mark_cm(n) == 3 .and. pro_type /= 7 ) then
           icycle_n(n)=1
         end if
       enddo
!       do ijn=1,g_2%N_BIN*g_1%N_BIN*g_1%L
!         in=(ijn-1)/g_2%N_BIN+1
!         j=ijn-(in-1)*g_2%N_BIN
!         n=(in-1)/g_1%N_BIN+1
!         i=in-(n-1)*g_1%N_BIN
       do n = 1, g_1%L
       do i = 1, g_1%N_BIN
       do j = 1, g_2%N_BIN

         if( g_1%MS(i,n)%con > 1.0e-30_PS .and. &
             g_1%MS(i,n)%mass(1) > 1.0e-30_PS .and. &
             g_1%MS(i,n)%mean_mass > 1.0e-15_PS .and. &
             g_2%MS(j,n)%con > 1.0e-30_PS .and. &
             g_2%MS(j,n)%mass(1) > 1.0e-30_PS .and. &
             g_2%MS(j,n)%mean_mass > 1.0e-15_PS ) then
           icycle_ijn(i,j,n)=0
         endif
       enddo
       enddo
       enddo

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate the collection kernel function
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       do n=1,g_1%L
          if(icycle_n(n)==0) then
            call cal_collision_kernel_func(g_1,g_2,ag%TV(n),col_level,ibreak,&
               imin_bk,imax_bk,jmin_bk,jmax_bk,bu_tmass,&
               n,KC(:,:,n),E_coal(:,:,n), &
               adrpdrp,drpdrp,&
               ahexdrp,hexdrp,&
               abbcdrp,bbcdrp,&
               acoldrp,coldrp,&
               agp1drp,gp1drp,&
               agp4drp,gp4drp,&
               agp8drp,gp8drp)

!            if( g_2%token == 2 .or.level>=4) then
!              ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!              ! calculate the mass and volume ratio of collected group
!              call cal_massratio( g_2, n, ratio_M_2(1,1,n), level)
!!!              ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!            end if

          endif
       enddo

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate the mass and volume ratio of collected group
       if( g_2%token == 2 .or.level>=4) then
         call cal_massratio_3d( g_2, ratio_M_2)
       end if
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate total number of hydrometeor consumed for each bin, and
       ! if the number exceeds original amount, it is normalized.
       do i=g_1%N_BIN, 1, -1
!         do jn=1,g_2%n_bin*g_2%L
!           n=(jn-1)/g_2%N_BIN+1
!           j=jn-(n-1)*g_2%N_BIN
          do n = 1, g_2%L
          do j = 1, g_2%N_BIN

           if(icycle_ijn(i,j,n)==0) then

             ! +++ prevent errors from numerical diffusion +++
             ! NOTE: This part may depend on the precision setup
             if( g_1%MS(i,n)%con < 1.0e-30_PS .or. g_2%MS(j,n)%con < 1.0e-30_PS ) then
                N_col(i,j,n) = 0.0_PS
             else if( KC(i,j,n) > 0.0_PS ) then
                ! --- only consider the case of i catching j +++
                N_col(i,j,n) =  g_1%MS(i,n)%con * KC(i,j,n)
             else if( KC(i,j,n) < 0.0_PS .and. g_1%token /= g_2%token ) then
                ! --- case of riming, both the cases: ice catching drops, and
                !     drops catching ice contribute growth of ice
                N_col(i,j,n) =  g_1%MS(i,n)%con * abs(KC(i,j,n))
             end if

             if( N_col(i,j,n) > g_2%MS(j,n)%con ) then
                N_col(i,j,n) = g_2%MS(j,n)%con
             end if
             used_N_2(j,n)=used_N_2(j,n)+N_col(i,j,n)*E_coal(i,j,n)
             used_M_2(j,n)=used_M_2(j,n)+N_col(i,j,n)*E_coal(i,j,n)*g_2%MS(j,n)%mean_mass
           endif
         enddo
         enddo
       enddo

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate consumed con and mass by breakup process
       if(ibreak==1) then
         do i=1,g_1%N_BIN
!           do jn=1,g_2%n_bin*g_2%L
!             n=(jn-1)/g_2%N_BIN+1
!             j=jn-(n-1)*g_2%N_BIN
            do n = 1, g_2%L
            do j = 1, g_2%N_BIN
             if(icycle_ijn(i,j,n)==0) then
               N_bk=N_col(i,j,n)*max(0.0_PS,1.0_PS-E_coal(i,j,n))
               used_N_b(j,n)=used_N_b(j,n)+N_bk
             endif
           enddo
           enddo
         enddo
         do j=1,g_2%N_BIN
!           do in=1,g_1%n_bin*g_1%L
!             n=(in-1)/g_1%N_BIN+1
!             i=in-(n-1)*g_1%N_BIN
            do n = 1, g_1%L
            do i = 1, g_1%N_BIN
             if(icycle_ijn(i,j,n)==0) then
               N_bk=N_col(i,j,n)*max(0.0_PS,1.0_PS-E_coal(i,j,n))
               used_N_b(i,n)=used_N_b(i,n)+N_bk
             endif
           enddo
           enddo
         enddo

!         do in=1,g_1%n_bin*g_1%L
!           n=(in-1)/g_1%N_BIN+1
!           i=in-(n-1)*g_1%N_BIN
         do n = 1, g_1%L
         do i = 1, g_1%N_BIN
           if(icycle_n(n)==0) then
             used_N_2(i,n)=used_N_2(i,n)+used_N_b(i,n)
             used_M_2(i,n)=used_M_2(i,n)+used_N_b(i,n)*g_2%MS(i,n)%mean_mass
           endif
         enddo
         enddo
       end if
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! Fix over-depletion
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       do i=1,g_2%N_BIN

         iter_loop1: do ii=1,iter
           mod_ratio(1:g_2%L)=1.0_PS
           icond2_n(1:g_2%L)=0
           do n=1,g_2%L
             if( g_2%MS(i,n)%con<used_N_2(i,n) ) then
               mod_ratio(n)=g_2%MS(i,n)%con/used_N_2(i,n)
               icond2_n(n)=1
             endif
           enddo
           idone_n=.true.
!!!           write(*,*) "iter-1:",i,ii,sum(icond2_n(1:g_2%L))
           if(any(icond2_n(1:g_2%L)>0)) then
             idone_n=.false.
!             do jn=1,g_1%n_bin*g_1%L
!               n=(jn-1)/g_1%N_BIN+1
!               j=jn-(n-1)*g_1%N_BIN
             do n = 1, g_1%L
             do j = 1, g_1%N_BIN
               N_col(j,i,n)=N_col(j,i,n)*min(1.0_PS,mod_ratio(n))
             enddo
             enddo
             ! Initialize used_M_2 with 0 if mod_ratio is less than 1.
             do n=1,g_2%L
               used_M_2(i,n)=used_M_2(i,n)*(1.0-real(icond2_n(n),PS_KIND))
             enddo
             do j=1,g_1%N_BIN
               do n=1,g_2%L
                 if(icond2_n(n)==1) then
                   used_M_2(i,n)=used_M_2(i,n)+N_col(j,i,n)*E_coal(j,i,n)*g_2%MS(i,n)%mean_mass
                 endif
               enddo
             enddo
             do n=1,g_2%L
               if(icond2_n(n)==1) then
                 used_N_2(i,n)=g_2%MS(i,n)%con
                 used_marker(i,n)=1
               endif
             enddo

             if(ibreak==1) then
!               do jn=1,g_1%n_bin*g_1%L
!                 n=(jn-1)/g_1%N_BIN+1
!                 j=jn-(n-1)*g_1%N_BIN
                do n = 1, g_1%L
                do j = 1, g_1%N_BIN
                   if(j/=i) then
                      N_col(i,j,n)=N_col(i,j,n)*min(1.0_PS,mod_ratio(n))
                   endif
                enddo
                enddo

               used_N_b(:,:)=0.0_PS
               do j=1,g_1%N_BIN
!                 do kn=1,g_2%n_bin*g_2%L
!                   n=(kn-1)/g_2%N_BIN+1
!                   k=kn-(n-1)*g_2%N_BIN
                  do n = 1, g_2%L
                  do k = 1, g_2%N_BIN
                     if(icycle_ijn(j,k,n)==0.and.icond2_n(n)==1) then
                        N_bk=N_col(j,k,n)*max(0.0_PS,1.0_PS-E_coal(j,k,n))
                        used_N_b(k,n)=used_N_b(k,n)+N_bk
                     endif
                  end do
                  end do
               end do
               do k=1,g_2%N_BIN
!                 do jn=1,g_1%n_bin*g_1%L
!                   n=(jn-1)/g_1%N_BIN+1
!                   j=jn-(n-1)*g_1%N_BIN
                  do n = 1, g_1%L
                  do j = 1, g_1%N_BIN
                     if(icycle_ijn(j,k,n)==0.and.icond2_n(n)==1) then
                        N_bk=N_col(j,k,n)*max(0.0_PS,1.0_PS-E_coal(j,k,n))
                        used_N_b(j,n)=used_N_b(j,n)+N_bk
                     endif
                  end do
                  end do
               end do
               do n=1,g_2%L
                 if(icond2_n(n)==1) then
                   used_M_2(i,n)=used_M_2(i,n)+used_N_b(i,n)*g_2%MS(i,n)%mean_mass
                 endif
               enddo
             endif
           endif

           mod_ratio(1:g_2%L)=1.0_PS
           icond2_n(1:g_2%L)=0
           do n=1,g_2%L
             if( g_2%MS(i,n)%mass(1)<used_M_2(i,n) ) then
               mod_ratio(n)=g_2%MS(i,n)%mass(1)/used_M_2(i,n)
               icond2_n(n)=1
             endif
           enddo
!!!           write(*,*) "iter-2:",i,ii,sum(icond2_n(1:g_2%L))
           idone_m=.true.
           if(any(icond2_n(1:g_2%L)>0)) then
             idone_m=.false.
!             do jn=1,g_1%n_bin*g_1%L
!               n=(jn-1)/g_1%N_BIN+1
!               j=jn-(n-1)*g_1%N_BIN
             do n = 1, g_1%L
             do j = 1, g_1%N_BIN
               N_col(j,i,n)=N_col(j,i,n)*min(1.0_PS,mod_ratio(n))
             enddo
             enddo
             ! Initialize used_N_2 with 0 if mod_ratio is less than 1.
             do n=1,g_2%L
               used_N_2(i,n)=used_N_2(i,n)*(1.0-real(icond2_n(n),PS_KIND))
             enddo
             do j=1,g_1%N_BIN
               do n=1,g_2%L
                 if(icond2_n(n)==1) then
                   used_N_2(i,n)=used_N_2(i,n)+N_col(j,i,n)*E_coal(j,i,n)
                 endif
               enddo
             enddo
             do n=1,g_2%L
               if(icond2_n(n)==1) then
                 used_M_2(i,n)=g_2%MS(i,n)%mass(1)
                 used_marker(i,n)=1
               endif
             enddo

             if(ibreak==1) then
!               do jn=1,g_1%n_bin*g_1%L
!                 n=(jn-1)/g_1%N_BIN+1
!                 j=jn-(n-1)*g_1%N_BIN
                do n = 1, g_1%L
                do j = 1, g_1%N_BIN
                   if(j/=i) then
                      N_col(i,j,n)=N_col(i,j,n)*min(1.0_PS,mod_ratio(n))
                   endif
                enddo
                enddo

                used_N_b(:,:)=0.0_PS
                do j=1,g_1%N_BIN
!                 do kn=1,g_2%n_bin*g_2%L
!                   n=(kn-1)/g_2%N_BIN+1
!                   k=kn-(n-1)*g_2%N_BIN
                   do n = 1, g_2%L
                   do k = 1, g_2%N_BIN
                      if(icycle_ijn(j,k,n)==0.and.icond2_n(n)==1) then
                         N_bk=N_col(j,k,n)*max(0.0_PS,1.0_PS-E_coal(j,k,n))
                         used_N_b(k,n)=used_N_b(k,n)+N_bk
                      endif
                   end do
                   end do
               end do
               do k=1,g_2%N_BIN
!                 do jn=1,g_1%n_bin*g_1%L
!                   n=(jn-1)/g_1%N_BIN+1
!                   j=jn-(n-1)*g_1%N_BIN
                  do n = 1, g_1%L
                  do j = 1, g_1%N_BIN
                     if(icycle_ijn(j,k,n)==0.and.icond2_n(n)==1) then
                        N_bk=N_col(j,k,n)*max(0.0_PS,1.0_PS-E_coal(j,k,n))
                        used_N_b(j,n)=used_N_b(j,n)+N_bk
                     endif
                  end do
                  end do
               end do
               do n=1,g_2%L
                 if(icond2_n(n)==1) then
                   used_N_2(i,n)=used_N_2(i,n)+used_N_b(i,n)
                 endif
               enddo
             endif
           endif

           if(idone_n.and.idone_m) then
             exit
           endif
         enddo iter_loop1
       enddo

!       do n=1,g_2%L
!         do i=1,g_2%N_BIN
!           if(used_N_b(i,n)>0.0_PS) then
!             write(*,'("ck used2:",2I5,3ES15.6)') i,n,used_N_2(i,n),used_M_2(i,n),used_N_b(i,n)
!           endif
!         enddo
!       enddo

       ! figure out if a grid does not have anytings colliding.
       counter(1:g_2%L)=0
       do i=1,g_2%N_BIN
         do n=1,g_2%L
           if(used_N_2(i,n)>0.0_PS) then
             counter(n)=counter(n)+1
           endif
         enddo
       enddo
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate the left hydrometeors of group 2
       if( g_1%token == g_2%token ) then
!         do in=1,g_1%n_bin*g_1%L
!           n=(in-1)/g_1%N_BIN+1
!           i=in-(n-1)*g_1%N_BIN
          do n = 1, g_1%L
          do i = 1, g_1%N_BIN
           left_N(i,n)=max(g_2%MS(i,n)%con-used_N_2(i,n),0.0_DS)
           left_M(i,n)=max(g_2%MS(i,n)%mass(1)-used_M_2(i,n),0.0_DS)
         end do
         end do
       else
!         do in=1,g_1%n_bin*g_1%L
!           n=(in-1)/g_1%N_BIN+1
!           i=in-(n-1)*g_1%N_BIN
          do n = 1, g_1%L
          do i = 1, g_1%N_BIN
           left_N(i,n) = g_1%MS(i,n)%con
           left_M(i,n) = g_1%MS(i,n)%mass(1)
         end do
         end do
       end if

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate the mass change on boundaries and shift bins.

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! initialization
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       used_M_2(:,:) = 0.0_PS
       used_N_b(:,:) = 0.0_PS

       icond1(:,:)=0


       jmax = g_2%N_BIN


       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! check if there is no mass or concentration in the bin
!       do in=1,g_1%N_bin*g_1%L
!         n=(in-1)/g_1%N_bin+1
!         i=in-(n-1)*g_1%N_bin
       do n = 1, g_1%L
       do i = 1, g_1%N_bin
         if(icycle_n(n)==0.and.&
            counter(n)>0.and.&
           (g_1%MS(i,n)%con > 1.0e-30_PS .and. &
            g_1%MS(i,n)%mass(1) > 1.0e-30_PS .and. &
            g_1%MS(i,n)%mean_mass > 1.0e-15_PS ).and. &
            ! check if all the hydrometeors are going to be consumed or not
           (used_marker(i,n) /= 1 .or. pro_type /= 2 ) ) then
           icond1(i,n)=1
!!!           write(*,*) "ck0: icond1==1",i,n
         endif
       enddo
       enddo
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       collector_loop1: do i=g_1%N_bin,icolbin_min,-1
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! initialization
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!         do n=1,g_1%L
!           if(icond1(19,n)==1) then
!             write(*,'("ck2-0: icond1==1",2I5,10ES15.6)') i,n,g_1%MS(19,n)%con, &
!                g_1%MS(19,n)%mass(1:2),g_1%MS(19,n)%mean_mass
!           endif
!         enddo

          n_h(:) = 0
          n_lm(:) = 0
          n_all(:) = 0
          n_f(:) = 0

          jbin_h(:,:) = 0
          jbin_lm(:,:) = 0
          col_ratio(:,:) = 0.0_PS

          error_number(:,:) = 0
          icond3(:,:)=0

          Np(:,:)=0.0_PS
          Mp(:,:)=0.0_PS
          dN_ice(:,:) = 0.0_PS
          mtend(:,:) = 0.0_PS
          binb3d(:,:,:)=0.0_PS
          Npd(:,:)=0.0_PS
          Mpd(:,:)=0.0_PS
          dmass_max(:,:) = 0.0_PS
          dmass_min(:,:) = 0.0_PS
          dmass_max_auto(:,:) = 0.0_PS
          dmass_min_auto(:,:) = 0.0_PS
!   <<< 2014/10 T. Hashino added for KiD
          Mp_ini(:,:)=0.0_PS
          dMp_auto(:,:)=0.0_PS
          dMp_accr(:,:)=0.0_PS
! >>> 2014/10 T. Hashino added for KiD

          Mc(:,:,:) = 0.0_PS

          Qp(:,:,:) = 0.0_RP

          dM_col(:,:,:) = 0.0_PS
          N_drops(:,:,:) = 0.0_PS

!         do n=1,g_1%L
!           if(icond1(19,n)==1) then
!             write(*,'("ck2-1: icond1==1",2I5,10ES15.6)') i,n,g_1%MS(19,n)%con, &
!                g_1%MS(19,n)%mass(1:2),g_1%MS(19,n)%mean_mass
!           endif
!         enddo

         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! categorize bins into the collection rate groups
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         do j= jmax, 1, -1
           do n=1,g_1%L
             if(icond1(i,n)==1) then
               col_ratio(j,n) = E_coal(i,j,n)*N_col(i,j,n)/g_1%MS(i,n)%con
!!c                col_ratio(j)=N_col(i,j)/g_1%MS(i,n)%con
               if( N_col(i,j,n) > 0.0_PS ) then
                 if( col_ratio(j,n) < 0.0_PS ) then
!org                   write(*,*) "ERROR! N_col/N_2 is negative!!!"
!org                   stop
                 else if( col_ratio(j,n) > 10.0_PS ) then
                   n_h(n) = n_h(n) + 1
                   jbin_h(n_h(n),n) = j
                 else if( col_ratio(j,n) > 0.0_PS .and. col_ratio(j,n) < 1.0_PS ) then
                   n_lm(n) = n_lm(n) + 1
                   jbin_lm(n_lm(n),n) = j
                 else if( col_ratio(j,n) >= 1.0_PS .and. col_ratio(j,n) <= 10.0_PS ) then
                   n_h(n) = n_h(n) + 1
                   jbin_h(n_h(n),n) = j
                   n_lm(n) = n_lm(n) + 1
                   jbin_lm(n_lm(n),n) = j
                 endif
               end if
             end if
           end do
         end do
         n_lm_max=maxval(n_lm(1:g_1%L))
         n_h_max=maxval(n_h(1:g_1%L))


         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! determine the non-overlapping fraction of the bin
         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         sum_ndrop_B(1:g_1%L) = 0.0_PS
         icond2_n(1:g_1%L)=0
         do jj= 1, n_lm_max
           do n=1,g_1%L
             if(icond1(i,n)==1.and.jj<=n_lm(n).and.icond2_n(n)==0) then
               j = jbin_lm(jj,n)
               if( col_ratio(j,n) > 0.0_PS .and. col_ratio(j,n) < 1.0_PS ) then
                 p_F = col_ratio(j,n)
                 sum_ndrop_B(n) = sum_ndrop_B(n) + p_F
               else if( col_ratio(j,n) >= 1.0_PS .and. col_ratio(j,n) <= 10.0_PS ) then
                 p_F = col_ratio(j,n) - aint(col_ratio(j,n))
                 sum_ndrop_B(n) = sum_ndrop_B(n) + p_F
               else
                 p_F = -1.0_PS
               end if
               if(p_F>0.0_PS) then
                 if( sum_ndrop_B(n) >= 1.0_PS ) then
                   sum_ndrop_B(n) = sum_ndrop_B(n) - p_F ! subtract back as sum (R) > 1
                   icond2_n(n)=1 ! these g2 bins are excluded as sum (R) > 1
                 else
                   Np(jj,n)=p_F*left_N(i,n) ! this is the fraction of g1 particles that will collide
                   Mp(jj,n) = Np(jj,n)*g_1%MS(i,n)%mean_mass ! this is the total original mass
                   n_f(n) = n_f(n) + 1
                 end if
               end if
             end if
           end do
         end do
         ! +++ determine the unfortunate group +++
         do n=1,g_1%L
           if(icond1(i,n)==1.and.left_N(i,n)>0.0_PS) then
             n_all(n) = n_f(n) + 1
             Np(n_all(n),n) = (1.0_PS - sum_ndrop_B(n)) * left_N(i,n) ! the remaining g1 unfortunate
             Mp(n_all(n),n) = Np(n_all(n),n)*g_1%MS(i,n)%mean_mass ! the remaining g1 unfortunate mass
!!!             write(*,*) "ck np",n,i,np(n_all(n),n),sum_ndrop_b(n),left_n(i,n)
           endif
         enddo

         n_f_max=maxval(n_f(1:g_1%L))
         n_all_max=maxval(n_all(1:g_1%L))
         n_f_min=100000
         do n=1,g_1%L
           if(icond1(i,n)==1) then
             if(n_f_min>n_f(n)) then
               n_f_min=n_f(n)
             endif
           endif
         enddo
!         if(n_all_max>0) then
!           write(*,'("check lmt",6I7)') i,n_lm_max,n_h_max,n_f_max,n_f_min,n_all_max
!         endif
!         do n=1,g_1%L
!           do j=1,n_all(n)
!             if(icond1(i,n)==1.and.Np(j,n)>0.0) then
!               write(*,'("ck np,mp",3I5,50ES15.6)') n,i,j,Np(j,n),Mp(j,n)
!             endif
!           enddo
!         enddo

!         do n=1,g_1%L
!           if(icond1(19,n)==1) then
!             write(*,'("ck2: icond1==1",2I5,10ES15.6)') i,n,g_1%MS(19,n)%con, &
!                g_1%MS(19,n)%mass(1:2),g_1%MS(19,n)%mean_mass
!           endif
!         enddo

         ! +++ initialize the mass and volume components +++
         if(level>=4.and.g_1%token==1) then
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
            do n = 1, g_1%L
            do j = 1, n_all_max
             if(Mp(j,n)<1.0e-28_PS.and.j<=n_all(n)) then
               Mp(j,n)=0.0_PS
               Np(j,n)=0.0_PS
             endif
           enddo
           enddo
           do k = 1, g_1%N_masscom
!             do jn=1,n_all_max*g_1%L
!               n=(jn-1)/n_all_max+1
!               j=jn-(n-1)*n_all_max
              do n = 1, g_1%L
              do j = 1, n_all_max
                 if(j<=n_all(n)) then
                    if(Mp(j,n)<1.0e-28_PS) then
                       Mc(j,k,n)=0.0_PS
                    else
                       Mc(j,k,n) = Mp(j,n)*(g_1%MS(i,n)%mass(1+k)/g_1%MS(i,n)%mass(1))
                    endif
                 endif
              enddo
              enddo
           end do
         elseif( g_1%token == 2 ) then
           do k = 1, g_1%N_masscom
!             do jn=1,n_all_max*g_1%L
!               n=(jn-1)/n_all_max+1
!               j=jn-(n-1)*n_all_max
              do n = 1, g_1%L
              do j = 1, n_all_max
               if(j<=n_all(n)) then
                 Mc(j,k,n) = Mp(j,n)*(g_1%MS(i,n)%mass(1+k)/g_1%MS(i,n)%mass(1))
               endif
             enddo
             enddo
           enddo
!!c                      write(*,*) "ice crystal mass comp is small"
!!c                      write(*,'("mass com",10ES16.5)') (Mc(j,k),k=1,g_1%N_masscom)
!!c                      write(*,'("i,j,mp,np",2I5,2ES15.6)') i,j,Np(j),Mp(j)
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
           do n = 1, g_1%L
           do j = 1, n_all_max
             if(Mc(j,imc_m,n)<=1.0e-30_PS.and.j<=n_all(n)) then
               Mp(j,n)=0.0_PS
               Np(j,n)=0.0_PS
             endif
           enddo
           enddo
           do k = 1, g_1%N_masscom
!             do jn=1,n_all_max*g_1%L
!               n=(jn-1)/n_all_max+1
!               j=jn-(n-1)*n_all_max
              do n = 1, g_1%L
              do j = 1, n_all_max
                 if(Mp(j,n)<1.0e-30_PS.and.j<=n_all(n)) then
                    Mc(j,k,n)=0.0_PS
                 endif
              enddo
              enddo
           end do
         end if

! <<< 2014/10 T. Hashino added for KiD
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           if(j<=n_all(n)) then
             Mp_ini(j,n)=Mp(j,n)
           endif
         enddo
         enddo
! >>> 2014/10 T. Hashino added for KiD

         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! collect the hydrometeors in high collection reates
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         do jj = 1, n_h_max
!           do kn=1,n_all_max*g_1%L
!             n=(kn-1)/n_all_max+1
!             k=kn-(n-1)*n_all_max
            do n = 1, g_1%L
            do k = 1, n_all_max

             if(icond1(i,n)==1.and.jj<=n_h(n).and.k<=n_all(n)) then
               j=jbin_h(jj,n)
               if( col_ratio(j,n) >= 1.0_PS .and. col_ratio(j,n) <= 10.0_PS ) then
                 ndrop_B = aint(col_ratio(j,n))
               else
                 ndrop_B = col_ratio(j,n)
               end if
               dM_dum = ndrop_B * g_1%MS(i,n)%con * g_2%MS(j,n)%mean_mass * &
                        (Np(k,n)/max(left_N(i,n),1e-30_PS)) ! fraction of the subbin, total summation is one
               Mp(k,n) = Mp(k,n) + dM_dum
               dmass_max(k,n) = dmass_max(k,n) + ndrop_B * g_2%binb(j+1)
               dmass_min(k,n) = dmass_min(k,n) + ndrop_B * g_2%binb(j)

               dM_col(k,j,n) = dM_col(k,j,n) + dM_dum
               ! +++ add up what was used for coalescence process +++
               used_M_2(j,n) = used_M_2(j,n) + dM_dum
               if( used_M_2(j,n) >= g_2%MS(j,n)%mass(1) ) then
                 used_M_2(j,n) = g_2%MS(j,n)%mass(1)
                 used_marker(j,n) = 1
               end if

               N_drops(k,j,n) = N_drops(k,j,n) + ndrop_B

! <<< 2014/10 T. Hashino added for KiD
               if(g_1%token==1.and.g_2%token==1) then
                 if(max(g_1%binb(i+1),g_2%binb(j+1))<=g_1%binb(isplit_bin_liq+1)) then
                   dMp_auto(k,n)=dMp_auto(k,n)+dM_dum
                   dmass_max_auto(k,n) = dmass_max_auto(k,n) + ndrop_B * g_2%binb(j+1)
                   dmass_min_auto(k,n) = dmass_min_auto(k,n) + ndrop_B * g_2%binb(j)
                 elseif(g_1%binb(i)>=g_1%binb(isplit_bin_liq+1).and.&
                        g_2%binb(j+1)<=g_1%binb(isplit_bin_liq+1)) then
!                       write(*,'("ck g1con,1:",I5,10ES15.6)') n,g_1%MS(i,n)%con,g_2%MS(j,n)%con &
!                          ,dM_dum
                   dMp_accr(k,n)=dMp_accr(k,n)+dM_dum
                 endif
               endif
! >>> 2014/10 T. Hashino added for KiD
             endif
           end do
           end do
         end do
!         do n=1,g_1%L
!           if(icond1(i,n)==1) then
!             do j=1,n_all(n)
!               write(*,'("ck np,mp_H:",3I5,50ES15.6)') n,i,j,Np(j,n),Mp(j,n)
!             enddo
!           endif
!         enddo

         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! case where the fortunate groups collect
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!         do jn=1,n_f_max*g_1%L
!           n=(jn-1)/n_f_max+1
!           jj=jn-(n-1)*n_f_max
         do n = 1, g_1%L
         do jj = 1, n_f_max
           if(icond1(i,n)==1.and.jj<=n_f(n)) then
             j = jbin_lm(jj,n)

             ndrop_F = 1.0_PS

             if( col_ratio(j,n) > 0.0_PS .and. col_ratio(j,n) < 1.0_PS ) then
               p_F = 0.0_PS
               dM_dum = N_col(i,j,n)*E_coal(i,j,n)*g_2%MS(j,n)%mean_mass
             else if( col_ratio(j,n) >= 1.0_PS .and. col_ratio(j,n) <= 10.0_PS ) then
               p_F = col_ratio(j,n)-aint(col_ratio(j,n))
               dM_dum = p_F * g_1%MS(i,n)%con * g_2%MS(j,n)%mean_mass
             else
               p_F = 0.0_PS
               dM_dum = 0.0_PS
             end if
             Mp(jj,n) = Mp(jj,n) + dM_dum
             dM_col(jj,j,n) = dM_col(jj,j,n) + dM_dum

             ! for fortunate growth group
             dmass_max(jj,n) = dmass_max(jj,n) + ndrop_F * g_2%binb(j+1)
             dmass_min(jj,n) = dmass_min(jj,n) + ndrop_F * g_2%binb(j)

             ! +++ add up what was used for coalescence process +++
             used_M_2(j,n) = used_M_2(j,n) + dM_dum
             if( used_M_2(j,n) >= g_2%MS(j,n)%mass(1) ) then
               used_M_2(j,n) = g_2%MS(j,n)%mass(1)
             end if

             N_drops(jj,j,n) = N_drops(jj,j,n) + ndrop_F

! <<< 2014/10 T. Hashino added for KiD
             if(g_1%token==1.and.g_2%token==1) then
               if(max(g_1%binb(i+1),g_2%binb(j+1))<=g_1%binb(isplit_bin_liq+1)) then

                 dMp_auto(jj,n)=dMp_auto(jj,n)+dM_dum
                 dmass_max_auto(jj,n) = dmass_max_auto(jj,n) + ndrop_F * g_2%binb(j+1)
                 dmass_min_auto(jj,n) = dmass_min_auto(jj,n) + ndrop_F * g_2%binb(j)
               elseif(g_1%binb(i)>=g_1%binb(isplit_bin_liq+1).and.&
                      g_2%binb(j+1)<=g_1%binb(isplit_bin_liq+1)) then
                 dMp_accr(jj,n)=dMp_accr(jj,n)+dM_dum
               endif
             endif
! >>> 2014/10 T. Hashino added for KiD
           endif
         enddo
         enddo
!         do n=1,g_1%L
!           if(icond1(i,n)==1) then
!             do j=1,n_all(n)
!               write(*,'("ck np,mp_F:",3I5,50ES15.6)') n,i,j,Np(j,n),Mp(j,n)
!             enddo
!           endif
!         enddo


         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! case where the left-over exists
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         do jj= (n_f_min+1), n_lm_max
!           do kn=1,n_all_max*g_1%L
!             n=(kn-1)/n_all_max+1
!             k=kn-(n-1)*n_all_max
            do n = 1, g_1%L
            do k = 1, n_all_max
             if(icond1(i,n)==1.and.k<=n_all(n).and.jj<=n_lm(n).and.jj>=n_f(n)+1) then
               j = jbin_lm(jj,n)
               if( col_ratio(j,n) > 0.0_PS .and. col_ratio(j,n) < 1.0_PS ) then
                 p_F = col_ratio(j,n)
               else if( col_ratio(j,n) >= 1.0_PS .and. col_ratio(j,n) <= 10.0_PS ) then
                 p_F = col_ratio(j,n)-aint(col_ratio(j,n))
               else
                 p_F = 0.0_PS
               end if
               ndrop_B = p_F

               dM_dum = p_F * g_1%MS(i,n)%con * g_2%MS(j,n)%mean_mass * &
                        (Np(k,n)/max(left_N(i,n),1e-30_PS))
               Mp(k,n) = Mp(k,n) + dM_dum
               dmass_max(k,n) = dmass_max(k,n) + ndrop_B * g_2%binb(j+1)
               dmass_min(k,n) = dmass_min(k,n) + ndrop_B * g_2%binb(j)

               dM_col(k,j,n) = dM_col(k,j,n) + dM_dum
               ! +++ add up what was used for coalescence process +++
               used_M_2(j,n) = used_M_2(j,n) + dM_dum
               if( used_M_2(j,n) >= g_2%MS(j,n)%mass(1) ) then
                 used_M_2(j,n) = g_2%MS(j,n)%mass(1)
               end if

               N_drops(k,j,n) = N_drops(k,j,n) + ndrop_B

! <<< 2014/10 T. Hashino added for KiD
               if(g_1%token==1.and.g_2%token==1) then
                 if(max(g_1%binb(i+1),g_2%binb(j+1))<=g_1%binb(isplit_bin_liq+1)) then
                   dMp_auto(k,n)=dMp_auto(k,n)+dM_dum
                   dmass_max_auto(k,n) = dmass_max_auto(k,n) + ndrop_B * g_2%binb(j+1)
                   dmass_min_auto(k,n) = dmass_min_auto(k,n) + ndrop_B * g_2%binb(j)
                 elseif(g_1%binb(i)>=g_1%binb(isplit_bin_liq+1).and.&
                        g_2%binb(j+1)<=g_1%binb(isplit_bin_liq+1)) then
                   dMp_accr(k,n)=dMp_accr(k,n)+dM_dum
                 endif
               endif
! >>> 2014/10 T. Hashino added for KiD
             endif
           end do
           end do
         end do

!         do n=1,g_1%L
!           if(icond1(i,n)==1) then
!             do j=1,n_all(n)
!               write(*,'("ck np,mp_L:",3I5,50ES15.6)') n,i,j,Np(j,n),Mp(j,n)
!             enddo
!           endif
!         enddo

         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! calculate quality variables
         call cal_Qp2_vec( g_1, g_2, icond1, i, n_all, &
                          N_drops, Qp, checker, dN_ice)

         if(debug) then
           if(pro_type==4) then
!             do jn=1,n_all_max*g_1%L
!               n=(jn-1)/n_all_max+1
!               j=jn-(n-1)*n_all_max
!               ierror(jn)=0
              do n = 1, g_1%L
              do j = 1, n_all_max
                 if( icond1(i,n)==1.and.j<=n_all(n) &
                      .and. np(j,n)>1.0e-30.and.Qp(j,n,iccr)/Qp(j,n,iacr)>2.0_PS ) then
                    write(*,*) "axis check 1:",j,KD(n),ID(n),JD(n)
                    write(*,*) "alen,clen,phi",j,n,qp(j,n,iacr),qp(j,n,iccr),&
                         qp(j,n,iccr)/qp(j,n,iacr)
                    write(*,*) "np,mp",j,n,np(j,n),mp(j,n)
                 endif
              enddo
              enddo
           endif
         endif

!         if( g_1%token == 2 .and. pro_type==2) then
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
!             if(icond1(i,n)==1.and.j<=n_all(n)) then
!               write(*,'("ck-1 qp1:",3I5,10ES15.6)') i,j,n,qp(j,n,1)
!             endif
!           enddo
!         endif

         ! check if no collision occurred based on rime density formula
         if( g_1%token == 2 .and. g_2%token == 1) then   ! 2014/10 tempei bug found
!           do jkn=1,n_all_max*g_2%N_BIN*g_2%L
!             kn=(jkn-1)/n_all_max+1
!             j=jkn-(kn-1)*n_all_max
!             n=(kn-1)/g_2%N_BIN+1
!             k=kn-(n-1)*g_2%N_BIN
            do n = 1, g_2%L
            do k = 1, g_2%N_BIN
            do j = 1, n_all_max

             if(icond1(i,n)==1.and.j<=n_all(n)) then
               if( N_drops(j,k,n) > 0.0_PS .and. checker(j,k,n) == 0) then
                 dM_dum = N_drops(j,k,n)*&
                       g_1%MS(i,n)%con*g_2%MS(k,n)%mean_mass*(Np(j,n)/max(left_N(i,n),1e-30_PS))

                 Mp(j,n)=Mp(j,n)-dM_dum
                 dmass_max(j,n)=dmass_max(j,n)-N_drops(j,k,n)*g_2%binb(k+1)
                 dmass_min(j,n)=dmass_min(j,n)-N_drops(j,k,n)*g_2%binb(k)
                 used_N_2(k,n)=used_N_2(k,n)-N_drops(j,k,n)*g_1%MS(i,n)%con
                 used_M_2(k,n)=used_M_2(k,n)-dM_dum

!tmp                  write(*,'("No collision:",5I5,10ES15.6)') KD(n),i,n_all,k,j,N_col(i,j,n),N_drops(k,j) &
!tmp                    ,g_1%MS(i,n)%con
!tmp                  stop
               end if
             end if
           end do
           end do
           end do
         end if
         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! Map the shifted bin into original bins.
         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

         ! check if there is no mass or concentration in the bin
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           if(icond1(i,n)==1.and.j<=n_all(n)) then
             if( Np(j,n) > 1.0e-30_PS .and. Mp(j,n) > 1.0e-30_PS ) then
               icond3(j,n)=1
             endif
           endif
         enddo
         enddo

         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! calculation of
         !     1. ratio of each increased mass components to total mass
         ratio_Mp(:,:,:) = 0.0_PS

         call cal_ratio_mass_col_vec( g_1, g_2, ag, level, icond3, &
                 n_all, Mc, dN_ice, ratio_M_2, dM_col, Mp, ratio_Mp)

         !     2. ratio of each increased volume components to total volume
!!!         do jkn=1,(g_1%N_nonmass+2)*n_all_max*g_1%L
!!!           jn=(jkn-1)/(g_1%N_nonmass+2)+1
!!!           k=jkn-(jn-1)*(g_1%N_nonmass+2)
!!!           n=(jn-1)/n_all_max+1
!!!           j=jn-(n-1)*n_all_max
!!!
!!!           dummy_Vp(k,j,n)=Qp(j,n,k)
!!!         enddo
!         if( g_1%token == 2 .and. pro_type==2) then
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
!             if(icond1(i,n)==1.and.j<=n_all(n)) then
!               write(*,'("ck-2 qp1:",3I5,10ES15.6)') i,j,n,qp(j,n,1)
!             endif
!           enddo
!         endif

         if( g_1%token == 2 ) then
!           ierror(1:n_all_max*g_1%L)=0
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
           do n = 1, g_1%L
           do j = 1, n_all_max
              if(icond3(j,n)==1.and.j<=n_all(n)) then
                 if( ratio_Mp(j,n,imc_m) <= 0.0_PS ) then
                    LOG_ERROR("coalescence",*) "ice crystal mass comp is wrong"
                    LOG_ERROR_CONT(*) "ratio_Mp aft ratio_vol",ratio_Mp(j,n,1:imc_m)
!                    LOG_ERROR_CONT(*) "mass,con,alen",Mp(j,n),Np(j,n),d_axis_len(j,n,1:2)
!                    LOG_ERROR_CONT(*) "mass,con",Mp(j,n),Np(j,n)
                    LOG_ERROR_CONT(*) "mass com", (Mc(j,k,n),k=1,g_1%N_masscom)
                    LOG_ERROR_CONT(*) "dM_col", (dM_col(j,k,n),k=1,g_2%N_BIN)
                    !LOG_ERROR_CONT(*) "ratio_M_2",(Mc(j,k),k=1,g_1%N_masscom)
                    LOG_ERROR_CONT(*) "j,n_all",j,n_all(n)
                    call PRC_abort
!                      write(*,*) "this group ignored"
!                      cycle
                 end if
              end if
           enddo
           enddo
         endif

         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! first try post-growth linear method
         ! +++ calculation of new slope and intercept +++
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           binb3d(j,n,1)=g_1%binb(i)  +dmass_min(j,n)
           binb3d(j,n,2)=g_1%binb(i+1)+dmass_max(j,n)

           Npd(j,n)=Np(j,n)
           Mpd(j,n)=Mp(j,n)
         enddo
         enddo
         call cal_lincubprms_vec(mxnbin+1,n_all_max,g_1%L,Npd,Mpd,binb3d  &
             ,a2d,error_number,"coal_1")

         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! check of postgrowth method
         ! if post-growth linear method produce an error,
         ! post-growth lienar method with linear growth of bin limits is used.
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           if(1<=error_number(j,n).and.error_number(j,n)<=4) then
             dum1 = Mpd(j,n)/Npd(j,n)

!org             if( dum1 >= shifted_bound(2) ) then
!org               shifted_bound(2) = dum1*(1.0+bbmf)
!org             else if( dum1 <= shifted_bound(1) ) then
!org               shifted_bound(1) = max(g_1%binb(1),dum1*(1.0-bbmf))
!org             end if

             i_d_ge_b=int(0.5_PS*(1.0_PS+sign(1.0_PS,dum1-binb3d(j,n,2))))
             binb3d(j,n,2)=real(i_d_ge_b,PS_KIND)*dum1*(1.0+bbmf) + &
                           (1.0-real(i_d_ge_b,PS_KIND))*binb3d(j,n,2)

             i_b_ge_d=int(0.5_PS*(1.0_PS+sign(1.0_PS,binb3d(j,n,1)-dum1)))
             binb3d(j,n,1)=real(i_b_ge_d,PS_KIND)*max(g_1%binb(1),dum1*(1.0-bbmf)) + &
                           (1.0-real(i_b_ge_d,PS_KIND))*binb3d(j,n,1)

             a(1) = a2d(j,n,1)
             a(2) = a2d(j,n,2)
             a(3) = a2d(j,n,3)
             a(4) = a2d(j,n,4)
             call cal_linprms_vec_s(Npd(j,n),Mpd(j,n), &
                      binb3d(j,n,1),binb3d(j,n,2),a(:), &
                      error_number(j,n))
           endif
         enddo
         enddo
!         call cal_lincubprms_vec(mxnbin+1,g_1%L,real(Np,8),real(Mp,8),binb3d  &
!             ,a2d,error_number,"coal_2")

!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           if(1<=error_number(j,n).and.error_number(j,n)<=4) then

             Npd(j,n) = Mpd(j,n)/(0.5_PS*(g_1%binb(i+1)+g_1%binb(i)))
             Np(j,n)=Npd(j,n)

             a(1) = a2d(j,n,1)
             a(2) = a2d(j,n,2)
             a(3) = a2d(j,n,3)
             a(4) = a2d(j,n,4)
             call cal_linprms_vec_s(Npd(j,n),Mpd(j,n), &
                      binb3d(j,n,1),binb3d(j,n,2),a(:), &
                      error_number(j,n))
           endif
         enddo
         enddo
!         call cal_lincubprms_vec(mxnbin+1,g_1%L,real(Np,8),real(Mp,8),binb3d  &
!             ,a2d,error_number,"coal_3")

!         ierror(1:n_all_max*g_1%L)=0
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           if(1<=error_number(j,n).and.error_number(j,n)<=4) then
              if ( debug ) then
                 write(*,*) "Warning: Modified pre-growth linear method also does not work at" &
                      ,j,i,n
                 write(*,*) "       : Ignored con and mass:",Np(j,n),Mp(j,n)
              end if
              icond3(j,n)=0
            endif
         enddo
         enddo

         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! calculate the riming mass tendency of shifted bin
         if(pro_type==4) then
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
            do n = 1, g_1%L
            do j = 1, n_all_max
             if(icond3(j,n)==1.and.j<=n_all(n)) then
               rimed_mass=max(0.0_PS,max(0.0_PS,g_1%MS(i,n)%mass(imr)-&
                                   g_1%MS(i,n)%mass(imat))/g_1%MS(i,n)%con)
               mtend(j,n)=max(0.0_PS,&
                      (Mp(j,n)/Np(j,n)*max(0.0_PS,ratio_Mp(j,n,imr_m)-ratio_Mp(j,n,imat_m)) &
                        -rimed_mass)/g_1%dt)
             endif
           enddo
           enddo
         endif
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

         if( g_1%token == 2 ) then
           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           !  check the ice crsytal mass
!           ierror(1:n_all_max*g_1%L)=0
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
           do n = 1, g_1%L
           do j = 1, n_all_max
             if(icond3(j,n)==1.and.j<=n_all(n).and.ratio_Mp(j,n,imc_m) <= 0.0_PS ) then
                LOG_ERROR("coalescence",*) "ratio_Mp bef xxx",ratio_Mp(j,n,1:imc_m)
!                 LOG_ERROR_CONT(*) "mass,con,alen",Mp(j,n),Np(j,n),d_axis_len(j,n,1:2)
                LOG_ERROR_CONT(*) "mass,con",Mp(j,n),Np(j,n)
                LOG_ERROR_CONT(*) "mass com",(Mc(j,k,n),k=1,g_1%N_masscom)
                LOG_ERROR_CONT(*) "dM_col",(dM_col(j,k,n),k=1,g_2%N_BIN)
                call PRC_abort
              endif
           enddo
           enddo

           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           ! calculate the apparent density for the shifted bin
           call cal_xxx_p_v5_vec(level,g_1%L, icond3, n_all, Mp, Np, &
                   Qp, ratio_Mp, &
                   den_ip_p,asr_p,type_p,&
                   den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
                   pro_name)

         if(debug) then
           if(pro_type==4) then
!             do jn=1,n_all_max*g_1%L
!               n=(jn-1)/n_all_max+1
!               j=jn-(n-1)*n_all_max
!               ierror(jn)=0
              do n = 1, g_1%L
              do j = 1, n_all_max
                 if( icond1(i,n)==1.and.j<=n_all(n) &
                      .and. np(j,n)>1.0e-30.and.Qp(j,n,iccr)/Qp(j,n,iacr)>2.0_PS) then
                   write(*,*) "axis check 5:",j,KD(n),ID(n),JD(n)
                   write(*,*) "habit_p,type_p",j,n,habit_p(j,n),type_p(j,n)
                   write(*,*) "alen,clen,phi",j,n,qp(j,n,iacr),qp(j,n,iccr),&
                        qp(j,n,iccr)/qp(j,n,iacr)
                   write(*,*) "np,mp",j,n,np(j,n),mp(j,n)
                endif
             enddo
             enddo
           endif
         endif

           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           !  check the ice crsytal mass
!           ierror(1:n_all_max*g_1%L)=0
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
            if(icond3(j,n)==1.and.j<=n_all(n).and.ratio_Mp(j,n,imc_m) <= 0.0_PS ) then
               LOG_ERROR("coalescence",*) "ratio_Mp aft xxx",ratio_Mp(j,n,1:imc_m)
!               LOG_ERROR_CONT(*) "mass,con,alen",Mp(j,n),Np(j,n),d_axis_len(j,n,1:2)
               LOG_ERROR_CONT(*) "mass,con",Mp(j,n),Np(j,n)
               LOG_ERROR_CONT(*) "mass com",(Mc(j,k,n),k=1,g_1%N_masscom)
               LOG_ERROR_CONT(*) "dM_col",(dM_col(j,k,n),k=1,g_2%N_BIN)
               call PRC_abort
            endif
         enddo
         enddo

         elseif( g_1%token == 1 .and. g_2%token == 1 ) then

         endif

         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! turn on the error_number flag for neglible concentration and mass
         !  since these do not have the properties diagnosed above.
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
         do n = 1, g_1%L
         do j = 1, n_all_max
           if(icond3(j,n)==0) then
             error_number(j,n)=10
           endif
         enddo
         enddo
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
!           if(icond3(j,n)==1.and.j<=n_all(n)) then
!             write(*,'("ck bf trans",3I5,10ES15.6)') n,i,j,Np(j,n),Mp(j,n),a2d(j,n,1:3)
!           endif
!         enddo
         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! calculation of transferred concentration and mass into original bins
         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         call cal_transbin_vec(g_1%token, &
                           g_1%L,g_1%N_masscom, &
                           g_1%N_bin,n_all_max, &
                           g_1%binb, &
                           error_number, &
                           a2d,binb3d,mtend, &
                           new_N_1,new_M_1,new_Q_1, &
                           new_mtend, &
                           ratio_Mp,den_ip_p,axr_p,spx_p, &
                           habit_p,den_ic_p, &
                           rag_p,rcg_p,n_exice_p, &
                           actINF_p, &
                           0)
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!         do jn=1,g_1%N_bin*g_1%L
!           n=(jn-1)/g_1%N_bin+1
!           j=jn-(n-1)*g_1%N_bin
!           if(new_N_1(j,n)>0.0_PS) then
!             write(*,'("ck new_N,M",3I5,10ES15.6)') n,i,j,new_N_1(j,n),new_M_1(j,n,1)
!           endif
!         enddo

! <<< 2014/10 T. Hashino added for KiD
         if(g_1%token==1.and.g_2%token==1) then

!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
            do n = 1, g_1%L
            do j = 1, n_all_max

             binb3d(j,n,1)=g_1%binb(i)
             binb3d(j,n,2)=g_1%binb(i+1)

             Npd(j,n)=0.0d+0
             Mpd(j,n)=0.0d+0

             if(icond3(j,n)==1.and.j<=n_all(n)) then
               if(Np(j,n)>1.0e-30_PS.and.dMp_auto(j,n)>1.0e-30_PS) then

                 binb3d(j,n,1)=g_1%binb(i)  +dmass_min_auto(j,n)
                 binb3d(j,n,2)=g_1%binb(i+1)+dmass_max_auto(j,n)

                 Npd(j,n)=Np(j,n)
                 Mpd(j,n)=Mp_ini(j,n)+dMp_auto(j,n)
               endif
             endif
           enddo
           enddo

           call cal_lincubprms_vec(mxnbin+1,n_all_max,g_1%L,Npd &
                               ,Mpd,binb3d &
                               ,a2d,error_number,"auto1")

           ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           ! check of postgrowth method
           ! if post-growth linear method produce an error,
           ! post-growth lienar method with linear growth of bin limits is used.
           ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
           do n = 1, g_1%L
           do j = 1, n_all_max
             if(1<=error_number(j,n).and.error_number(j,n)<=4) then

               dum1 = (Mp_ini(j,n)+dMp_auto(j,n))/Npd(j,n)

               i_d_ge_b=0.5_PS*(1.0_PS+sign(1.0_PS,dum1-binb3d(j,n,2)))
               binb3d(j,n,2)=real(i_d_ge_b,PS_KIND)*dum1*(1.0_PS+bbmf) + &
                           (1.0_PS-real(i_d_ge_b,PS_KIND))*binb3d(j,n,2)

               i_b_ge_d=0.5_PS*(1.0_PS+sign(1.0_PS,binb3d(j,n,1)-dum1))
               binb3d(j,n,1)=real(i_b_ge_d,PS_KIND)*max(g_1%binb(1),dum1*(1.0_PS-bbmf)) + &
                           (1.0_PS-real(i_b_ge_d,PS_KIND))*binb3d(j,n,1)

               a(1) = a2d(j,n,1)
               a(2) = a2d(j,n,2)
               a(3) = a2d(j,n,3)
               a(4) = a2d(j,n,4)
               call cal_linprms_vec_s(Npd(j,n),Mpd(j,n), &
                        binb3d(j,n,1),binb3d(j,n,2),a(:), &
                        error_number(j,n))
             endif
           enddo
           enddo
!           ierror(1:n_all_max*g_1%L)=0
!           do jn=1,n_all_max*g_1%L
!             n=(jn-1)/n_all_max+1
!             j=jn-(n-1)*n_all_max
           do n = 1, g_1%L
           do j = 1, n_all_max
              if(1<=error_number(j,n).and.error_number(j,n)<=4) then
                 LOG_ERROR("coalescence",'("coalescence>cal_linear_prms error at auto2",2I5,10ES15.6)') &
                      i,k,Np(j,n),Mp_ini(j,n)+dMp_auto(j,n),binb3d(j,n,1:2),a2d(j,n,1:4)
                 call PRC_abort
              endif
           enddo
           enddo

           call cal_transbin_vec(g_1%token &
                           ,g_1%L,g_1%N_masscom &
                           ,g_1%N_bin,n_all_max &
                           ,g_1%binb &
                           ,error_number &
                           ,a2d,binb3d,mtend &
                           ,new_N_tmp,new_M_tmp,new_Q_tmp &
                           ,new_mtend_tmp &
                           ,ratio_Mp,den_ip_p,axr_p,spx_p &
                           ,habit_p,den_ic_p &
                           ,rag_p,rcg_p,n_exice_p &
                           ,actINF_p &
                           ,0)

           do j=isplit_bin_liq+1,g_1%n_bin
             do n=1,g_1%L
               dM_auto(n)=dM_auto(n)+new_M_tmp(j,n,1)
             enddo
           enddo
           do j=1,n_all_max
             do n=1,g_1%L
               if(icond3(j,n)==1.and.j<=n_all(n)) then
                 if(Np(j,n)>1.0e-30_PS.and.dMp_accr(j,n)>1.0e-30_PS) then
                   dM_accr(n)=dM_accr(n)+dMp_accr(j,n)
                 endif
               endif
             enddo
           enddo
         endif
! >>> 2014/10 T. Hashino added for KiD
!         do n=1,g_1%L
!           if(icond1(19,n)==1) then
!             write(*,'("ck3: icond1==1",2I5,10ES15.6)') i,n,g_1%MS(19,n)%con, &
!                g_1%MS(19,n)%mass(1:2),g_1%MS(19,n)%mean_mass
!           endif
!         enddo

         ! ********************************************************************
         ! calculation of concentration and mass transfer
         ! by collisional breakup
         ! ********************************************************************
         if(pro_type==2.and.ibreak==1) then

           call add_fragments_col_vec(new_N_1,new_M_1, &
                    i,g_1,g_2,icond1,used_marker,E_coal,N_col, &
                    imin_bk,imax_bk,jmin_bk,jmax_bk,bu_tmass,bu_fd)
         endif

       enddo collector_loop1

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! special treatment for each case of collection
       if( g_1%token == g_2%token ) then
         !+++ add the left-over that was non-collectable quantity +++
!         do in=1,g_1%N_BIN*g_1%L
!           n=(in-1)/g_1%N_BIN+1
!           i=in-(n-1)*g_1%N_BIN
          do n = 1, g_1%L
          do i = 1, g_1%N_BIN
             if( used_marker(i,n) == 1 ) then
                new_N_1(i,n) = new_N_1(i,n) + left_N(i,n)
                new_M_1(i,n,1) = new_M_1(i,n,1) + left_M(i,n)
             endif
          enddo
          enddo
          do j=1,g_1%N_masscom
!           do in=1,g_1%N_BIN*g_1%L
!             n=(in-1)/g_1%N_BIN+1
!             i=in-(n-1)*g_1%N_BIN
             do n = 1, g_1%L
             do i = 1, g_1%N_BIN
                if( used_marker(i,n) == 1 ) then
                   new_M_1(i,n,1+j) = new_M_1(i,n,1+j) &
                                    + left_M(i,n)*ratio_M_2(i,j,n)
                endif
             enddo
             enddo
          enddo
       end if
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! check if the density of a solid hydrometeor satisfies
       ! the minimum possible length
       call check_csvolume_vec(g_1,new_N_1,new_M_1,new_Q_1)
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! assign tendency by collision process
       call assign_tendency_vec( g_1, pro_type,&
              new_N_1, new_M_1, new_Q_1, new_mtend, &
              g_2, used_N_2, used_M_2,ratio_M_2)
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

     if(debug) then
       if(pro_type==4.or.(pro_type==2.and.g_1%token==2)) then
!         do in=1,g_1%N_BIN*g_1%L
!           n=(in-1)/g_1%N_BIN+1
!           i=in-(n-1)*g_1%N_BIN
          do n = 1, g_1%L
          do i = 1, g_1%N_BIN
!           ierror(in)=0

!           if(g_1%MS(i,n)%dvoldt(iccr,pro_type)>0.0_RP.and.&
!              g_1%MS(i,n)%dvoldt(iacr,pro_type)<0.0_RP) then
!           if(new_Q_1(i,n,iacr)>1.0e-30_RP.and.&
!              (new_Q_1(i,n,iccr)/max(1.0e-30_RP,new_q_1(i,n,iacr)))**(1.0_RP/3.0_RP)>2.0_RP) then
!             ierror(in)=1
!               write(*,*) "axis check final:",i,KD(n),ID(n),JD(n)
!               write(*,*) "alen,clen,phi",i,n,new_Q_1(i,n,iacr),new_q_1(i,n,iccr) &
!                 ,(new_Q_1(i,n,iccr)/max(1.0e-30_DS,new_q_1(i,n,iacr)))**(1.0_DS/3.0_DS)
!               write(*,*) "n,m",i,n,new_N_1(i,n),new_M_1(i,n,1)
!               write(*,*) "old alen,clen",g_1%MS(i,n)%a_len,g_1%MS(i,n)%c_len
!               write(*,*) "old n,m",g_1%MS(i,n)%con,g_1%MS(i,n)%mass(1)
!               write(*,*) "old habit",g_1%IS(i,n)%sh_type,g_1%IS(i,n)%habit
!               write(*,*) "dcondt:",g_1%MS(i,n)%dcondt(pro_type)
!               write(*,*) "dmassdt:",g_1%MS(i,n)%dmassdt(1,pro_type)
!               write(*,*) "dvoldt_a:",g_1%MS(i,n)%dvoldt(iacr,pro_type)
!               write(*,*) "dvoldt_c:",g_1%MS(i,n)%dvoldt(iccr,pro_type)

             if( debug .and. &
                  new_N_1(i,n)>1.0e-30_DS.and.new_Q_1(i,n,ivcs)>1.0e-30_RP.and.&
                  new_M_1(i,n,1)/max(1.0e-30_DS,new_Q_1(i,n,ivcs))<1.0e-2_RP) then
!           if(new_N_1(i,n)>1.0e-30_RP.and.new_Q_1(i,n,ivcs)>1.0e-30_RP) then

!             ierror(in)=2
               write(*,*) "coal den check final:",i,KD(n),ID(n),JD(n),pro_type,new_M_1(i,n,1)/new_Q_1(i,n,ivcs)
               write(*,*) "alen,clen,phi",i,n,new_Q_1(i,n,iacr),new_q_1(i,n,iccr) &
                 ,(new_Q_1(i,n,iccr)/max(1.0e-30_DS,new_q_1(i,n,iacr)))**(1.0_DS/3.0_DS)
               write(*,*) "n,m",i,n,new_N_1(i,n),new_M_1(i,n,1)
               write(*,*) "old alen,clen",g_1%MS(i,n)%a_len,g_1%MS(i,n)%c_len
               write(*,*) "old n,m",g_1%MS(i,n)%con,g_1%MS(i,n)%mass(1)
               write(*,*) "old den",g_1%MS(i,n)%den,g_1%IS(i,n)%V_cs
               write(*,*) "old habit",g_1%IS(i,n)%sh_type,g_1%IS(i,n)%habit
               write(*,*) "dcondt:",g_1%MS(i,n)%dcondt(pro_type)
               write(*,*) "dmassdt:",g_1%MS(i,n)%dmassdt(1,pro_type)
               write(*,*) "dvoldt_v:",g_1%MS(i,n)%dvoldt(ivcs,pro_type)
               write(*,*) "dvoldt_a:",g_1%MS(i,n)%dvoldt(iacr,pro_type)
               write(*,*) "dvoldt_c:",g_1%MS(i,n)%dvoldt(iccr,pro_type)
            endif
!           if(KD(n)==12.and.JD(n)==16.and.new_Q_1(i,n,ivcs)>1.0e-30_RP) then
!             ierror(i,n)=2
!!           endif
         enddo
         enddo
       endif
     endif

!!c
!!c50 continue
!tmp       call deallocate_coalescence1


    else if( g_1%token == 11 .and. g_2%token == 1 ) then
       do n=1,g_1%L
          ! +++ loop over grids +++
          if( mes_rc(n) == 0 ) cycle

          ! --- case of auto-conversion of monodiperse category ---
          ! The formulation follows Manton and Cotton (1977) and same as
          ! one in lph_micro.6b.newfix7.f
          if( g_1%MS(1,n)%con <= 1.0e-30_PS .OR. &
               g_1%MS(1,n)%mass(1) <= 1.0e-30_PS .OR. &
               g_1%MS(1,n)%mean_mass <= 1.0e-15_PS ) then
!!c             write(*,*) " class_group > the cloud droplets were depleted."
             cycle
          end if

          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! assign tendency by collision process
!!c          g_1%MS(1,n)%dmassdt(1,pro_type) = - auto_conversion(g_1,n)
!!c          g_2%MS(1,n)%dmassdt(1,pro_type) = - g_1%MS(1,n)%dmassdt(1,pro_type)

          g_1%MS(1,n)%dcondt(pro_type) = g_1%MS(1,n)%dmassdt(1,pro_type)/&
               g_1%MS(1,n)%mean_mass
          g_2%MS(1,n)%dcondt(pro_type) = - g_1%MS(1,n)%dcondt(pro_type)
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       end do
    end if


!!$    ! start deallocating pointers
!!$    deallocate(binb3d)
!!$    deallocate(new_N_1,new_M_1)
!!$    deallocate(ratio_M_2)
!!$    deallocate(Mc)
!!$    deallocate(ratio_Mp)
!!$    deallocate(ratio_Vp)
!!$    deallocate(new_Q_1)
!!$    deallocate(Qp)
!!$    deallocate(new_mtend,mtend)
!!$    deallocate(d_axis_len)
!!$    deallocate(KC)
!!$    deallocate(E_coal)
!!$    deallocate(rat_Np)
!!$    deallocate(used_N_2,used_M_2)
!!$    deallocate(used_marker)
!!$    deallocate(used_N_b)
!!$    deallocate(Np,Npd)
!!$    deallocate(Mp,Mpd)
!!$    deallocate(axr_p)
!!$    deallocate(den_ip_p,den_ic_p)
!!$    deallocate(asr_p)
!!$    deallocate(type_p)
!!$    deallocate(habit_p)
!!$    deallocate(rag_p,rcg_p)
!!$    deallocate(n_exice_p)
!!$    deallocate(actINF_p)
!!$    deallocate(error_number)
!!$    deallocate(jbin_h)
!!$    deallocate(jbin_lm)
!!$    deallocate(n_all)
!!$    deallocate(a2d)
!!$    deallocate(ap_dN,ap_dM)
!!$    deallocate(mod_ratio)
!!$    deallocate(sum_ndrop_B)
!!$    deallocate(dmass_max)
!!$    deallocate(dmass_min)
!!$    deallocate(n_h,n_lm,n_f)
!!$    deallocate(counter)
!!$    deallocate(N_col)
!!$    deallocate(col_ratio)
!!$    deallocate(left_N,left_M)
!!$    deallocate(dM_col)
!!$    deallocate(N_drops)
!!$    deallocate(dN_ice)
!!$    deallocate(checker)
!!$    ! end of deallocation of pointers

  end subroutine coalescence

  subroutine Ice_Nucleation1( gs,gr,ga,ag, level, mes_rc,APSNAME,nu_aps,m_aps&!,phi_aps
                 ,ap_sig_cp,ap_mean_cp,CRIC_RN_IMM,frac_dust &!,cdf_cp_180m0
                 ,iflg_cfz,iflg_spl,iflg_ifz,iflg_hfz,ID,JD,KD &
                 ,osm_nhs4,osm_sdch)
    use class_Mass_Bin, only: &
       data1d_lut
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Ice Nucleation routine.
    ! NOTE: this routine should include only modes that do not have any
    !       supersaturation dependency in the formula, so activation scheme
    !       can use the mass conversion tendency.
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! rain group
    type (Group), intent(inout)   :: gr
    type (AirGroup),intent(inout)  :: ag
    ! aerosol group
    type (Group), dimension(*)  :: ga

    ! level of complexity
    integer, intent(in)           :: level
    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc
    ! chemical notation for aerosols
    character (len=16) :: APSNAME(*)
    real(PS),dimension(*) :: nu_aps,m_aps!,phi_aps
    real(PS),dimension(*),intent(in) :: ap_sig_cp,ap_mean_cp!,cdf_cp_180m0
    real(PS), intent(in) :: CRIC_RN_IMM, frac_dust

!!c    real (PS)                     :: mass_v, mass_vis

    ! flag for nucleation processes
    integer, intent(in)           :: iflg_cfz,iflg_spl,iflg_ifz,iflg_hfz

    integer :: ID(*),JD(*),KD(*)
    type(data1d_lut),intent(in) :: osm_nhs4,osm_sdch


!!c    ! the nucleated ice mass
!!c    real(PS) :: PMAS
!!c    ! circumscribing sphere volume a-axis and c-axis volume of ice particle
!!c    ! when it is nucleated.
!!c    real(PS) :: NVCS, NVA, NVC

    ! grid number, bin number
    integer     :: n!,i

    real(PS), parameter              :: Rdvchiarui = 287.04_RP/461.50_RP ! chiarui

    ! gravity acceleration
    real(PS), parameter :: g = gg
    real(PS) :: coef_al1,coef_al2

    !real(PS) :: alpha,min_dt

    coef_al1=g*L_e*Rdvchiarui*M_a/(c_pa*R_u)
    coef_al2=-g*M_a/R_u

!!c    write(*,*) "in 1"
    do n=1,gs%L
       if( mes_rc(n) == 0 ) cycle
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! contact nucleation
       if(iflg_cfz/=0) then
!!c          write(*,*) "con mode",iflg_cfz
          call contact_mode(gs,gr,ga,ag%TV(n),level,n)
       endif
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! secondary nucleation (Hallett-Mossop mechanism)
       if(iflg_spl/=0) then
!!c          write(*,*) "spl mode",iflg_spl
          call secondary_nucleation(gs,gr,ag%TV(n),level,n,&
                                    ID,JD,KD)
       end if
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    end do
!!c    write(*,*) "in 2"
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! immersion freezing mode
    select case(iflg_ifz)
    case(2)
!!!       write(*,*) "imm mode",iflg_ifz
       call immersion_mode(gs,gr,ag,level,mes_rc,APSNAME,nu_aps,m_aps &
                          ,osm_nhs4,osm_sdch)
    case(1)
       call immersion_mode_KC04(gs,gr,ag,level,mes_rc,m_aps &
                               ,ap_sig_cp,ap_mean_cp,CRIC_RN_IMM,frac_dust &
                               )
    case default
    end select
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! homogeneous freezing mode
    if(iflg_hfz/=0) then
!!c       write(*,*) "hfz mode",iflg_ifz
       call homfreez_mode(gs,gr,ag,level,mes_rc,APSNAME,nu_aps,m_aps &
                         ,osm_nhs4,osm_sdch)

    end if
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


  end subroutine Ice_Nucleation1
!!$
  subroutine Ice_Nucleation2( gs,gr,ga,ag, level, mes_rc,APSNAME,nu_aps,m_aps&
                 ,iflg_dep,flagp_a,ID,JD,KD &
                 ,vigp,rdsd,ihabit_gm_random)
    use class_Group, only: &
       vap_igp_aux
    use mod_amps_utility, only: &
       random_genvar

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Ice Nucleation routine.
    ! NOTE: this routine should be called after the vapor mixing ratio
    ! at t+dt is obtained.  The mode included here should have dependency
    ! on the vapor mixing ratio.
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! rain group
    type (Group), intent(inout)   :: gr
    type (AirGroup),intent(inout)  :: ag
    ! aerosol group
    type (Group), dimension(*)  :: ga

    ! level of complexity
    integer, intent(in)           :: level
    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc
    ! chemical notation for aerosols
    character (len=16) :: APSNAME(*)
    real(PS),dimension(*) :: nu_aps,m_aps

    ! Inherent Growth parameterization
    type (vap_igp_aux),intent(in) :: vigp
    type(random_genvar),intent(inout) :: rdsd
    ! random generaion: 1, max frequency: 0
    integer, intent(in)           :: ihabit_gm_random

!!c    real (PS)                     :: mass_v, mass_vis

    ! flag for nucleation processes
    integer, intent(in)           :: iflg_dep
    ! prediction flag
    integer, intent(in)           :: flagp_a

    integer :: ID(*),JD(*),KD(*)

    integer :: n

    return
!!c    write(*,*) "in 1"
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! deposition/sorption nucleation based on Mayer (1992)
!org    if(iflg_dep/=0) then
!org      call deposition_mode_vec(gs,ga,ag,level,mes_rc,flagp_a,ID,JD,KD &
!org                              ,vigp,rdsd,ihabit_gm_random)
!org    endif
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    do n=1,gs%L
!!c       if( mes_rc(n) == 0 ) cycle
!!c       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c       ! deposition/sorption nucleation based on Fletcher's equation.
!!c       if(iflg_dep/=0) then
!!c!org!!c          write(*,*) "dep mode",iflg_dep
!!c          call deposition_mode(gs,gr,ga,ag%TV(n),level,n,mes_rc(n),flagp_a)
!!c       end if
!!c       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    end do

  end subroutine Ice_Nucleation2

  subroutine w_terminal_vel(g,ag,vt)
    use class_Group, only: &
       cal_wterm_vel_v3_vec
    use mod_amps_utility, only: cal_lincubprms_vec
    !integer, intent(in)              :: level
    type (group), intent(in)       :: g
    type (airgroup),intent(in)    :: ag
    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    !integer,dimension(*)   :: mes_rc
    ! weighted terminal velocity
    ! 1st argument
    !    bin number
    ! 2nd argument
    ! 1: mass weighted one
    ! 2: concentration weighted one
    ! 3: volume weighted one
    real(PS), dimension(2,mxnbin,*)  :: vt
    real(DS), dimension(2,g%n_bin,g%L)    :: vt_dum
    !real(ps), dimension(2)    :: vt_num,vt_num2
    ! parameter of linear distribution
    real(8), dimension(g%n_bin,g%L,4)   :: a2d
    real(8), dimension(g%n_bin,g%L)   :: vec1,vec2
    real(PS), dimension(g%n_bin,g%L,2)   :: binb3d

    ! mass bin boundaries
    !real(DS)                        :: left_bd, right_bd

    integer,dimension(g%n_bin,g%L)   :: error_number
    integer   :: i,j,n

    if( g%token == 11 ) then
      ! --- case of cloud droplets ---
      do n=1,g%l
        if( g%ms(1,n)%con < 1.0e-30_ps .or. g%ms(1,n)%mass(1) < 1.0e-30_ps ) then
          vt(1,1,n)=0.0_PS
          vt(2,1,n)=0.0_PS
        else
          vt(1,1,n)=real(g%ms(1,n)%vtm,PS_KIND)
          vt(2,1,n)=real(g%ms(1,n)%vtm,PS_KIND)
        end if
      enddo
    else if( g%token == 1 .or. g%token == 2 ) then
      ! --- case of rain and ice category ---
!      do in=1,g%n_bin*g%l
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%l
       do i = 1, g%N_BIN
        vt(1,i,n)=0.0_PS
        vt(2,i,n)=0.0_PS

        vec1(i,n)=g%MS(i,n)%con
        vec2(i,n)=g%MS(i,n)%mass(1)
        binb3d(i,n,1)=g%binb(i)
        binb3d(i,n,2)=g%binb(i+1)
      enddo
      enddo

      ! 1. calculate the paramters of linear distribution
      call cal_lincubprms_vec(g%n_bin,g%n_bin,g%L,vec1,vec2,binb3d,&
              a2d,error_number,"w_terminal_vel1")


      ! 2. set up the left and right boundaries of mass bins
!      do in=1,g%n_bin*g%l
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%l
      do i = 1, g%N_BIN
        if(a2d(i,n,4)==-9.99d+100) then
          ! linear distribution
          if( a2d(i,n,1) > 0.0d+0 ) then
            ! --- case of non-negative bin ---
            vec1(i,n)=g%binb(i)   ! left_bd
            vec2(i,n)=g%binb(i+1) ! right_bd
          elseif( a2d(i,n,1) == -1.0d+0 ) then
            ! case of n(x'_1) < 0.0
            vec1(i,n) = a2d(i,n,2)
            vec2(i,n)= g%binb(i+1)
          else if( a2d(i,n,1) == -2.0d+0 ) then
            ! case of n(x'_2) < 0.0
            vec1(i,n) = g%binb(i)
            vec2(i,n) = a2d(i,n,2)
          end if

          ! re-write the parameters as n(m)=a0+a1*m
          a2d(i,n,1)=max(0.0d+0,a2d(i,n,1))-a2d(i,n,2)*a2d(i,n,3)
          a2d(i,n,2)=a2d(i,n,3)
          a2d(i,n,3)=0.0d+0
          a2d(i,n,4)=0.0d+0

        elseif(a2d(i,n,4)>-9.98d+100) then
          ! cubic distribution
          vec1(i,n)=g%binb(i)   ! left_bd
          vec2(i,n)=g%binb(i+1) ! right_bd
        endif
      enddo
      enddo

      ! 3. calculate weighted terminal velocity.
      call cal_wterm_vel_v3_vec(g, ag, 1, &
              a2d, vec1, vec2, error_number, vt_dum)

!      do j=1,2
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
      do j=1,2
         vt(j,i,n)=vt_dum(j,i,n)
      enddo
      enddo
      enddo

      if(debug) then
!        do j=1,2
!          do in=1,g%N_BIN*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
         do j=1,2
            if(vt(j,i,n)<0.0.or.vt(j,i,n)>1.5e+3_PS)then
              write(*,11) j,i,n,g%token,vt(j,i,n),g%MS(i,n)%vtm
11            format("terminal velocity can be wrong at weight,bin,grid,token,w_v,v",4i5,2es15.6)
            endif
         end do
         end do
         end do
      endif
!      do j=1,2
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
      do j=1,2
          if(vt(j,i,n)<0.0.or.vt(j,i,n)>1.5e+3)then
            vt(j,i,n)=real(min(max(0.0_ps,g%MS(i,n)%vtm),1.5e+3_ps),PS_KIND)
          end if
      end do
      end do
      end do

    end if


  end subroutine w_terminal_vel

  subroutine cal_aptact_var8_vec(level,ag,ncat_a,ga,gr,gs &
                          ,flagp_a,flagp_r,flagp_s,iflg_inuc,iflg_dep,mes_rc &
                          ,qtp,thil,nu_aps,phi_aps,M_aps,CCNMAX,snrml,ID,JD,KD)
    use scale_prc, only: &
       PRC_abort
    use class_Mass_Bin, only: &
       data1d_lut_big, &
       interp_data1d_lut_big, &
       get_critrad_anal, &
       cal_coef_Ts3
    use class_Thermo_Var, only: &
       get_mod_thermal_cond, &
       get_sat_vapor_pres_lk
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec
    ! -------------------------------------------------------------------------------------
    !
    ! activation of CCN
    ! NOTE:
    !       only category 1 of aerol group is considered.
    ! -------------------------------------------------------------------------------------
    integer, intent(in)              :: level
    type (AirGroup), intent(inout) :: ag

    ! number of categories of aerosols
    integer,intent(in) :: ncat_a

    ! aerosol group
    type (Group), dimension(ncat_a), intent(inout)  :: ga
    ! rain group, ice group
    type (Group), intent(inout) :: gr,gs

    ! flag for predition
    integer,intent(in) :: flagp_r,flagp_s,flagp_a

    ! flag for nucleation processes
    integer,intent(in)   :: iflg_inuc,iflg_dep

    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc

    ! total water mixing ratio
    real(MP_KIND),dimension(*)  :: qtp
    ! theta il
    real(MP_KIND),dimension(*)  :: thil

    real(PS),dimension(ncat_a),intent(in) :: nu_aps,phi_aps,m_aps
    real(PS), intent(in) :: CCNMAX

    integer :: ID(*),JD(*),KD(*)
    type(data1d_lut_big),intent(in) :: snrml

    !
    ! new space
    !
    ! error message
    integer,dimension(LMAX) :: em

    ! shifted-bin boundaries
    real(PS), dimension(mxnbin+1,gr%L,2)           :: binb3d

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,gr%L,4)           :: a2d
    real(8) :: a2d_0d(4)
    !
    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,gr%L,1+mxnmasscomp)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,gr%L,mxnnonmc)          :: new_Q

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,gr%L,mxnmasscomp)      :: ratio_Mp

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
    real(PS), dimension(mxnbin+1,gr%L,mxnnonmc+2)             :: Qp

    ! averaged mass tendency after the time step
    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend

    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,gr%L,mxnaxis-1) :: axr_p
    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
    ! aspect ratio of ice particle
    !real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
    ! type in shifted bin
    !integer, dimension(mxnbin+1,LMAX)          :: type_p

    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p

    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p

    ! concentration and mass to be moved into aerosol groups
    real(8),dimension(LMAX)            :: ap_dN, ap_dM

    ! gravity acceleration
    real(PS), parameter :: g= gg
    ! dry air gas constant
    real(PS), parameter :: R_a=R_u/M_a


    ! surface tension of vapor and water interface
!!c  real(PS), parameter :: sigma_vw=76.0_PS
!!c    real(PS), parameter :: sigma_vw=74.0_PS
!!c  real, parameter :: M_a=28.9, M_w=18.0


    ! limit for prediction
    real(PS),parameter :: nlmt=1.0e-30_PS,mlmt=1.0e-30_PS

    ! super saturation over ice and water at current, next timestep and previous (_b) iteration.
    real(PS),dimension(LMAX) :: sw,sw_n,sw_b,sw_b2,si_n,si_b,sw_m,si_m,sw_o

    real(PS) :: e_satw,e_sati
    real(PS) :: r_e

    real(PS),dimension(LMAX) :: cs1_i_depmode

    real(PS) :: AA,sb,beta!,n_aps,BB(ncat_a)

    !integer :: status

    INTEGER,parameter :: ITMAX=200
    real(PS),PARAMETER :: alim1=1.0e-5,alim2=1.0e-5
    real(PS) :: dif,difT
    real(PS),dimension(LMAX) :: fret
    INTEGER :: iter
    integer,dimension(LMAX) :: iterz,iterzi

    ! number of mass bin derived from the PSD for each category
    integer,parameter :: N_bin_a=10, N_binb_a=N_bin_a+1
    ! normal variate that defines bins
    real(PS),dimension(N_binb_a) :: zn
    integer,dimension(N_bin_a,ncat_a,LMAX) :: noccn
    integer,dimension(LMAX) :: noindep,noccnt
    real(PS),dimension(N_bin_a,ncat_a,LMAX) :: s_c,a_c

    real(PS), dimension(2)           :: binba

    ! process type
    integer,parameter :: pro_type=3

    real(PS) :: coef_a,coef_al1,coef_al2

    real(PS),dimension(N_bin_a,ncat_a,LMAX) ::  M_act,N_act,mean_mass
    real(PS) :: N_acti,mean_mass_ap & !,M_acti
               ,r_n,rd_c,m_clv,e_n
    real(PS),dimension(LMAX) :: sw_allact

! <<< 2014/10 T. Hashino added for KiD
    ! activation limitter based on Stevens 1996
    !   this is on when flagp_a==-3
    real(PS),dimension(LMAX) :: akk_lmt
    real(PS),dimension(LMAX) :: akk
! >>> 2014/10 T. Hashino added for KiD
!    real(PS),parameter :: SRW=0.95
!    real(PS),parameter :: SRW=0.95
!    real(PS),parameter :: SRW=1.0
!    real(PS),parameter :: SRW=0.4
!    real(PS),parameter :: SRW=0.4
    !real(PS) :: getfrac_apact,getznorm

    ! maximum realisitc super saturation, and minimum critical radius for activation.
    real(PS),parameter :: max_sw=0.1,min_ac=1.0e-7,min_sw=0.0001

    ! maximum dry aerosol size allowed to activate (micron)
    real(PS),parameter :: max_r_n=1.0

    ! maximum Cloud droplet number allowed
    !real(PS),parameter :: CCNMAX=215.0_PS

    ! maximum fraction of activation
    real(PS),parameter :: max_fact=1.0_PS
    real(PS) :: fact_c(N_bin_a),fact_m,xi1,xi2,yi1,yi2,fm2!,wx,x1
    !integer :: i1

    real(PS),dimension(LMAX) :: gain_Mi_frn,gain_Mi_rim
    real(PS),dimension(LMAX) :: used_Ma_act,used_Na_act
    real(PS),dimension(LMAX) :: used_Mr_act,used_Mr_vap,used_Mi_act,used_Mi_vap,used_Mi_vapliq &
               ,loss_Mi_mlt,trans_Mi,liq_left,ice_left


    ! to diagnose surface temperature of ice particles
    integer,dimension(mxnbini,LMAX) :: phase2
    real(8),dimension(mxnbini,LMAX) :: TS_A1,TS_B11,TS_B12,TS_B13,TS_D1
    real(PS),dimension(mxnbini,LMAX) :: Tmax
    real(PS) :: mk_a
    real(PS),dimension(mxnbini,LMAX) :: E_L01


    ! smallest and largest bin numbers for fragment distribution
    integer :: ibinr_frg0,ibinr_frg1
    common/IFRGDIS/ibinr_frg0,ibinr_frg1
    real(PS) :: r_frg0,r_frg1
    common/RFRGDIS/r_frg0,r_frg1

    ! mass of maximum stable liquid
    real(PS) :: rm_frg1

    ! air temperature at t+dt
    real(PS) :: T_a_b2,T_a_r
    real(PS),dimension(LMAX) :: T_a_n,T_a_b,T_a_m,T_a_o

    ! bulk variables at the current time
    real(PS),dimension(LMAX) :: qr_0,qi_0,nr_0,ni_0
    real(PS),dimension(LMAX) :: qr,qi,qv,qv_n &
             ,qr_b,qi_b,qr_b2,qi_b2,qr2,qi2
!!!    real(PS) :: qv_b
    real(PS) :: qv_max!,sw_max,qv_w,qv_i
    integer,dimension(LMAX) :: iqvlmt
    integer,dimension(LMAX) :: imethod
    integer,dimension(LMAX) :: mbx,mbx2
    integer,dimension(LMAX) :: icond1 !,ierror1
    integer,dimension(mxnbin+1,LMAX) :: icond3,icond4
    integer,dimension(LMAX) :: iphase
    integer,dimension(mxnbin+1,LMAX)             :: error_number

    ! supersaturation limit where an adjustment scheme works
    real(PS) :: sw_allow=0.02
!!c    real(PS) :: sw_allow=0.00

    ! t il
    real(PS),dimension(LMAX) :: til
    real(PS),parameter :: Racp=287.04_PS/1004.64_PS,p00=1.0e+6 ! chiarui, origin Racp=287.0/1004.0
    real(PS),dimension(LMAX,ncamx) :: sum_ac,sum_am
    real(PS),dimension(LMAX) :: sum_rc,sum_rm

    real(PS), parameter :: Rdvchiarui=287.04_PS/461.50_PS

    integer :: Lbx,Lbx2
    real(PS) :: dum1

    integer,dimension(LMAX) :: icycle_n
!    integer,dimension(LMAX*mxnbin) :: ierror

    integer  :: i,j,k,n,ica,m,mm

    if(mxnbin+1<N_bin_a) then
       LOG_ERROR("cal_aptact_var8_vec",*) "var8: Error. Increase mxnbin",mxnbin,n_bin_a
       call PRC_abort
    endif

    zn=(/-3.090232306,-2.472185845,-1.854139384,-1.236092922,-0.618046461,0.0&
         ,0.618046461,1.236092922,1.854139384,2.472185845,3.090232306/)

    fact_c=(/0.005714484,0.025145127,0.076352402,0.160060344,0.231727644 &
            ,0.231727644,0.160060344,0.076352402,0.025145127,0.005714484/)

!!c    coef_a=2.0_PS*sigma_vw/(den_w*R_v)
    coef_a=2.0_PS/(den_w*R_v)

!!c    coef_al1=g*L_e/(c_pa*R_v)
!!c    coef_al2=-g*M_a/R_u
    coef_al1=g*L_e*Rdvchiarui*M_a/(c_pa*R_u)
    coef_al2=-g*M_a/R_u

    rm_frg1=coef4pi3*r_frg1**3

    do n=1,ag%L

      ! figure out the grid boxes to be skipped for CCN activation
      icycle_n(n)=0

      if( mes_rc(n) == 0 ) then
        icycle_n(n)=1
      elseif(mes_rc(n)==1) then
        if( qtp(n)>1.0e-20_PS.and.&
              ((flagp_r>0.and.ag%TV(n)%s_v(1)>0.0_PS).or.&
               (flagp_s>0.and.iflg_inuc>0.and.iflg_dep>0.and.ag%TV(n)%s_v(2)>0.0_PS.and.&
               ((ag%TV(n)%T<=T_0-5.0.and.ag%TV(n)%s_v(1)>0.0_PS).or.&
               (ag%TV(n)%s_v(2)>=0.05_PS.and.ag%TV(n)%T<T_0)))&
               ) ) then
        else
          icycle_n(n)=1
        endif
      endif
    enddo

    if(all(icycle_n(1:ag%L)==1)) return

    do n=1,ag%L
      ! initialization
      ag%TV(n)%svw0=ag%TV(n)%s_v(1)

      qr_0(n)=0.0_PS
      qi_0(n)=0.0_PS
      nr_0(n)=0.0_PS
      ni_0(n)=0.0_PS


      used_Ma_act(n)=0.0_PS
      used_Na_act(n)=0.0_PS

      used_Mr_vap(n)=0.0_PS
      used_Mr_act(n)=0.0_PS
      used_Mi_vap(n)=0.0_PS
      used_Mi_vapliq(n)=0.0_PS
      used_Mi_act(n)=0.0_PS
      loss_Mi_mlt(n)=0.0_PS

      gain_Mi_frn(n)=0.0_PS
      gain_Mi_rim(n)=0.0_PS

      akk_lmt(n)=1.0_PS

      sw(n)=ag%TV(n)%s_v(1)
      sw_n(n)=sw(n)
      sw_m(n)=sw(n)
      T_a_n(n)=ag%TV(n)%T
!!c      write(*,*) "sw,t",ag%TV(n)%s_v(1),ag%TV(n)%T

      sw_b(n)=sw_n(n)
      T_a_b(n)=T_a_n(n)

      em(n)=0
      iqvlmt(n)=0
      noccnt(n)=1
      noindep(n)=1

      ! imethod
      !   0:
      imethod(n)=0
      iphase(n)=0

      sum_rc(n)=0.0_PS
      sum_rm(n)=0.0_PS
    enddo

    do i=1,gr%n_bin
!CDIR NODEP
      do n=1,gr%L
        if(mes_rc(n)==2.or.mes_rc(n)==4) then
          qr_0(n)=qr_0(n)+max(0.0_PS,gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))

          gain_Mi_frn(n)=gain_Mi_frn(n) &
                ! contact freezing
                +max(0.0_DS,-(gr%MS(i,n)%dmassdt(rmt,8)-gr%MS(i,n)%dmassdt(rmat,8)))&
                ! immersion freezing
                +max(0.0_DS,-(gr%MS(i,n)%dmassdt(rmt,11)-gr%MS(i,n)%dmassdt(rmat,11)))&
                ! homogeneous freezing
                +max(0.0_DS,-(gr%MS(i,n)%dmassdt(rmt,12)-gr%MS(i,n)%dmassdt(rmat,12)))

          nr_0(n)=nr_0(n)+gr%MS(i,n)%con
        endif
      enddo
    enddo

    do i=1,gs%n_bin
!CDIR NODEP
      do n=1,gs%L
        if(mes_rc(n)==3.or.mes_rc(n)==4) then

          E_L01(i,n)=4.0_PS*PI*gs%MS(i,n)%CAP*ag%TV(n)%k_a*gs%MS(i,n)%fh
!!c             gain_Mi_rim=gain_Mi_rim+gs%MS(i,n)%dmassdt(imt,4)
          gain_Mi_rim(n)=gain_Mi_rim(n)+(gs%MS(i,n)%dmassdt(imt,4)-gs%MS(i,n)%dmassdt(imat,4))

          qi_0(n)=qi_0(n)+max(0.0_PS,gs%MS(i,n)%mass(imt)-gs%MS(i,n)%mass(imat))
          ni_0(n)=ni_0(n)+gs%MS(i,n)%con

        end if
        ! coefficients to calculate surface temperature of ice particles
        ! calculate modified thermal conductivity
        if(gs%MS(i,n)%con>=1.0e-30_PS.and.gs%MS(i,n)%mass(1)>=1.0e-30_PS) then
          mk_a = get_mod_thermal_cond(sqrt(gs%MS(i,n)%semi_a**2+gs%MS(i,n)%semi_c**2),&
                                      ag%TV(n)%K_a,ag%TV(n)%T,ag%TV(n)%den)
        else
          mk_a = ag%TV(n)%K_a
        endif
        call cal_coef_Ts3(gs%MS(i,n),ag%TV(n),gs%token &
                         ,TS_A1(i,n),TS_B11(i,n),TS_B12(i,n),TS_B13(i,n),TS_D1(i,n) &
                         ,phase2(i,n),Tmax(i,n),mk_a)
      enddo
    enddo
    do n=1,gs%L
      qr_0(n)=qr_0(n)/ag%TV(n)%den
      qi_0(n)=qi_0(n)/ag%TV(n)%den
      gain_Mi_rim(n)=gain_Mi_rim(n)*gs%dt
      gain_Mi_frn(n)=gain_Mi_frn(n)*gs%dt

!      ierror(n)=0
      if(ga(1)%MS(1,n)%p(1).eq.0.0.or.ga(1)%MS(1,n)%p(2).eq.0.0) then
         LOG_ERROR("cal_aptact_var8_vec",*) "cal_aptact_var8>distribution parameters are 0, check them",&
                   KD(n),ID(n),JD(n),ga(1)%MS(1,n)%p,ga(1)%MS(1,n)%con, ga(1)%MS(1,n)%mass(1)
         call PRC_abort
      endif
    enddo


    ! initialization
    do n=1,ag%L

      qv(n)=ag%TV(n)%rv
!!c      write(*,*) "ck qv in var8:",kd(n),id(n),jd(n),n,qv(n),qr_0(n),qi_0(n)
      qr_b(n)=qr_0(n)
      qr_b2(n)=qr_0(n)
      qi_b(n)=qi_0(n)
      qi_b2(n)=qi_0(n)

      if(ag%TV(n)%T<T_0) then
        call cal_coef_svsteady_init(ga(2),n,cs1_i_depmode(n))
      end if

    enddo


!    do in=1,ag%L*ncat_a
!      ica=(in-1)/ag%L+1
!      n=in-(ica-1)*ag%L
    do ica = 1, ncat_a
    do n = 1, ag%L
      sum_ac(n,ica)=0.0_PS
      sum_am(n,ica)=0.0_PS
    enddo
    enddo

!    do ijn=1,N_bin_a*ncat_a*ag%L
!      jn=(ijn-1)/N_bin_a+1
!      i=ijn-(jn-1)*N_bin_a
!      n=(jn-1)/ncat_a+1
!      ica=jn-(n-1)*ncat_a
    do n = 1, ag%L
    do ica = 1, ncat_a
    do i = 1, N_bin_a

      noccn(i,ica,n)=1
      a_c(i,ica,n)=1.0e+5_PS
      s_c(i,ica,n)=1.0e+5_PS
      N_act(i,ica,n)=0.0_PS
      M_act(i,ica,n)=0.0_PS

      if(icycle_n(n)==0.and.sw(n)>0.0_PS.and.ica/=2) then
        ! size-invariant coef
        AA=coef_a*ag%TV(n)%sig_wa

        ! calculate critical supersaturation for mass bins for each category of aerosols

        ! molecular weight is the one of soluble material of the aerosol.
!org        BB(ica)=nu_aps(ica)*phi_aps(ica)*ga(ica)%MS(1,n)%eps_map*M_W*ga(ica)%MS(1,n)%den/(M_aps(ica)*den_w)

        ! mass bin boundary
        dum1=coef4pi3*ga(ica)%MS(1,n)%den*&
                    exp(ga(ica)%MS(1,n)%p(2))*ga(ica)%MS(1,n)%p(1) &
                       *ga(ica)%MS(1,n)%p(1)*ga(ica)%MS(1,n)%p(1)

        binba(1)=dum1*exp(3.0*zn(i))
        binba(2)=dum1*exp(3.0*zn(i+1))

        ! moles of soluble material
!org        n_aps=ga(ica)%MS(1,n)%mass(ams)/ga(ica)%MS(1,n)%con/M_aps(ica)

        N_act(i,ica,n)=fact_c(i)*ga(ica)%MS(1,n)%con
!!c        fact_m=getznorm2(dble( zn(i+1)-3.0_PS*ga(ica)%MS(1,n)%p(2)))-&
!!c               getznorm2(dble(   zn(i)-3.0_PS*ga(ica)%MS(1,n)%p(2)))

        xi2=zn(i+1)-3.0_PS*ga(ica)%MS(1,n)%p(2)
!        i1=max(1,min(snrml%n-1 &
!            ,int((abs(xi2)-snrml%xs)/snrml%dx)+1))
!        x1=real(i1-1)*snrml%dx+snrml%xs
!        wx=min(1.0,max(0.0_RP,(abs(xi2)-x1)/snrml%dx))
!        yi2=min(1.0,max(0.0_RP, &
!                   (1.0_RP-wx)*snrml%y(i1)+ &
!                        wx*snrml%y(i1+1) ))
        yi2=interp_data1d_lut_big(snrml,abs(xi2))

        xi1=zn(i)-3.0_PS*ga(ica)%MS(1,n)%p(2)
!        i1=max(1,min(snrml%n-1 &
!            ,int((abs(xi1)-snrml%xs)/snrml%dx)+1))
!        x1=real(i1-1)*snrml%dx+snrml%xs
!        wx=min(1.0,max(0.0_RP,(abs(xi1)-x1)/snrml%dx))
!        yi1=min(1.0,max(0.0_RP, &
!                   (1.0_RP-wx)*snrml%y(i1)+ &
!                        wx*snrml%y(i1+1) ))
        yi1=interp_data1d_lut_big(snrml,abs(xi1))

        if(xi1>=0.0_RP) then
          fm2=yi1-yi2
        elseif(xi1<=0.0_RP.and.xi2>0.0_RP) then
          fm2=1.0-yi1-yi2
        else
          fm2=yi2-yi1
        endif

!!c        write(*,*) "ck fact_m",fact_m,fm2,xi1,xi2,yi1,yi2
!       stop

        fact_m=fm2

        M_act(i,ica,n)=min(max_fact,fact_m)*ga(ica)%MS(1,n)%mean_mass*ga(ica)%MS(1,n)%con



        if(N_act(i,ica,n)>=nlmt.and.M_act(i,ica,n)>=mlmt.and.&
           ga(ica)%MS(1,n)%eps_map>=min_eps_ccn) then

          ! dry radius in micron meter
          r_n=1.0e+4_PS*(M_act(i,ica,n)/N_act(i,ica,n)/ga(ica)%MS(1,n)%den/coef4pi3)**(1.0/3.0)

          ! calculate critical radius for given molality and temperature (in micro meter)
!tmp                   rd_c=get_critrad_itr(AA/ag%TV(n)%T*1.0e+4_PS,BB(ica),n_aps*1.0e+12_PS,r_n)

          ! BB defined by Khvorostyanov and Curry (unitless for beta=0.5)
          sb=nu_aps(ica)*ga(ica)%MS(1,n)%eps_map*M_W*ga(ica)%MS(1,n)%den/(M_aps(ica)*den_w)*phi_aps(ica)
          beta=0.5

          rd_c=1.0e+4_PS*get_critrad_anal(AA/ag%TV(n)%T,sb,beta,r_n*1.0e-4_PS)  ! [cm]
          a_c(i,ica,n)=rd_c*1.0e-4_PS

            ! get critical super saturation at the bin boundary
!tmp                   s_c(i,ica)=dexp(real(AA/ag%TV(n)%T*1.0e+4_PS/rd_c-&
!tmp                      BB(ica)*get_osm(1,1.0e+3_PS*n_aps/(coef4pi3*(rd_c**3-r_n**3)))*&
!tmp                      r_n**3/(rd_c**3-r_n**3),8)  )-1.0d+0

          s_c(i,ica,n)=dexp( real(AA/ag%TV(n)%T*1.0e+4_PS/rd_c-&
                          sb*r_n**(2.0*(1.0+beta))/&
                          (rd_c**3-r_n**3),8) ) -1.0d+0

!!c                   write(*,*) "ck a_c",n,ica,i,a_c(i,ica,n),r_n,AA/ag%TV(n)%T,sb,ga(ica)%MS(1,n)%den &
!!c                         ,ga(ica)%MS(1,n)%eps_map,rd_c,s_c(i,ica,n)

          if(s_c(i,ica,n)<=sw(n).and.r_n<=max_r_n.and.s_c(i,ica,n)<=sw_allow) then

            mean_mass(i,ica,n)=coef4pi3*(den_w*(a_c(i,ica,n)**3-r_n**3*1.0e-12_PS)+&
                               ga(ica)%MS(1,n)%den*r_n**3*1.0e-12_PS)

            mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)
            m_clv=binba(2)+&
                    (mean_mass(i,ica,n)-mean_mass_ap)*(binba(2)/mean_mass_ap)**(1.0/3.0)
            if(m_clv>=gr%binb(1).and.mean_mass(i,ica,n)>M_act(i,ica,n)/N_act(i,ica,n) ) then

              noccn(i,ica,n)=0
            endif
          endif
        endif
      endif
    enddo
    enddo
    enddo

    ! calculate the number and mass of aerosols activated.
    do ica=1,ncat_a
      do i=1,N_bin_a
        do n=1,ag%L
          if(noccn(i,ica,n)==0) then
            used_Ma_act(n)=used_Ma_act(n)+max(0.0_PS,N_act(i,ica,n)*mean_mass(i,ica,n)-M_act(i,ica,n))
            used_Na_act(n)=used_Na_act(n)+N_act(i,ica,n)
          endif
        enddo
      enddo
    enddo

    do n=1,ag%L

      e_n=ag%TV(n)%P*(ag%TV(n)%rv_sat(1)+used_Ma_act(n)/ag%TV(n)%den)/&
                     (Rdvchiarui+(ag%TV(n)%rv_sat(1)+used_Ma_act(n)/ag%TV(n)%den))
      sw_allact(n)=e_n/ag%TV(n)%e_sat(1)-1.0_PS

!!c      write(*,*) "used_ma_act",n,e_n,sw_allact(n),ag%TV(n)%rv_sat(1),used_ma_act(n),ag%TV(n)%den
    enddo

    ! set limit on activation based on the exisiting concentration
    if(flagp_a==-3.or.flagp_a==-2.or.flagp_a==-6.or.flagp_a==-5) then
      do n=1,ag%L
!org        akk_lmt(n)=max(0.0_PS,(used_Na_act(n)-nr_0(n))/max(1.0e-30_PS,used_Na_act(n)))
        akk_lmt(n)=max(0.0_PS,(min(CCNMAX,used_Na_act(n))-nr_0(n))&
                       /max(1.0e-30_PS,used_Na_act(n)))
      enddo
    endif
!org    if(flagp_a==-3.or.flagp_a==-1.or.flagp_a==-6.or.flagp_a==-4) then
!org      do n=1,ag%L
!org        ni_0(n)=0.0_PS
!org      enddo
!org    endif

    do n=1,ag%L
      ! +++ calculate T_il from thil +++
      til(n)=thil(n)*(ag%TV(n)%P/p00)**(Racp)

      T_a_r=cal_air_temp(Til(n),qr_0(n),qi_0(n))

!      ierror(n)=0
      if(abs(T_a_r-ag%TV(n)%T)/ag%TV(n)%T>1.0e-5_PS) then
         LOG_ERROR("cal_aptact_var8_vec",'("T is not right",3I5,10ES15.6)') KD(n),ID(n),JD(n),T_a_r,ag%TV(n)%T &
                     ,Til(n), qr_0(n), qi_0(n), ag%TV(n)%P
         call PRC_abort
     endif
    enddo

    !   initialize
    m=0
    do n=1,ag%L
      if(icycle_n(n)==0.and.imethod(n)==0) then
        ! these grids will be considered.
        m=m+1
        mbx(m)=n
        icond1(m)=1
      endif
    enddo
    Lbx=m

    mbx2(1:Lbx)=mbx(1:Lbx)
    Lbx2=Lbx

    ! ----------------------------------------------------------
    ! 1. Backward Euler - Til-Qt conservation method
    ! ----------------------------------------------------------
    ! initialize the effective grid numbers, mbx
    !   this will incldue all the grids
    iter1_loop: do iter=1,ITMAX


      ! ++++++++++++++++++++++++++++
      !  calculate mass formed based on the supersaturation and temperature
      call func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                          ,mbx2,Lbx2,sw_b)!,T_a_b

      call func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                          ,noindep &
                          ,mbx2,Lbx2,sw_b,T_a_b)
      ! ++++++++++++++++++++++++++++

!!!!CDIR NOVECTOR
!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx2
        n=mbx2(m)

        ! ++++ calculate new mixing ratio of hydrometeors at t^(n+1)++++
        trans_Mi(n)=loss_Mi_mlt(n)-min(liq_left(n),gain_Mi_rim(n)+gain_Mi_frn(n))

        qr(n)=max(0.0_PS,qr_0(n)+&
          (used_Mr_act(n)+used_Mr_vap(n)+trans_Mi(n))/ag%TV(n)%den)
        qi(n)=max(0.0_PS,qi_0(n)+&
          (used_Mi_vap(n)+used_Mi_vapliq(n)+used_Mi_act(n)-trans_Mi(n))/ag%TV(n)%den)

        em(n)=0
        if(qr(n)+qi(n)>=qtp(n)) then
          em(n)=1
!!c            write(*,*) "n,qr,qi",n,em(n),qr(n),qi(n),qtp(n)
        endif
        !
        ! ++++ calculate new air temperature (y_n) at t^(n+1) ++++
        T_a_n(n)=cal_air_temp(Til(n),qr(n),qi(n))
        !
        ! ++++ calculate new supersaturation (x_n) at t^(n+1) ++++
        e_satw=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
        qv_n(n)=max(0.0_PS,qtp(n)-qr(n)-qi(n))
        sw_n(n)=ag%TV(n)%P*qv_n(n)/(Rdvchiarui+qv_n(n))/e_satw-1.0_PS

        e_sati=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
        r_e=e_satw/e_sati
        si_n(n)=r_e*(sw_n(n)+1.0_PS)-1.0_PS
        ! +++++++++++++++++++++++++++++++++++++++++++++++++

!!c          dif=abs(2.0*(sw_n-sw_b)/(sw_n+sw_b))
!!c          dif=abs(2.0*(qv_n-qv)/(qv_n+qv))
!!c          difT=abs(2.0*(T_a_n-T_a_b)/(T_a_n+T_a_b))
!!c          dif=abs((sw_n-sw_b)/sw_b)
        dif=abs((qv_n(n)-qv(n))/qv(n))
        difT=abs((T_a_n(n)-T_a_b(n))/T_a_b(n))

        if(&
           (&
           ( (qi(n)>1.0e-20_PS.and.&
             (qi_b(n)<qi(n).and.qi_b2(n)>qi_b(n).and.T_a_b(n)<T_0)).or.&
             (qr(n)>1.0e-20_PS.and.&
             (qr_b(n)<qr(n).and.qr_b2(n)>qr_b(n)))&
             ).and.iter>=10)   .or.&
             (em(n)>=1) &
               )   then
          ! case of using zbrent method.
          imethod(n)=1
          icond1(m)=0

        elseif(dif<=alim1.and.difT<=alim2) then

          ! convergence OK
          sw_n(n)=sw_b(n)
          T_a_m(n)=T_a_n(n)
          T_a_n(n)=T_a_b(n)

          qv_n(n)=qtp(n)-qr(n)-qi(n)

          imethod(n)=-1
          icond1(m)=0

        else
          sw_b2(n)=sw_b(n)
          T_a_b2=T_a_b(n)

          sw_b(n)=sw_n(n)
          si_b(n)=si_n(n)
          T_a_b(n)=T_a_n(n)
          qv(n)=qv_n(n)

          qr_b2(n)=qr_b(n)
          qi_b2(n)=qi_b(n)
          qr_b(n)=qr(n)
          qi_b(n)=qi(n)

        endif

!!c        write(*,*) "ck backeuler",m,mbx2(m),imethod(n),icond1(m)
      enddo
      if(any(icond1(1:Lbx2)>0)) then
        !   initialize for next iteration
!!c        write(*,*) "ck bfmx",mbx2(1:Lbx2)
        mm=0
!CDIR NOVECTOR
        do m=1,Lbx2
          if(icond1(m)==1) then
            mm=mm+1
            mbx2(mm)=mbx2(m)
            icond1(mm)=1
          endif
        enddo
        Lbx2=mm

!!c        write(*,*) 'ck afmx',mbx2(1:Lbx2)
!!c        write(*,*) 'ck Lbx2:',Lbx2
      else
        Lbx2=0
        exit
      endif
    enddo iter1_loop

    if(Lbx2>0) then
       if ( debug ) write(*,*) "cal_aptact_var8_vec, back-Euler failed. zbrent is used.",Lbx2
       do m=1,Lbx2
          n=mbx2(m)
          imethod(n)=1
       enddo
    endif
!!c    do n=1,ag%L
!!c      write(*,*) "imethod,em",n,icycle_n(n),imethod(n),em(n)
!!c    enddo

    ! ----------------------------------------------------------
    ! 2. Zbrent method
    ! ----------------------------------------------------------
    !   initialize
    m=0
    do n=1,ag%L
      if(icycle_n(n)==0.and.imethod(n)==1) then
        m=m+1
        mbx(m)=n
      endif
    enddo
    Lbx=m

!CDIR NODEP
!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)

      ! case of both liquid and ice exist.
      !  The minimum possible vapor is the ice saturation if liquid also exhosted.
      T_a_n(n)=ag%TV(n)%T
      T_a_b(n)=ag%TV(n)%T
      T_a_o(n)=ag%TV(n)%T
      sw_n(n)=ag%TV(n)%s_v(1)
      sw_b(n)=ag%TV(n)%s_v(1)
      sw_o(n)=ag%TV(n)%s_v(1)
      qv(n)=ag%TV(n)%rv
!!!        qv_b(n)=ag%TV(n)%rv

      iqvlmt(n)=1


      ! calculate max supersaturation over water in mixed phase
!org        sw_max=(ag%TV(n)%P*(qtp(n)-qi_0)/(0.622+(qtp(n)-qi_0)))/ag%TV(n)%e_sat(1)-1.0
      if(mes_rc(n)==3.and.abs(used_mi_vapliq(n))<1.0e-25_PS.and.T_a_n(n)<T_0) then
        ! This case is ice saturation.
        iphase(n)=2
      else
        iphase(n)=1
      endif
    enddo

    call zbrent_act_vec(sw_n,iphase,1,mbx,Lbx,sw_o,T_a_o,sw_b,T_a_b)

    do m=1,Lbx
      n=mbx(m)
      qr_b(n)=qr2(n)
      qi_b(n)=qi2(n)
    enddo

    !+++++++++++++++++++++++++++++++++++++++++
    ! oscillation check (only for zbrent grids)
    call func_vec(sw_m,T_a_m,si_m,fret,0,mbx,Lbx,sw_n,T_a_b)

!    do n=1,ag%L
!      ierror1(n)=0
!    enddo

    mm=0
!CDIR NODEP
!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)
      if(abs(fret(n))>0.1) then
        sw_n(n)=ag%TV(n)%s_v(1)
        T_a_b(n)=ag%TV(n)%T
        qr_b(n)=qr_0(n)
        qi_b(n)=qi_0(n)

        if(iphase(n)==1) then
          ! error message set to 1, which is used in the repair
          gr%mark_er(n)=1
          if(debug) then
            write(*,*) "qv limit oscillation 1",&
                     KD(n),ID(n),JD(n),n,em(n),iterzi(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                     sw_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qr2(n)
            write(*,*) "used_Mr_act,mr_vap,mi_vap,mi_vapliq,mi_act,lmlt,grm,grf,tmi,lqlft",&
                     used_Mr_act(n),used_Mr_vap(n),&
                     used_Mi_vap(n),used_Mi_vapliq(n),&
                     used_Mi_act(n),loss_Mi_mlt(n),gain_Mi_rim(n),gain_Mi_frn(n),trans_Mi(n),liq_left(n)
            write(*,*) "noccnt,used_Ma_act,used_Na_act,sw_allact", &
                     noccnt(n),used_Ma_act(n),used_Na_act(n),sw_allact(n)
            write(*,*) "akk_lmt",akk_lmt(n)

           end if
        else
           if(debug) then
            write(*,*) "qv limit oscillation 2",&
                   KD(n),ID(n),JD(n),n,iterzi(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                   sw_m(n),ag%TV(n)%s_v(2),si_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qi2(n)

           end if
        endif

        mm=mm+1
        mbx2(mm)=n
      endif
    enddo
    Lbx2=mm

    call func_vec(sw_m,T_a_m,si_m,fret,0,mbx2,Lbx2,sw_n,T_a_b)

    if(debug) then
      if(any(sw_m(1:ag%L)>0.10).or.&
         any(sw_b(1:ag%L)>0.10)) then
        do m=1,Lbx
          n=mbx(m)
          if(sw_m(n)>0.10.or.&
             sw_b(n)>0.10) then
              write(*,*) "qv limit done 1_2: k,i,j,em,iter,qv,qr,qi,swo,swb,swn,swm,to,tn,tm,fret,qr2",&
                   KD(n),ID(n),JD(n),em(n),iterzi(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                   sw_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qr2(n)
!!c                      write(*,'("con",3I5,40ES15.6)') KD(n),ID(n),JD(n),(gr%MS(i,n)%con,i=1,gr%N_BIN)
!!c                      write(*,'("coef1",3I5,40ES15.6)') KD(n),ID(n),JD(n),(gr%MS(i,n)%coef(1),i=1,gr%N_BIN)
!!c                      write(*,'("coef2",3I5,40ES15.6)') KD(n),ID(n),JD(n),(gr%MS(i,n)%coef(2),i=1,gr%N_BIN)
!!c                      write(*,'("dm",3I5,40ES15.6)') KD(n),ID(n),JD(n),((gr%MS(i,n)%coef(1)*sw_n+gr%MS(i,n)%coef(2))*gr%dt,i=1,gr%N_BIN)
          endif
        enddo
      endif

      if(any(si_m(1:ag%L)>0.30)) then
        do m=1,Lbx
          n=mbx(m)
          if(si_m(n)>0.30) then
            write(*,*) "qv limit done 2_2: k,i,j,iter,qv,qr,qi,swo,swb,swn,swm,sio,sim,to,tn,tm,fret,qi2",&
                     KD(n),ID(n),JD(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                     sw_m(n),ag%TV(n)%s_v(2),si_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qi2(n)

          endif
        enddo
      endif
    endif ! debug
    !+++++++++++++++++++++++++++++++++++++++++

    ! check if we need to run zbrent again for water saturation.
    m=0
    do n=1,ag%L
      if(icycle_n(n)==0.and.&
         qr_0(n)>1.0e-10_PS.and.(&
        (iqvlmt(n)==0.and.sw_n(n)>sw_allow).or.(iqvlmt(n)==1.and.sw_m(n)>sw_allow))) then
        ! This is unrealistic high supersaturation
        ! run the water saturation adjustment
        m=m+1
        mbx(m)=n
      endif
    enddo
    Lbx=m

!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)
      iphase(n)=1
      T_a_n(n)=ag%TV(n)%T
      T_a_b(n)=ag%TV(n)%T
      T_a_o(n)=ag%TV(n)%T
      sw_n(n)=sw(n)
      sw_b(n)=sw(n)
      qv(n)=ag%TV(n)%rv
!!!        qv_b(n)=ag%TV(n)%rv

      iqvlmt(n)=2
    enddo
    call zbrent_act_vec(sw_n,iphase,2,mbx,Lbx,sw,T_a_o,sw_b,T_a_b)

    call func_vec(sw_m,T_a_m,si_m,fret,0,mbx,Lbx,sw_n,T_a_b)

    if(debug) then
      do m=1,Lbx
        n=mbx(m)
        write(*,*) "qv limit done 1_3: k,i,j,em,iter,qv,qr,qi,swo,swb,swn,swm,to,tn,tm,fret,qr2",&
                   KD(n),ID(n),JD(n),em(n),iterzi(n),qv_n(n),qr(n),qi(n),sw(n),sw_b(n),sw_n(n),&
                   sw_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qr2(n)
      enddo
    endif

    if (debug) then
    do n=1,ag%L
!      ierror1(n)=0
      if((iqvlmt(n)==0.and.sw_n(n)>0.10).or.(iqvlmt(n)==1.and.sw_m(n)>0.10)) then
          write(*,*) "large supersaturation:k,i,j",KD(n),ID(n),JD(n)
          write(*,110) iterzi(n),sw(n), sw_n(n), ag%TV(n)%W, ag%TV(n)%T,T_a_n(n)
110       format("iter,sw,sw_n,W,T,T_a_n",I5,5ES15.6)
          do ica=1,ncat_a
            write(*,*) "k,i,j,ica,noccn", KD(n),ID(n),JD(n),ica,(noccn(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,sc", KD(n),ID(n),JD(n),ica,(s_c(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,m_act", KD(n),ID(n),JD(n),ica,(m_act(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,n_act", KD(n),ID(n),JD(n),ica,(n_act(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,init m, n", KD(n),ID(n),JD(n),ica &
                                ,ga(ica)%MS(1,n)%mass(amt),ga(ica)%MS(1,n)%con
          enddo
          write(*,*) "iqvlmt,em,sw_b,sw_n,si_b,si_n", &
                      iqvlmt(n),em(n),sw_b(n),sw_n(n),si_b(n),si_n(n)
          write(*,*) "used_Mr_act,mr_vap,mi_vap,mi_vapliq,mi_act,lmlt,grm,grf,tmi,lqlft", &
            used_Mr_act(n),used_Mr_vap(n),&
            used_Mi_vap(n),used_Mi_vapliq(n),&
            used_Mi_act(n),loss_Mi_mlt(n),gain_Mi_rim(n),gain_Mi_frn(n),trans_Mi(n),liq_left(n)
          write(*,*) "noccnt,used_Ma_act,used_Na_act,sw_allact", noccnt(n),used_Ma_act(n),used_Na_act(n),sw_allact(n)
          write(*,*) "akk_lmt", akk_lmt(n)

          write(*,*) "k,i,j,qtp,qv0,qv2,qv3,qr0,qr,qi0,qi", KD(n),ID(n),JD(n),&
               qtp(n),ag%TV(n)%rv,qtp(n)-qr_0(n)-qi_0(n),qtp(n)-qr(n)-qi(n),qr_0(n),qr(n),qi_0(n),qi(n)
      endif
    enddo
    end if

    if(sum(noccnt(1:ag%L))==ag%L) goto 5555

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! grow the activated droplets to deplete excess water
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization
!    do in=1,mxnbin*ag%L
!      n=(in-1)/mxnbin+1
!      i=in-(n-1)*mxnbin
    do n = 1, ag%L
    do i = 1, mxnbin
      new_N(i,n)=0.0_PS
      new_mtend(i,n)=0.0_PS
    enddo
    enddo
!    do in=1,(mxnbin+1)*ag%L
!      n=(in-1)/(mxnbin+1)+1
!      i=in-(n-1)*(mxnbin+1)
    do n = 1, ag%L
    do i = 1, (mxnbin+1)
      Np(i,n)=0.0_PS
      Mp(i,n)=0.0_PS
      Npd(i,n)=0.0d+0
      Mpd(i,n)=0.0d+0
      mtend(i,n)=0.0e+0

      icond3(i,n)=0
      icond4(i,n)=0
      error_number(i,n)=0
    enddo
    enddo
!    do ijn=1,mxnbin*(1+mxnmasscomp)*ag%L
!      jn=(ijn-1)/mxnbin+1
!      i=ijn-(jn-1)*mxnbin
!      n=(jn-1)/(1+mxnmasscomp)+1
!      j=jn-(n-1)*(1+mxnmasscomp)
    do j = 1, 1+mxnmasscomp
    do n = 1, gr%L
    do i = 1, mxnbin
      new_M(i,n,j) = 0.0_PS
    enddo
    enddo
    enddo
!    do ijn=1,mxnmasscomp*(mxnbin+1)*ag%L
!      in=(ijn-1)/mxnmasscomp+1
!      j=ijn-(in-1)*mxnmasscomp
!      n=(in-1)/(mxnbin+1)+1
!      i=in-(n-1)*(mxnbin+1)
    do j = 1, mxnmasscomp
    do n = 1, ag%L
    do i = 1, mxnbin+1
      ratio_Mp(i,n,j) = 0.0_PS
    enddo
    enddo
    enddo


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    category_loop1: do ica=1,ncat_a

      do n=1,ag%L
        ! initialize con and mass of aerosol transports
        ap_dN(n) = 0.0d+0
        ap_dM(n) = 0.0d+0
      enddo

!      do in=1,N_bin_a*ag%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, ag%L
      do i = 1, N_bin_a

!!!        write(*,*) "ica,i,n",ica,i,n,ga(ica)%MS(1,n)den,&
!!!                       ga(ica)%MS(1,n)%p(1:2)
        icond4(i,n)=0

        if(noccn(i,ica,n)==0) then
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! grow the activated droplets using Twomey lower bound estimates
             !                          th_var,phase,alpha,Sd_max,dt,min_dt,r0,m0
!             shifted_bound(1)=get_vapdepact_v2(ag%TV(n),1&
!                  ,sw_n,ga(ica)%dt,r1,shifted_bound(1))
!             shifted_bound(2)=get_vapdepact_v2(ag%TV(n),1&
!                  ,sw_n,ga(ica)%dt,r2,shifted_bound(2))

!             mean_mass_ap=coef4pi3*a_c(i,ica)**3
!             mean_mass=get_vapdepact_v2(ag%TV(n),1,sw_n,ga(ica)%dt,a_c(i,ica),mean_mass_ap)


!             mean_mass_ap=M_act(i,ica)/N_act(i,ica)
!             mean_mass=coef4pi3*den_w*a_h(i,ica)**3

!             mean_mass_ap=coef4pi3*den_w*a_h(i,ica)**3
!             mean_mass=get_vapdepact_v2(ag%TV(n),1,sw_n,ga(ica)%dt,a_h(i,ica),mean_mass_ap)

!             mean_mass=coef4pi3*den_w*a_c(i,ica)**3

!             mean_mass=get_vapdepact_v2(ag%TV(n),1,sw_n,ga(ica)%dt,a_h(i,ica),mean_mass_ap)

          mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)

          dum1=coef4pi3*ga(ica)%MS(1,n)%den*&
                    exp(ga(ica)%MS(1,n)%p(2))*ga(ica)%MS(1,n)%p(1) &
                       *ga(ica)%MS(1,n)%p(1)*ga(ica)%MS(1,n)%p(1)

          binb3d(i,n,1)=dum1*exp(3.0*zn(i))
          binb3d(i,n,2)=dum1*exp(3.0*zn(i+1))

          binb3d(i,n,1)=binb3d(i,n,1)+&
                (mean_mass(i,ica,n)-mean_mass_ap)*(binb3d(i,n,1)/mean_mass_ap)**(1.0_PS/3.0_PS)
          binb3d(i,n,2)=binb3d(i,n,2)+&
                (mean_mass(i,ica,n)-mean_mass_ap)*(binb3d(i,n,2)/mean_mass_ap)**(1.0_PS/3.0_PS)

!kid             if((iqvlmt==0.and.sw_n>0.10).or.(iqvlmt==1.and.sw_m>0.10)) then
!             if((iqvlmt==0.and.sw_n>0.50).or.(iqvlmt==1.and.sw_m>0.50)) then
!                write(*,*) "k,i,j,ac,p1,p2", KD(n),ID(n),JD(n) &
!                     ,a_c(:,ica),ga(ica)%MS(1,n)%p(1),ga(ica)%MS(1,n)%p(2)
!             endif

          if(sw_allact(n)>1.0e-25_PS) then
! <<< 2014/10 T. Hashino modified for KiD, following Stevens 1996
!tmp                akk=min(1.0_PS,max(0.0_PS,sw_n/sw_allact))
            akk(n)=min(1.0_PS,akk_lmt(n),max(0.0_PS,sw_n(n)/sw_allact(n)))
! >>> 2014/10 T. Hashino modified for KiD, following Stevens 1996
          else
            akk(n)=1.0_PS
          endif
          Mp(i,n)=N_act(i,ica,n)*akk(n)*mean_mass(i,ica,n)
          Np(i,n)=N_act(i,ica,n)*akk(n)

          icond3(i,n)=1
          if(Np(i,n)<=1.0e-25_PS.or.Mp(i,n)<=1.0e-25_PS) then
            icond3(i,n)=0
            Np(i,n)=0.0_PS
            Mp(i,n)=0.0_PS

            ratio_Mp(i,n,rmat_m)=0.0_PS
            ratio_Mp(i,n,rmas_m)=0.0_PS
            ratio_Mp(i,n,rmai_m)=0.0_PS

          elseif(binb3d(i,n,1)>=mean_mass(i,ica,n).or.mean_mass(i,ica,n)>=binb3d(i,n,2)) then
            icond3(i,n)=0
            icond4(i,n)=1
!!c            write(*,*) "ck addsim0:",i,n,ica,Np(i,n),Mp(i,n),mean_mass(i,ica,n),&
!!c                 binb3d(i,n,1:2)
            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! set up mass ratio
            ratio_Mp(i,n,rmat_m)=M_act(i,ica,n)*akk(n)/Mp(i,n)
            ratio_Mp(i,n,rmas_m)=ga(ica)%MS(1,n)%eps_map*ratio_Mp(i,n,rmat_m)
            ratio_Mp(i,n,rmai_m)=max(0.0_PS,ratio_Mp(i,n,rmat_m)-ratio_Mp(i,n,rmas_m))

          else

            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! set up mass ratio
            ratio_Mp(i,n,rmat_m)=M_act(i,ica,n)*akk(n)/Mp(i,n)
            ratio_Mp(i,n,rmas_m)=ga(ica)%MS(1,n)%eps_map*ratio_Mp(i,n,rmat_m)
            ratio_Mp(i,n,rmai_m)=max(0.0_PS,ratio_Mp(i,n,rmat_m)-ratio_Mp(i,n,rmas_m))

          endif

          Npd(i,n)=Np(i,n)
          Mpd(i,n)=Mp(i,n)
        else
          ! those ignored for transfer_bin
          icond3(i,n)=0
          binb3d(i,n,1)=0.0_PS
          binb3d(i,n,2)=0.0_PS
          Np(i,n)=0.0_PS
          Mp(i,n)=0.0_PS
          Npd(i,n)=0.0d+0
          Mpd(i,n)=0.0d+0
          ratio_Mp(i,n,rmat_m)=0.0_PS
          ratio_Mp(i,n,rmas_m)=0.0_PS
          ratio_Mp(i,n,rmai_m)=0.0_PS
        endif
      enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      !  case where the mean mass is not constrained.
      call add_simple_vec(N_bin_a,gr%L,icond4,gr,Np,Mp,ratio_Mp,new_N,new_M, &
                          new_Q,Qp)
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of parameters for linear distribution in the shifted bin
      call cal_lincubprms_vec(mxnbin+1,N_bin_a,gr%L,Npd,Mpd,binb3d  &
                         ,a2d,error_number,"cal_apact_1")

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! turn on the error_number flag for neglible concentration and mass
      !  since these do not have the properties diagnosed above.
!      do in=1,N_bin_a*gr%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, gr%L
      do i = 1, N_bin_a
        if(icond3(i,n)==0) then
          error_number(i,n)=10
        endif
      enddo
      enddo

!      if(any(error_number(1:N_bin_a,1:gr%L)>=1.and.error_number(1:N_bin_a,1:gr%L)<=4)) then
        do j=1,gr%N_BIN
!          do in=1,N_bin_a*gr%L
!            n=(in-1)/N_bin_a+1
!            i=in-(n-1)*N_bin_a
           do n = 1, gr%L
           do i = 1, N_bin_a
            if(1<=error_number(i,n).and.error_number(i,n)<=4) then
              if(gr%binb(j)<mean_mass(i,ica,n).and.gr%binb(j+1)>mean_mass(i,ica,n)) then
                binb3d(i,n,1)=gr%binb(j)
                binb3d(i,n,2)=gr%binb(j+1)

                a2d_0d(1) = a2d(i,n,1)
                a2d_0d(2) = a2d(i,n,2)
                a2d_0d(3) = a2d(i,n,3)
                a2d_0d(4) = a2d(i,n,4)
                call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                       binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                       error_number(i,n))
              end if
            end if
          end do
          end do
        end do
!      endif

!      ierror(1:N_bin_a*gr%L)=0
!      do in=1,N_bin_a*gr%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, gr%L
      do i = 1, N_bin_a
        if(1<=error_number(i,n).and.error_number(i,n)<=4) then
           if ( debug ) then
              write(*,*) "cal_ap_act_var8: Warning: Modified pre-growth linear method also does not work at" &
                   ,i,n
              write(*,*) "       : Ignored con and mass:",Np(i,n),Mp(i,n)
           end if
            error_number(i,n)=10
        endif
      enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of transferred concentration and mass into original bins
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call cal_transbin_vec(gr%token &
                           ,gr%L,gr%N_masscom &
                           ,gr%N_bin,N_bin_a &
                           ,real(gr%binb,PS_KIND) &
                           ,error_number &
                           ,a2d,binb3d,mtend &
                           ,new_N,new_M,new_Q &
                           ,new_mtend &
                           ,ratio_Mp,den_ip_p,axr_p,spx_p &
                           ,habit_p,den_ic_p &
                           ,rag_p,rcg_p,n_exice_p &
                           ,actINF_p &
                           ,0)
      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      do i=1,N_bin_a
        do n=1,gr%L
          if(noccn(i,ica,n)==0) then
!!c            write(*,'("ck np",5I5,10ES15.6)') ica,i,kd(n),noccn(i,ica,n),icond3(i,n) &
!!c                          ,Np(i,n),N_act(i,ica,n),akk(n),mean_mass(i,ica,n)
            sum_ac(n,ica)=sum_ac(n,ica)+Np(i,n)
            sum_am(n,ica)=sum_am(n,ica)+M_act(i,ica,n)*akk(n)
          endif
        enddo
      enddo
      do n=1,gr%L
        sum_ac(n,ica)=sum_ac(n,ica)-ap_dN(n)
        sum_am(n,ica)=sum_am(n,ica)-ap_dM(n)
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate used aerosol tendencies
      do n=1,gr%L
        ga(ica)%MS(1,n)%dcondt(pro_type)=-sum_ac(n,ica)/gr%dt
      enddo
!      do in=1,(1+ga(ica)%N_masscom)*gr%L
!        n=(in-1)/(1+ga(ica)%N_masscom)+1
!        j=in-(n-1)*(1+ga(ica)%N_masscom)
      do n = 1, gr%L
      do j = 1, 1+ga(ica)%N_masscom
        ga(ica)%MS(1,n)%dmassdt(j,pro_type)=-sum_am(n,ica)*&
                     ga(ica)%MS(1,n)%mass(j)/ga(ica)%MS(1,n)%mass(1)/gr%dt
      end do
      end do
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    enddo category_loop1

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the tendency of liquid activated.
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      gr%MS(i,n)%dcondt(pro_type)=new_N(i,n)/gr%dt

      gr%MS(i,n)%dmassdt(rmt,pro_type)=new_M(i,n,rmt)/gr%dt

!!c      write(*,*) "ck new_n",i,n,new_n(i,n)

!      ierror(in)=0
      if( new_N(i,n) < -1.0e+10 .or. new_N(i,n) > 1.0e+10) then
         LOG_ERROR("cal_aptact_var8_vec",*) "Tendency unrealistic", (new_N(j,n),j=1,gr%N_BIN)
         LOG_ERROR_CONT(*) "sw,sw_n,ncat_a",sw(n),sw_n(n), ncat_a
         LOG_ERROR_CONT(*) "a_c",a_c(1:N_bin_a,1:ncat_a,n)
         !LOG_ERROR_CONT(*) "p(1)",ga(1:ncat_a)%MS(1,n)%p(1)
         !LOG_ERROR_CONT(*) "p(2)",ga(1:ncat_a)%MS(1,n)%p(2)
         LOG_ERROR_CONT(*) "Nact",N_act(1:N_bin_a,1:ncat_a,n)
         LOG_ERROR_CONT(*) "Mact",M_act(1:N_bin_a,1:ncat_a,n)
         ! Ong Chia Rui, delete due to unknown compile error, recovered
         !LOG_ERROR_CONT(*) "con,mass",ga(1:ncat_a)%MS(1,n)%con,ga(1:ncat_a)%MS(1,n)%mass(1)
         LOG_ERROR_CONT(*) KD(n),ID(n),JD(n),i,(new_M(i,n,k),k=1,1+gr%N_masscom)
         call PRC_abort
      endif
      if( new_M(i,n,rmt) < -1.0e+10_PS .or. new_M(i,n,rmt) > 1.0e+10_PS) then
          call PRC_abort
      endif
    enddo
    enddo

!    do j=2,(1+gr%N_masscom)
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
       do j=2,(1+gr%N_masscom)
        gr%MS(i,n)%dmassdt(j,pro_type)=new_M(i,n,j)/gr%dt

!        ierror(in)=0
        if( new_M(i,n,j) < -1.0e+10_PS .or. new_M(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("cal_aptact_var8_vec",*) "Tendency unrealistic",KD(n),ID(n),JD(n)
           call PRC_abort
        endif
        gr%MS(i,n)%dmassdt(j,pro_type)=&
                 min(abs(gr%MS(i,n)%dmassdt(rmt,pro_type))&
                ,max(-abs(gr%MS(i,n)%dmassdt(rmt,pro_type)),gr%MS(i,n)%dmassdt(j,pro_type)))
      enddo
      enddo
    enddo

    do n=1,gr%L
      do i=1,gr%N_bin
        sum_rc(n)=sum_rc(n)+new_N(i,n)
        sum_rm(n)=sum_rm(n)+new_M(i,n,rmt)-new_M(i,n,rmat)
      enddo
    enddo


5555 continue


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! finalize it by updatting thermo variables
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    do n=1,gr%L
      if(icycle_n(n)==0) then
        ag%TV(n)%e_sat_n(1)=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
        ag%TV(n)%e_sat_n(2)=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
        r_e= ag%TV(n)%e_sat_n(1)/ag%TV(n)%e_sat_n(2)
        ag%TV(n)%T_n=T_a_n(n)
        ag%TV(n)%T_m=T_a_m(n)

        ! +++ update the steady state saturation +++
        ag%TV(n)%s_v_n(1)=sw_n(n)
        ag%TV(n)%s_v_n(2)=r_e*(sw_n(n)+1.0_PS)-1.0_PS

!        ierror(n)=0
        if((iqvlmt(n)==0.and.sw_n(n)>0.10).or.(iqvlmt(n)==1.and.sw_m(n)>0.10).or.&
          debug) then
          ag%TV(n)%e_sat_n(1)=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
          ag%TV(n)%e_sat_n(2)=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
          r_e= ag%TV(n)%e_sat_n(1)/ag%TV(n)%e_sat_n(2)
          if (debug) write(*,*) "var8,final>sw_n,si_n,T_a_n", KD(n),ID(n),JD(n) &
               ,sw_n(n),r_e*(sw_n(n)+1.0_PS)-1.0_PS,T_a_n(n),sum_rc(n),sum_ac(n,1:ncat_a) &
               ,sum_rm(n),sum_am(n,1:ncat_a)
        endif
      endif
    enddo

!!!    stop

    return
  contains

    subroutine cal_coef_svsteady_init(g,n,a)
      ! +++++++++++++++++++++++++++++++++++++++++++++++++
      ! this coefficient is given per perticle
      type (Group)        :: g
      integer :: n!,i
      real(PS) :: a

      a=g%MS(1,n)%coef(1)*g%dt
    end subroutine cal_coef_svsteady_init

!tmp    subroutine allocate_aptact
!tmp      integer :: item(15)
!tmp      item=0
!tmp      allocate( new_M(1+gr%N_masscom,gr%N_BIN), stat = item(1))
!tmp      allocate( new_Q(gr%N_nonmass,gr%N_BIN), stat = item(2))
!tmp      allocate( new_N(gr%N_BIN), stat = item(3))
!tmp      allocate( ratio_Mp(gr%N_masscom), stat = item(4))
!tmp      allocate( par(3), stat = item(5))
!tmp      allocate( Qp(gr%N_nonmass), stat = item(6))
!tmp      allocate( ratio_Vp(gr%N_vol), stat = item(7))
!tmp      allocate( d_axis_len(2), stat = item(8))
!tmp      allocate( new_mtend(gr%N_BIN), stat = item(9))
!tmp      allocate( shifted_bound(2), stat = item(10))
!tmp      allocate( axr_p(gr%N_axis-1), stat = item(11))
!tmp      allocate( TS_A1(gs%N_BIN), stat = item(12))
!tmp      allocate( TS_B11(gs%N_BIN), stat = item(13))
!tmp      allocate( TS_B12(gs%N_BIN), stat = item(14))
!tmp      allocate( phase2(gs%N_BIN), stat = item(15))
!tmp      if(any(item/=0) ) Stop 'Allocatation failed at aptact'
!tmp    end subroutine allocate_aptact
!tmp    subroutine deallocate_aptact
!tmp      integer :: item(15)
!tmp      item=0
!tmp      deallocate( phase2, stat = item(15))
!tmp      nullify(phase2)
!tmp      deallocate( TS_B12, stat = item(14))
!tmp      nullify(TS_B12)
!tmp      deallocate( TS_B11, stat = item(13))
!tmp      nullify(TS_B11)
!tmp      deallocate( TS_A1, stat = item(12))
!tmp      nullify(TS_A1)
!tmp      deallocate( axr_p, stat = item(11))
!tmp      nullify(axr_p)
!tmp      deallocate( shifted_bound, stat = item(10))
!tmp      nullify(shifted_bound)
!tmp      deallocate( new_mtend, stat = item(9))
!tmp      nullify(new_mtend)
!tmp      deallocate( d_axis_len, stat = item(8))
!tmp      nullify(d_axis_len)
!tmp      deallocate( ratio_Vp, stat = item(7))
!tmp      nullify(ratio_Vp)
!tmp      deallocate( Qp, stat = item(6))
!tmp      nullify(Qp)
!tmp      deallocate( par, stat = item(5))
!tmp      nullify(par)
!tmp      deallocate( ratio_Mp, stat = item(4))
!tmp      nullify(ratio_Mp)
!tmp      deallocate( new_N, stat = item(3))
!tmp      nullify(new_N)
!tmp      deallocate( new_Q, stat = item(2))
!tmp      nullify(new_Q)
!tmp      deallocate( new_M, stat = item(1))
!tmp      nullify(new_M)
!tmp      if(any(item/=0)) Stop 'Deallocatation failed at aptact'
!tmp    end subroutine deallocate_aptact


    function cal_air_temp(Til,qr,qi) result(T)
      real(PS),intent(in) :: Til,qr,qi
      real(PS) :: T
!!c      integer :: i_y_gt253

!!c      i_y_gt253=0.5*(1.0-sign(1.0,253.0_PS-T))
!!c      T=Til*(1.0_PS+(L_e*qr+L_s*qi)/(c_pa*253.0_PS))
!!c      T=(1.0-real(i_y_gt253))*T+&
!!c               real(i_y_gt253)*&
!!c          0.5*(Til+sqrt(Til**2+4.0_PS*Til/c_pa*(L_e*qr+L_s*qi)))

      T=Til*(1.0_PS+(L_e*qr+L_s*qi)/(c_pa*253.0_PS))
      if(T>253.0_PS) then
         T=0.5*(Til+sqrt(Til**2+4.0_PS*Til/c_pa*(L_e*qr+L_s*qi)))
      endif
    end function cal_air_temp

    subroutine func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                          ,mbx,Lbx,x)
      ! -------------------------------------------------------------
      !   calculate formed and left mass of liquid due to
      !    activation and depositional growth
      ! -------------------------------------------------------------
      integer,intent(in) :: Lbx
      integer,intent(in),dimension(*) :: mbx
      real(PS),dimension(*),intent(in) :: x!,y
      real(PS),dimension(*),intent(inout) :: used_mr_vap,used_Mr_act,liq_left
      integer,dimension(*),intent(inout) :: noccnt

      real(PS) :: d_mean_mass
      integer :: m,n

      do m=1,Lbx
        n=mbx(m)

        used_Mr_vap(n)=0.0_PS
        used_Mr_act(n)=0.0_PS
        liq_left(n)=0.0_PS
        noccnt(n)=1
      enddo

      if(flagp_r>0) then

!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx
          n=mbx(m)

          if(x(n)>0.0_PS.and.sw(n)>0.0_PS.and.used_Ma_act(n)>1.0e-25_PS) then
            if(sw_allact(n)>1.0e-25_PS) then

! <<< 2014/10 T. Hashino modified for KiD, following Stevens 1996
!tmp               akk=min(1.0_PS,x/sw_allact)    ! original
              akk(n)=min(1.0_PS,akk_lmt(n),x(n)/sw_allact(n))
! >>> 2014/10 T. Hashino modified for KiD, following Stevens 1996
            else
              akk(n)=1.0_PS
            endif

            used_Mr_act(n)=used_Mr_act(n)+akk(n)*used_Ma_act(n)
            noccnt(n)=0
          endif
        enddo
!!c         evr=0.0_PS
        do j=1,gr%N_BIN
!CDIR NODEP
!OCL INDEPENDENT
          do m=1,Lbx
            n=mbx(m)
            if((mes_rc(n)==2.or.mes_rc(n)==4).and.&
               gr%MS(j,n)%con>=nlmt.and.gr%MS(j,n)%mass(rmt)>=mlmt ) then

!!$                  d_mean_mass=gr%MS(j,n)%coef(1)*x(n)*gr%dt

              d_mean_mass=(gr%MS(j,n)%coef(1)*x(n)+gr%MS(j,n)%coef(2))*gr%dt
!!c               d_mean_mass=(gr%MS(j,n)%coef(1)*x(n)+gr%MS(j,n)%coef(2)/y(n)+gr%MS(j,n)%coef(3))*gr%dt

              if(d_mean_mass*gr%MS(j,n)%con&
                    <=gr%MS(j,n)%mass(rmat)-gr%MS(j,n)%mass(rmt)) then
                  ! evaporated
                used_Mr_vap(n)=used_Mr_vap(n)-(gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat))

!!c                     write(*,'("bin 1",I5,5ES15.6)') &
!!c                          j,gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat),gr%MS(j,n)%coef(1)
                liq_left(n)=liq_left(n)+0.0_PS

              elseif(d_mean_mass<0.0_PS.and.&
                    (gr%MS(j,n)%r_act>&
                  coef3i4p1i3*((gr%MS(j,n)%mean_mass+d_mean_mass)/gr%MS(j,n)%den)**(1.0/3.0)&
                  )) then
                ! transfer to haze particles
                used_Mr_vap(n)=used_Mr_vap(n)-(gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat))
!!c                     write(*,'("bin 3",I5,5ES15.6)') &
!!c                          j,gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat),gr%MS(j,n)%coef(1) &
!!c                          ,(-gr%MS(j,n)%coef(2)/y(n)-gr%MS(j,n)%coef(3))/gr%MS(j,n)%coef(1) &
!!c                          ,gr%MS(j,n)%r_act,gr%MS(j,n)%a_len
                liq_left(n)=liq_left(n)+0.0_PS

              else
                used_Mr_vap(n)=used_Mr_vap(n)+d_mean_mass*gr%MS(j,n)%con
!!c                     write(*,'("bin 2",I5,5Es15.6)') &
!!c                          j,d_mean_mass,d_mean_mass*gr%MS(j,n)%con,gr%MS(j,n)%coef(1)

!!c                     liq_left=liq_left+gr%MS(j,n)%mass(rmt)+d_mean_mass*gr%MS(j,n)%con
                liq_left(n)=liq_left(n)+gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat)+d_mean_mass*gr%MS(j,n)%con
              end if
            endif
          enddo
        enddo
      endif

    end subroutine func_liqvap_vec

    subroutine func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                          ,noindep &
                          ,mbx,Lbx,x,y)
      use class_Thermo_Var, only: &
         get_sat_vapor_pres_lk
      use class_Ice_Shape, only: &
         get_vip, &
         cal_semiac_ip
      use mod_amps_utility, only: &
         get_inact_tropic
      ! -------------------------------------------------------------
      !   calculate formed and left mass of ice due to
      !    activation and depositional growth, and others
      ! -------------------------------------------------------------
      integer,intent(in) :: Lbx
      integer,dimension(*),intent(in) :: mbx
      real(PS),dimension(*),intent(in) :: x,y
      real(PS),dimension(*),intent(inout) :: used_Mi_vap,used_Mi_vapliq,used_Mi_act &
              ,loss_Mi_mlt,ice_left
      integer,dimension(*),intent(inout) :: noindep
      !
      real(PS) :: xi,xw,tmp,tmp_bf,d_mean_mass,m_w,m_icore,m_w_c,&
             v_cs_p,semi_aip_p,semi_cip_p,v_w,v_ip,v_space,m_shed,&
             dm_w,mass_ap,dia_icore,q
      real(PS) :: x0,x1,x2,gx0,gx1,gx2,dT_w
      real(8) :: TS_B1,TS_D2,w0,w1,w2 &
              ,aL,bL,dL
      real(PS) :: den_w=1.0_PS
      !integer :: emts,i_phase_eq1
      integer :: m,n



!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)

        used_Mi_vap(n)=0.0_PS
        used_Mi_vapliq(n)=0.0_PS
        used_Mi_act(n)=0.0_PS
        loss_Mi_mlt(n)=0.0_PS
        ice_left(n)=0.0_PS
        noindep(n)=1
      enddo

!!c      if(flagp_s>0.and.(si_b/=xi.or.sw_b/=x2)) then
      if(flagp_s>0) then
!!c         ice_left=1.0e+3_PS
         bin_loop1: do j=1,gs%N_BIN
!CDIR NODEP
!OCL INDEPENDENT
           do m=1,Lbx
             n=mbx(m)
             if((mes_rc(n)==3.or.mes_rc(n)==4).and.&
               gs%MS(j,n)%con>=nlmt.and.gs%MS(j,n)%mass(1)>=mlmt ) then

               e_satw=get_sat_vapor_pres_lk(1,y(n),ag%estbar,ag%esitbar)
               e_sati=get_sat_vapor_pres_lk(2,min(T_0,y(n)),ag%estbar,ag%esitbar)
               r_e=e_satw/e_sati

               xi=r_e*(x(n)+1.0_PS)-1.0_PS
               xw=x(n)


!               i_phase_eq1=max(0.0_RP,(-isign(1,phase2(j,n)-1)*max(0,phase2(j,n)-1)+1.0))*&
!                           max(0.0_RP,(-isign(1,phase2(j,n)-1)*min(0,phase2(j,n)-1)+1.0))
               if(T_0>ag%TV(n)%T.and.T_0>y(n)) then
                 if(phase2(j,n)==1) then
                    TS_B1=TS_B11(j,n)*e_satw/y(n) * (xw + 1.0_PS) + &
                          TS_B12(j,n)+TS_B13(j,n)*y(n)
                 else
                    TS_B1=TS_B11(j,n)*e_sati/y(n) * (xi + 1.0_PS) + &
                          TS_B12(j,n)+TS_B13(j,n)*y(n)
                 endif
!                 TS_B1=real(i_phase_eq1)*(TS_B11(j,n)*e_satw/y(n) * (xw + 1.0_PS) + &
!                         TS_B12(j,n)+TS_B13(j,n)*y(n)) +&
!                       real(1-i_phase_eq1)*(TS_B11(j,n)*e_sati/y(n) * (xi + 1.0_PS) + &
!                         TS_B12(j,n)+TS_B13(j,n)*y(n))
!
                 ! locally fit a parabora using Lagrange polynomial
                 ! the fit equation is
                 !   g(x)=esi(Tsfc)/Tsfc
                 ! fit the polynomical
                 !  First trial
                 dT_w=20.0_RP
                 x2=min(Tmax(j,n),gs%MS(j,n)%tmp+dT_w)
                 x1=x2-dT_w
                 x0=x1-dT_w
                 gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                 gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                 gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                 w0=gx0/((x0-x1)*(x0-x2))
                 w1=gx1/((x1-x0)*(x1-x2))
                 w2=gx2/((x2-x0)*(x2-x1))
                 aL=w0+w1+w2
                 bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                 dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                 tmp_bf=gs%MS(j,n)%tmp

                 TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                               4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                 if(TS_D2>=0.0d+0) then
                   tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                       sqrt(TS_D2)  )/ &
                       (2.0*TS_D1(j,n)*aL)
                 else
                   tmp=tmp_bf
                 endif

                 tmp=min(tmp,Tmax(j,n))

                 !  second trial
                 tmp_bf=tmp
                 dT_w=10.0
                 x2=min(Tmax(j,n),tmp+dT_w)
                 x1=x2-dT_w
                 x0=x1-dT_w
                 gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                 gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                 gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                 w0=gx0/((x0-x1)*(x0-x2))
                 w1=gx1/((x1-x0)*(x1-x2))
                 w2=gx2/((x2-x0)*(x2-x1))
                 aL=w0+w1+w2
                 bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                 dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                 TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                               4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                 if(TS_D2>=0.0d+0) then
                   tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                       sqrt(TS_D2)  )/ &
                       (2.0*TS_D1(j,n)*aL)
                 else
                   tmp=tmp_bf
                 endif

                 tmp=min(tmp,Tmax(j,n))
                 if(abs(tmp-tmp_bf)/tmp_bf>1.0e-4) then
                   !  third trial
                   tmp_bf=tmp
                   dT_w=5.0
                   x2=min(Tmax(j,n),tmp+dT_w)
                   x1=x2-dT_w
                   x0=x1-dT_w
                   gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                   gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                   gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                   w0=gx0/((x0-x1)*(x0-x2))
                   w1=gx1/((x1-x0)*(x1-x2))
                   w2=gx2/((x2-x0)*(x2-x1))
                   aL=w0+w1+w2
                   bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                   dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                   TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                                 4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                   if(TS_D2>=0.0d+0) then
                     tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                         sqrt(TS_D2)  )/ &
                         (2.0*TS_D1(j,n)*aL)
                   else
                     tmp=tmp_bf
                   endif

                   tmp=min(tmp,Tmax(j,n))
                 endif
                 if(abs(tmp-tmp_bf)/tmp_bf>1.0e-4) then
                   !  fourth trial
                   tmp_bf=tmp
                   dT_w=1.0
                   x2=min(Tmax(j,n),tmp+dT_w)
                   x1=x2-dT_w
                   x0=x1-dT_w
                   gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                   gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                   gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                   w0=gx0/((x0-x1)*(x0-x2))
                   w1=gx1/((x1-x0)*(x1-x2))
                   w2=gx2/((x2-x0)*(x2-x1))
                   aL=w0+w1+w2
                   bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                   dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                   TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                                 4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                   if(TS_D2>=0.0d+0) then
                     tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                         sqrt(TS_D2)  )/ &
                         (2.0*TS_D1(j,n)*aL)
                   else
                     tmp=tmp_bf
                   endif

                   tmp=min(tmp,Tmax(j,n))
                 endif
                 if(abs(tmp-tmp_bf)/tmp_bf>1.0e-4) then
                   !  fifth trial
                   tmp_bf=tmp
                   dT_w=0.5
                   x2=min(Tmax(j,n),tmp+dT_w)
                   x1=x2-dT_w
                   x0=x1-dT_w
                   gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                   gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                   gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                   w0=gx0/((x0-x1)*(x0-x2))
                   w1=gx1/((x1-x0)*(x1-x2))
                   w2=gx2/((x2-x0)*(x2-x1))
                   aL=w0+w1+w2
                   bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                   dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                   TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                                 4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                   if(TS_D2>=0.0d+0) then
                     tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                         sqrt(TS_D2)  )/ &
                         (2.0*TS_D1(j,n)*aL)
                   else
                     tmp=tmp_bf
                   endif
                   tmp=min(tmp,Tmax(j,n))

                 endif
               else
                 tmp=T_0
               end if

               if(phase2(j,n)==2) then

                 d_mean_mass=(gs%MS(j,n)%coef(1)*e_sati/y(n)*(xi+1.0_PS)+&
                       gs%MS(j,n)%coef(2)*get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)/&
                       tmp)*gs%dt


                 if((gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))/gs%MS(j,n)%con+d_mean_mass&
                       <=0.0_PS) then
                     ! evaporated
!!c                  evi(j)=1.0_PS
                   used_Mi_vap(n)=used_Mi_vap(n)-(gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))

                   ice_left(n)=0.0_PS
!!c                     ice_left=min(ice_left,0.0_PS)
                 else
                   used_Mi_vap(n)=used_Mi_vap(n)+d_mean_mass*gs%MS(j,n)%con

!!c                     ice_left=gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con
                   ice_left(n)=gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat)+d_mean_mass*gs%MS(j,n)%con
!!c                     ice_left=min(ice_left,gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con)
                 end if
!!c                 write(*,*) "used_mi_vap",xi,y(n),used_mi_vap(n),d_mean_mass,gs%MS(j,n)%con

                 if(tmp==T_0) then
                   ! +++ melting +++
                   m_w=(&
                        L_s*(gs%MS(j,n)%coef(1)*e_sati/y(n)*(xi+1.0_PS)+&
                        gs%MS(j,n)%coef(2)*&
                        get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)&
                        /tmp)+&
                        (L_f+C_w*(y(n)-tmp))*gs%MS(j,n)%Ldmassdt(2)&
                        -E_L01(j,n)*(tmp-y(n))&
                        )*gs%dt/L_f
                 else
                   m_w=0.0_PS
                 endif

               else
                 d_mean_mass=(gs%MS(j,n)%coef(1)*e_satw/y(n)*(xw+1.0_PS)+&
                       gs%MS(j,n)%coef(2)*get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)/&
                       tmp)*gs%dt


                 if((gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))/gs%MS(j,n)%con+d_mean_mass&
                       <=0.0_PS) then
                     ! evaporated
                   used_Mi_vapliq(n)=used_Mi_vapliq(n)-(gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))

                   ice_left(n)=0.0_PS
!!c                     ice_left=min(ice_left,0.0_PS)
                 else
                   used_Mi_vapliq(n)=used_Mi_vapliq(n)+d_mean_mass*gs%MS(j,n)%con

!!c                     ice_left=gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con
                   ice_left(n)=gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat)+d_mean_mass*gs%MS(j,n)%con
!!c                     ice_left=min(ice_left,gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con)
                 end if

                 if(T_0<=ag%TV(n)%T) then
                   ! +++ melting +++
                   m_w=max(0.0_PS,(&
                        L_e*(gs%MS(j,n)%coef(1)*e_satw/y(n)*(x(n)+1.0_PS)+&
                        gs%MS(j,n)%coef(2)*&
                        get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)&
                        /tmp)+&
                        c_w*(y(n)-tmp)*gs%MS(j,n)%Ldmassdt(2)&
                        -E_L01(j,n)*(tmp-y(n))&
                        )*gs%dt/L_f)
                 else
                   if(tmp==T_0) then
                     m_w=(&
                           L_e*(gs%MS(j,n)%coef(1)*e_satw/y(n)*(x(n)+1.0_PS)+&
                           gs%MS(j,n)%coef(2)*&
                           get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)&
                           /tmp)+&
                           (L_f+c_w*(y(n)-tmp))*gs%MS(j,n)%Ldmassdt(2)&
                           -E_L01(j,n)*(tmp-y(n))&
                           )*gs%dt/L_f
                   else
                     m_w=0.0_PS
                   endif
                 endif
               endif


               ! +++ melting process tendency +++
               if(level<=3) then
                 mass_ap=0.0_PS
               else
                 mass_ap=gs%MS(j,n)%mass(imat)/gs%MS(j,n)%con
               end if
               dm_w=m_w
               m_w=gs%MS(j,n)%mass(imw)/gs%MS(j,n)%con+m_w

               if((level<=5.and.m_w>0.0_PS).or.&
                  (level>=6.and.m_w>0.0_PS.and.&
                     (gs%MS(j,n)%mass(imw)/gs%MS(j,n)%con>1.0e-12_PS.or.&
                      dm_w/=0.0_PS))) then

                 if(gs%MS(j,n)%mean_mass-mass_ap<=m_w) then
                   ! whole ice melt
!!c                        loss_Mi_mlt=loss_Mi_mlt+max(0.0_PS,min(ice_left,gs%MS(j,n)%mass(1)))
                   loss_Mi_mlt(n)=loss_Mi_mlt(n)+max(0.0_PS,min(ice_left(n),&
                                 gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat)))
!!c                        loss_Mi_mlt=loss_Mi_mlt+gs%MS(j,n)%mass(1)
!!c                     if(ice_left(n)<0.0) then
!!c                       write(*,*) "icelft neg",j,ice_left(n),gs%MS(j,n)%mass(1)
!!c                     endif
                 else

                   m_icore=gs%MS(j,n)%mean_mass-m_w
                   m_w_c=0.268_PS+0.1389_PS*m_icore

                   V_cs_p=m_icore/gs%IS(j,n)%den_ip
                   call cal_semiac_ip(gs%IS(j,n)%is_mod(2),gs%IS(j,n)%phi_cs,&
                                        V_cs_p,semi_aip_p,semi_cip_p)

                   dia_icore=2.0_PS*max(semi_aip_p,semi_cip_p)
                   V_w = m_w/den_w
                   V_ip=get_vip(gs%IS(j,n)%is_mod(2),gs%IS(j,n)%phi_cs,semi_aip_p)
                   V_space=max(0.0_PS,V_ip-m_icore/den_i)

                   q=max(dia_icore-0.9_PS,0.0_PS)
                   q = 1.0_PS+10.67_PS*q-&
                       10.81_PS*q*q+&
                       10.26_PS*q*q*q

                   if(V_space<V_w.and.dia_icore>=0.9_PS.and.m_w>=m_w_c) then
                     m_shed=m_w-gs%MS(j,n)%mean_mass/q
                   elseif(V_space<V_w.and.dia_icore<0.9_PS.and.m_w>rm_frg1) then
                     m_shed=rm_frg1
                   else
                     m_shed=0.0_PS
                   endif
                   loss_Mi_mlt(n)=loss_Mi_mlt(n)+max(0.0_ps,min(ice_left(n),&
                         m_shed*gs%MS(j,n)%con*&
                         (gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))/gs%MS(j,n)%mass(1)))
                 endif

               endif
             endif
           enddo
         enddo bin_loop1

         if(iflg_inuc>0.and.iflg_dep>0) then
!CDIR NODEP
!OCL INDEPENDENT
           do m=1,Lbx
             n=mbx(m)

             e_satw=get_sat_vapor_pres_lk(1,y(n),ag%estbar,ag%esitbar)
             e_sati=get_sat_vapor_pres_lk(2,min(T_0,y(n)),ag%estbar,ag%esitbar)
             r_e=e_satw/e_sati

             xi=r_e*(x(n)+1.0_PS)-1.0_PS
!!!             xw=x(n)

             if( xi>0.0_PS.and.&
                 ( ((y(n) <= T_0-5.0) .and. (x(n)>0.0_PS)) .or.&
                   ((xi >= 0.05_PS).and.(y(n) < T_0 ))).and. &
                 ga(2)%MS(1,n)%con>=nlmt.and.ga(2)%MS(1,n)%mass(1)>=mlmt ) then

! <<< 2014/10 T. Hashino modified for KiD
!tmp                     N_acti=min(get_inact(xi),ga(2)%MS(1,n)%con)
!tmp                     N_acti=min(get_inact_tropic(xi,y),ga(2)%MS(1,n)%con)
!               N_acti=min(get_inact(xi),ga(2)%MS(1,n)%con) ! SHEBA CHIARUI
               N_acti=min(max(get_inact_tropic(xi,y(n))-ni_0(n),0.0_PS),ga(2)%MS(1,n)%con)
! >>> 2014/10 T. Hashino modified for KiD

!!c                  M_acti=get_vapdepact_v2(ag%TV(n),2,xi,ga(2)%dt,ga(2)%MS(1,n)%a_len,ga(2)%MS(1,n)%mean_mass)
!!c                  M_acti=N_acti*cs2_depmode*xi*gr%dt
!!c                  used_M=used_M+max(0.0_PS,M_acti-N_acti*ga(2)%MS(1,n)%mean_mass)

!!c                  used_M=used_M+max(0.0_PS,cs1_i_depmode*xi*N_acti)
               used_Mi_act(n)=max(0.0_PS,cs1_i_depmode(n)*xi,gs%binb(1)*1.1_PS-ga(2)%MS(1,n)%mean_mass)*N_acti

!!c                  used_Mi_act=max(0.0_PS,M_acti-N_acti*ga(2)%MS(1,n)%mean_mass)

               noindep(n)=0
             end if
           enddo
         endif
      endif


    end subroutine func_icevap_vec

    subroutine zbrent_act_vec(sw_n,iphase,iswitch,mbx,Lbx,sw_o,T_a_o,sw_b,T_a)
      integer,intent(in) :: iswitch
      integer,dimension(*),intent(in) :: iphase
      integer,intent(in) :: Lbx
      integer,dimension(*),intent(in) :: mbx
      real(PS),dimension(*),intent(in) :: sw_o,T_a_o
      real(PS),dimension(*),intent(in) :: sw_b,T_a
      real(PS),dimension(*),intent(inout) :: sw_n

      integer,dimension(LMAX) :: icond2
      integer :: Lbx2
      integer,dimension(LMAX) :: mbx2
      REAL(PS) :: tol=1.0e-6
      real(PS) :: eps
      PARAMETER (EPS=3.0e-8)
      !  Using Brent's method, find the root of a function func known to lie between x1 and x2.
      !  The root, returned as zbrent, will be refined until its accuracy is tol.

      !  Parameters: Maximum allowed number of iterations, and machine floating-point precision.
      REAL(PS),dimension(LMAX) :: a,b,c,d,e,fa,fb,fc
      REAL(PS) :: p,q,r,s,tol1,xm
      real(PS),dimension(LMAX) :: dum1,dum2,dum3
      integer,parameter :: nb_it=20

      integer :: itr,m,mm,n
      integer,parameter :: ITMAX_ini=30
      integer,parameter :: ITMAX=50

      integer :: ierror1(ag%L)

      ! initialize the bounds
!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)

        if(iphase(n)==1) then
          b(n)=-0.5_PS
          a(n)=0.2_PS

        elseif(iphase(n)==2) then
          e_satw=get_sat_vapor_pres_lk(1,T_a_o(n),ag%estbar,ag%esitbar)
          e_sati=get_sat_vapor_pres_lk(2,min(T_0,T_a_o(n)),ag%estbar,ag%esitbar)
          r_e=e_satw/e_sati

          ! super saturation over ice is -0.5
          b(n)=(-0.5_PS+1.0_PS)/r_e-1.0_PS

          a(n)=0.2_PS

        endif
      enddo

      do m=1,Lbx
        icond2(m)=1
        mbx2(m)=mbx(m)
      enddo
      Lbx2=Lbx

      do n=1,ag%L
        iterz(n)=0
        iterzi(n)=0
        ierror1(n)=0
      enddo

      do itr=1,ITMAX_ini

        call func_vec(dum1,dum2,dum3,fa,iswitch,mbx2,Lbx2,a,T_a)
        call func_vec(dum1,dum2,dum3,fb,iswitch,mbx2,Lbx2,b,T_a)

!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx2
          n=mbx2(m)

          if(fa(n).lt.0.0_PS.and.fb(n).lt.0.0_PS) then
            if(iswitch==2) then
               a(n)=a(n)*2.0_PS
            else
               a(n)=a(n)+0.2_PS
            endif

            if(a(n)>1.0e+4) then
              ierror1(n)=1
              icond2(m)=0
            endif
          elseif(fa(n).gt.0.0_PS.and.fb(n).gt.0.0_PS) then

            b(n)=b(n)-0.2_PS

            if(b(n)<-2.0e+0) then
              ierror1(n)=2
              icond2(m)=0
            endif
          else
            icond2(m)=0
          end if
        enddo
        if(any(icond2(1:Lbx2)>0)) then
          iterzi(n)=iterzi(n)+1

          ! initialize for next iteration
          mm=0
!CDIR NOVECTOR
          do m=1,Lbx2
            if(icond2(m)==1) then
              mm=mm+1
              mbx2(mm)=mbx2(m)
              icond2(mm)=1
            endif
          enddo
          Lbx2=mm
        else
          Lbx2=0
          exit
        endif
      enddo

      do m=1,Lbx2
        n=mbx2(m)
        ierror1(n)=3
      enddo

      if(any(ierror1(1:ag%L)>0)) then
        do m=1,Lbx
          n=mbx(m)
          if(ierror1(n)>0) then
             qv_max=ag%TV(n)%rv+qr_0(n)+qi_0(n)

             if ( debug ) then
                write(*,'("initialization for zbrent failed",3I5)') ierror1(n),iphase(n),iswitch
                write(*,'("n,iter,em,sw,sw_n,a,b,fa,fb",5I5,15ES15.6)') &
                     KD(n),ID(n),JD(n),iterzi(n),em(n),sw_b(n),sw_n(n),a(n),b(n),fa(n),fb(n)
                write(*,'("W,a_c,N_act,M_act,T,r_e",10ES15.6)') ag%TV(n)%W, a_c, N_act,M_act, ag%TV(n)%T,r_e
                write(*,'("sv1,sv2,qv_max,rvsat1",10ES15.6)') ag%TV(n)%s_v(1),ag%TV(n)%s_v(2),qv_max,&
                     ag%TV(n)%rv_sat(1)
                write(*,'("k,i,j,used_Mr_vap,used_Mr_act,used_Mi_vap+vapliq,used_Mi_act,used_Mi_vapliq",3I5,10ES15.6)') &
                     KD(n),ID(n),JD(n),used_Mr_vap(n),used_Mr_act(n),(used_Mi_vap(n)+used_Mi_vapliq(n)),used_Mi_act(n),used_Mi_vapliq(n)

                do i=1,gr%N_BIN
                   write(*,'(I5,5ES15.6)') i,gr%MS(i,n)%con,gr%MS(i,n)%mass(rmt),gr%MS(i,n)%coef(1),gr%MS(i,n)%coef(2)
                end do
                do i=1,gs%N_BIN
                   write(*,'(I5,5ES15.6)') i,gs%MS(i,n)%con,gs%MS(i,n)%mass(imt),gs%MS(i,n)%coef(1),gs%MS(i,n)%coef(2)
                end do
             end if

             sw_n(n)=sw_o(n)
          endif
        enddo
      endif

      ! start the zbrent algorithm
      do m=1,Lbx
        icond2(m)=1
        mbx2(m)=mbx(m)
      enddo
      Lbx2=Lbx

!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)
        c(n)=b(n)
        fc(n)=fb(n)
      enddo

!!c      write(*,*) "bf iter",c(1),fc(1)
      do itr=1,ITMAX


!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx2
          n=mbx2(m)

          if((fb(n).gt.0.0_PS.and.fc(n).gt.0.0_PS).or.(fb(n).lt.0.0_PS.and.fc(n).lt.0.0_PS))then
            c(n)=a(n) ! Rename a, b, c and adjust bounding interval d.
            fc(n)=fa(n)
            d(n)=b(n)-a(n)
            e(n)=d(n)
          endif
          if(abs(fc(n)).lt.abs(fb(n))) then
            a(n)=b(n)
            b(n)=c(n)
            c(n)=a(n)
            fa(n)=fb(n)
            fb(n)=fc(n)
            fc(n)=fa(n)
          endif
          tol1=2.0_PS*EPS*abs(b(n))+0.5_PS*tol ! Convergence check.
          xm=0.5_PS*(c(n)-b(n))
          if(abs(xm).le.tol1 .or. fb(n).eq.0.)then
            sw_n(n)=b(n)
            icond2(m)=0
          else
            if(abs(e(n)).ge.tol1 .and. abs(fa(n)).gt.abs(fb(n))) then
              s=fb(n)/fa(n) ! Attempt inverse quadratic interpolation.
              if(a(n).eq.c(n)) then
                p=2.0_PS*xm*s
                q=1.0_PS-s
              else
                q=fa(n)/fc(n)
                r=fb(n)/fc(n)
                p=s*(2.*xm*q*(q-r)-(b(n)-a(n))*(r-1.0_PS))
                q=(q-1.0_PS)*(r-1.0_PS)*(s-1.0_PS)
              endif
              if(p.gt.0.) q=-q ! Check whether in bounds.
              p=abs(p)
              if(2.0_PS*p .lt. min(3.0_PS*xm*q-abs(tol1*q),abs(e(n)*q))) then
                e(n)=d(n) ! Accept interpolation.
                d(n)=p/q
              else
                d(n)=xm ! Interpolation failed, use bisection.
                e(n)=d(n)
              endif
            else ! Bounds decreasing too slowly, use bisection.
              d(n)=xm
              e(n)=d(n)
            endif
            a(n)=b(n) ! Move last best guess to a.
            fa(n)=fb(n)
            if(abs(d(n)) .gt. tol1) then ! Evaluate new trial root.
              b(n)=b(n)+d(n)
            else
              b(n)=b(n)+sign(tol1,xm)
            endif

            iterz(n)=iterz(n)+1
            sw_n(n)=b(n)

!!c              write(*,*) "zbrent ck",a(n),b(n),c(n),d(n),e(n),fa(n),fb(n),fc(n)
          endif
        enddo
        if(any(icond2(1:Lbx2)>0)) then
          call func_vec(dum1,dum2,dum3,fb,iswitch,mbx2,Lbx2,b,T_a)
!!c          write(*,*) "zbrent ck2:",b(1),T_a(1),fb(1)

          ! initialize for next iteration
          mm=0
!CDIR NOVECTOR
          do m=1,Lbx2
            if(icond2(m)==1) then
              mm=mm+1
              mbx2(mm)=mbx2(m)
              icond2(mm)=1
            endif
          enddo
          Lbx2=mm

        else
          Lbx2=0
          exit
        endif
      enddo

      if ( debug ) then
         do m=1,Lbx2
            n=mbx2(m)
            write(*,'("brent exceeding maximum iterations. n,sw,sw_n,a,b,fa,fb",2I5,12ES15.6)') &
                 n,sw_b(n),sw_n(n),a(n),b(n),fa(n),fb(n)
            write(*,'("W,a_c,N_act,M_act,T,r_e",10ES15.6)') ag%TV(n)%W, a_c, N_act,M_act, ag%TV(n)%T
         enddo
      end if

     end subroutine zbrent_act_vec

     subroutine func_vec(x_n,y_n,xi_n,  fa,iswitch,mbx,Lbx,x,y)
      ! x: supersaturation over water at current time
      ! y: temperature at current time
      ! x_n: x at next time
      ! y_n: y at next time
      real(PS),dimension(*),intent(in) :: x,y
      real(PS),dimension(*),intent(inout) :: x_n,xi_n,y_n,fa
      integer,intent(in) :: iswitch
      integer,intent(in) :: Lbx
      integer,dimension(*),intent(in) :: mbx

      call func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                          ,mbx,Lbx,   x)

      call func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                          ,noindep &
                          ,mbx,Lbx,   x,y)

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)

        ! ++++ calculate new mixing ratio of hydrometeors ++++
        trans_Mi(n)=loss_Mi_mlt(n)-min(liq_left(n),gain_Mi_rim(n)+gain_Mi_frn(n))

        qr(n)=max(0.0_PS,qr_0(n)+&
            (used_Mr_act(n)+used_Mr_vap(n)+trans_Mi(n))/ag%TV(n)%den)
        qi(n)=max(0.0_PS,qi_0(n)+&
            (used_Mi_vap(n)+used_Mi_vapliq(n)+used_Mi_act(n)-trans_Mi(n))/ag%TV(n)%den)

        if(qr(n)+qi(n)>=qtp(n)) then
          em(n)=iswitch+10
        else
          em(n)=0
        endif
      enddo

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)
        !
        ! ++++ calculate new air temperature (y_n) at t^(n+1) ++++
        y_n(n)=cal_air_temp(Til(n),qr(n),qi(n))
        !
      enddo

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)
        ! ++++ calculate new supersaturation (x_n) at t^(n+1) ++++
        e_satw=get_sat_vapor_pres_lk(1,y_n(n),ag%estbar,ag%esitbar)
        qv_n(n)=max(0.0_PS,qtp(n)-qr(n)-qi(n))
        x_n(n)=ag%TV(n)%P*qv_n(n)/(Rdvchiarui+qv_n(n))/e_satw-1.0_PS

        e_sati=get_sat_vapor_pres_lk(2,min(T_0,y_n(n)),ag%estbar,ag%esitbar)
        r_e=e_satw/e_sati
        xi_n(n)=r_e*(x_n(n)+1.0_PS)-1.0_PS
        ! +++++++++++++++++++++++++++++++++++++++++++++++++

      enddo

      select case(iswitch)
      case(1)
        call func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                            ,mbx,Lbx,   x_n)

        call func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                            ,noindep &
                            ,mbx,Lbx,   x_n,y_n)

!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx
          n=mbx(m)

          trans_Mi(n)=loss_Mi_mlt(n)-min(liq_left(n),gain_Mi_rim(n)+gain_Mi_frn(n))
          qr2(n)=max(0.0_PS,qr_0(n)+&
                (used_Mr_act(n)+used_Mr_vap(n)+trans_Mi(n))/ag%TV(n)%den)

          qi2(n)=max(0.0_PS,qi_0(n)+&
                (used_Mi_vap(n)+used_Mi_vapliq(n)+used_Mi_act(n)-trans_Mi(n))/ag%TV(n)%den)

          fa(n)=(qr(n)+qi(n)-qr2(n)-qi2(n))/max(1.0e-9_RP,ag%TV(n)%rv)

!!c            write(*,*) "fa check",trans_Mi(n),qr2(n),qi2(n),fa(n), &
!!c                used_Mr_act(n),used_Mr_vap(n),trans_Mi(n), &
!!c                used_Mi_vap(n),used_Mi_vapliq(n),used_Mi_act(n),trans_Mi(n),&
!!c                qr(n),qi(n)

        enddo
      case(2)
        do m=1,Lbx
          n=mbx(m)
          fa(n)=-x_n(n)+sw_allow
        enddo
      case(0)
        do m=1,Lbx
          n=mbx(m)
          fa(n)=(qr(n)+qi(n)-qr_b(n)-qi_b(n))/max(1.0e-9_RP,ag%TV(n)%rv)
        enddo
      case default

      end select
     end subroutine func_vec
  end subroutine cal_aptact_var8_vec


  subroutine cal_aptact_var8_kc04dep(level,ag,ncat_a,ga,gr,gs &
                          ,flagp_a,flagp_r,flagp_s,iflg_inuc,iflg_dep,iflg_dhf & ! iflg: 10, 13 ,19
                          ,mes_rc &
                          ,qtp,thil,nu_aps,phi_aps,M_aps &
                          ,ap_sig_cp,ap_mean_cp,CCNMAX,CRIC_RN_IMM,frac_dust& !,cdf_cp_180m0
                          ,snrml,ID,JD,KD)
    use scale_prc, only: &
       PRC_abort
    use class_Mass_Bin, only: &
       data1d_lut_big, &
       interp_data1d_lut_big, &
       get_critrad_anal, &
       get_hazerad_anal, &
       cal_coef_Ts3
    use class_Thermo_Var, only: &
       get_mod_thermal_cond, &
       get_sat_vapor_pres_lk
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec, &
       get_inact
    ! -------------------------------------------------------------------------------------
    !
    ! activation of CCN
    ! NOTE:
    !       only category 1 of aerol group is considered.
    ! -------------------------------------------------------------------------------------
    integer, intent(in)              :: level
    type (AirGroup), intent(inout) :: ag

    ! number of categories of aerosols
    integer,intent(in) :: ncat_a

    ! aerosol group
    type (Group), dimension(ncat_a), intent(inout)  :: ga
    ! rain group, ice group
    type (Group), intent(inout) :: gr,gs

    ! flag for predition
    integer,intent(in) :: flagp_r,flagp_s,flagp_a

    ! flag for nucleation processes
    integer,intent(in)   :: iflg_inuc,iflg_dep,iflg_dhf

    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc

    ! total water mixing ratio
    real(MP_KIND),dimension(*)  :: qtp
    ! theta il
    real(MP_KIND),dimension(*)  :: thil

    real(PS),dimension(ncat_a),intent(in) :: nu_aps,phi_aps,m_aps
    real(PS),dimension(ncat_a),intent(in) :: ap_sig_cp,ap_mean_cp!,cdf_cp_180m0
    real(PS), intent(in) :: CCNMAX, CRIC_RN_IMM, frac_dust

    integer :: ID(*),JD(*),KD(*)
    type(data1d_lut_big),intent(in) :: snrml

    !
    ! new space
    !
    ! error message
    integer,dimension(LMAX) :: em

    ! shifted-bin boundaries
    real(PS), dimension(mxnbin+1,ag%L,2)           :: binb3d
!    real(PS), pointer, dimension(:,:,:)           :: binb3d

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,ag%L,4)           :: a2d
!    real(8), pointer, dimension(:,:,:)           :: a2d
    real(8) :: a2d_0d(4)
    !
    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
!    real(8), pointer, dimension(:,:)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,ag%L,1+mxnmasscomp)          :: new_M
!    real(8), pointer, dimension(:,:,:)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,ag%L,mxnnonmc)          :: new_Q
!    real(8), pointer, dimension(:,:,:)          :: new_Q

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd
!    real(PS), pointer, dimension(:,:)           :: Np
!    real(8), pointer, dimension(:,:)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd
!    real(PS), pointer, dimension(:,:)           :: Mp
!    real(8), pointer, dimension(:,:)           :: Mpd

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,ag%L,mxnmasscomp)      :: ratio_Mp
!    real(PS), pointer, dimension(:,:,:)      :: ratio_Mp

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
    real(PS), dimension(mxnbin+1,ag%L,mxnnonmc+2)             :: Qp
!    real(PS), pointer, dimension(:,:,:)             :: Qp

    ! averaged mass tendency after the time step
    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
!    real(8), pointer, dimension(:,:)                       :: new_mtend

    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend
!    real(PS), pointer, dimension(:,:)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,ag%L,mxnaxis-1) :: axr_p
!    real(PS),pointer, dimension(:,:,:) :: axr_p

    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
!    real(PS), pointer, dimension(:,:)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
!    integer, pointer, dimension(:,:)          :: habit_p
    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
!    real(PS), pointer, dimension(:,:)              :: asr_p
    ! type in shifted bin
   integer, dimension(mxnbin+1,LMAX)          :: type_p
!    integer, pointer, dimension(:,:)          :: type_p

    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p
!    real(PS), pointer, dimension(:,:)           :: actINF_p

    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
!    real(PS), pointer, dimension(:,:)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
!    real(PS), pointer, dimension(:,:)           :: n_exice_p

    ! concentration and mass to be moved into aerosol groups
    real(8),dimension(LMAX)            :: ap_dN, ap_dM
!    real(8), pointer, dimension(:)            :: ap_dN, ap_dM

    ! gravity acceleration
    real(PS), parameter :: g= gg
    ! dry air gas constant
    real(PS), parameter :: R_a=R_u/M_a


    ! surface tension of vapor and water interface
!!c  real(PS), parameter :: sigma_vw=76.0_PS
!!c    real(PS), parameter :: sigma_vw=74.0_PS
!!c  real, parameter :: M_a=28.9, M_w=18.0


    ! limit for prediction
    real(PS),parameter :: nlmt=1.0e-30_PS,mlmt=1.0e-30_PS

    ! super saturation over ice and water at current, next timestep and previous (_b) iteration.
    real(PS),dimension(LMAX) :: sw,sw_n,sw_b,sw_b2,si_n,si_b,sw_m,si_m,sw_o
!    real(PS), pointer, dimension(:) :: sw,sw_n,sw_b,sw_b2,si_n,si_b,sw_m,si_m,sw_o

    real(PS) :: e_satw,e_sati
    real(PS) :: r_e

    real(PS),dimension(LMAX) :: cs1_i_depmode
!    real(PS), pointer, dimension(:) :: cs1_i_depmode

    real(PS) :: AA,sb,beta!,BB(ncat_a),n_aps
    !real(PS) :: s0,ks0,cNd


    !integer :: status

    INTEGER,parameter :: ITMAX=200
    real(PS),PARAMETER :: alim1=1.0e-5,alim2=1.0e-5
    real(PS) :: dif,difT
    real(PS),dimension(LMAX) :: fret
    INTEGER :: iter
    integer,dimension(LMAX) :: iterz,iterzi

    ! number of mass bin derived from the PSD for each category
    integer,parameter :: N_bin_a=10, N_binb_a=N_bin_a+1
    ! normal variate that defines bins
    real(PS),dimension(N_binb_a) :: zn
    integer,dimension(N_bin_a,ncat_a,LMAX) :: noccn
    integer,dimension(LMAX) :: noindep,noccnt,nodhft
    real(PS),dimension(N_bin_a,ncat_a,LMAX) :: s_c,a_c
!    real(PS), pointer, dimension(:) :: zn
!    integer, pointer, dimension(:,:,:) :: noccn
!    integer, pointer, dimension(:) :: noindep,noccnt,nodhft
!    real(PS), pointer, dimension(:,:,:) :: s_c,a_c

    real(PS), dimension(2)           :: binba

    ! process type
    integer,parameter :: pro_type=3
    integer,parameter :: pro_type_dhf_ice=3
    integer,parameter :: pro_type_dhf_aer=6
    integer,parameter :: pro_type_dep_ice=7
    integer,parameter :: pro_type_dep_aer=7

    real(PS) :: coef_a,coef_al1,coef_al2

    real(PS),dimension(N_bin_a,ncat_a,LMAX) ::  M_act,N_act,mean_mass
!    real(PS), pointer, dimension(:,:,:) ::  M_act,N_act,mean_mass
    real(PS) :: mean_mass_ap,mean_mass_dhf & !,M_acti,N_acti
               ,r_n,rd_c,e_n !,m_clv

    real(PS),dimension(LMAX) :: sw_allact
!    real(PS), pointer, dimension(:) :: sw_allact

! <<< 2014/10 T. Hashino added for KiD
    ! activation limitter based on Stevens 1996
    !   this is on when flagp_a==-3
    real(PS),dimension(LMAX) :: akk_lmt
    real(PS),dimension(LMAX) :: akk_lmt_DHF
    real(PS),dimension(LMAX) :: akk
    real(PS),dimension(LMAX) :: akk_DHF
!    real(PS), pointer, dimension(:) :: akk_lmt
!    real(PS), pointer, dimension(:) :: akk_lmt_DHF
!    real(PS), pointer, dimension(:) :: akk
!    real(PS), pointer, dimension(:) :: akk_DHF
! >>> 2014/10 T. Hashino added for KiD
!    real(PS),parameter :: SRW=0.95
!    real(PS),parameter :: SRW=0.95
!    real(PS),parameter :: SRW=1.0
!    real(PS),parameter :: SRW=0.4
!    real(PS),parameter :: SRW=0.4
    !real(PS) :: getfrac_apact,getznorm

    ! maximum realisitc super saturation, and minimum critical radius for activation.
    real(PS),parameter :: max_sw=0.1,min_ac=1.0e-7,min_sw=0.0001

    ! maximum dry aerosol size allowed to activate (micron)
    real(PS),parameter :: max_r_n=10.0
!test    real(PS),parameter :: max_r_n=100.0

    ! maximum dry aerosol size allowed to freeze through deliquesence freezing (cm)
    real(PS),parameter :: max_r_n_DHF=10.0e-4
!test    real(PS),parameter :: max_r_n_DHF=100.0e-4

    ! maximum Cloud droplet number allowed
    !real(PS),parameter :: CCNMAX=215.0_PS
    !real(PS),parameter :: CCNMAX=230.0_PS
    !real(PS),parameter :: CCNMAX=300.0_PS
    !real(PS),parameter :: CCNMAX=350.0_PS
    !real(PS),parameter :: CCNMAX=700.0_PS

    ! maximum ice particle number allowed
    real(PS),parameter :: INMAX=1.7e-3_PS

    ! maximum fraction of activation
    real(PS),parameter :: max_fact=1.0_PS
    real(PS) :: fact_c(N_bin_a),fact_m,xi1,xi2,yi1,yi2,fm2!,wx,x1
    !integer :: i1

    real(PS),dimension(LMAX) :: gain_Mi_frn,gain_Mi_rim
    real(PS),dimension(LMAX) :: used_Ma_act,used_Na_act
    real(PS),dimension(LMAX) :: used_Mr_act,used_Mr_vap,used_Mi_act,used_Mi_vap,used_Mi_vapliq &
               ,loss_Mi_mlt,trans_Mi,liq_left,ice_left
    real(PS),dimension(LMAX) :: used_Ma_DHF,used_Na_DHF
!    real(PS), pointer, dimension(:) :: gain_Mi_frn,gain_Mi_rim
!    real(PS), pointer, dimension(:) :: used_Ma_act,used_Na_act
!    real(PS), pointer, dimension(:) :: used_Mr_act,used_Mr_vap,used_Mi_act,used_Mi_vap,used_Mi_vapliq &
!               ,loss_Mi_mlt,trans_Mi,liq_left,ice_left
!    real(PS), pointer, dimension(:) :: used_Ma_DHF,used_Na_DHF


    ! to diagnose surface temperature of ice particles
    real(PS) :: mk_a
    integer,dimension(mxnbini,LMAX) :: phase2
    real(8),dimension(mxnbini,LMAX) :: TS_A1,TS_B11,TS_B12,TS_B13,TS_D1
    real(PS),dimension(mxnbini,LMAX) :: Tmax
    real(PS),dimension(mxnbini,LMAX) :: E_L01
!    integer, pointer, dimension(:,:) :: phase2
!    real(8), pointer, dimension(:,:) :: TS_A1,TS_B11,TS_B12,TS_B13,TS_D1
!    real(PS), pointer, dimension(:,:) :: Tmax
!    real(PS), pointer, dimension(:,:) :: E_L01


    ! smallest and largest bin numbers for fragment distribution
    integer :: ibinr_frg0,ibinr_frg1
    common/IFRGDIS/ibinr_frg0,ibinr_frg1
    real(PS) :: r_frg0,r_frg1
    common/RFRGDIS/r_frg0,r_frg1

    ! mass of maximum stable liquid
    real(PS) :: rm_frg1

    ! air temperature at t+dt
    real(PS) :: T_a_b2,T_a_r
    real(PS),dimension(LMAX) :: T_a_n,T_a_b,T_a_m,T_a_o
!    real(PS), pointer, dimension(:) :: T_a_n,T_a_b,T_a_m,T_a_o

    ! bulk variables at the current time
    real(PS),dimension(LMAX) :: qr_0,qi_0,nr_0,ni_0
    real(PS),dimension(LMAX) :: qr,qi,qv,qv_n &
             ,qr_b,qi_b,qr_b2,qi_b2,qr2,qi2
!    real(PS), pointer, dimension(:) :: qr_0,qi_0,nr_0,ni_0
!    real(PS), pointer, dimension(:) :: qr,qi,qv,qv_n &
!             ,qr_b,qi_b,qr_b2,qi_b2,qr2,qi2
!!!    real(PS) :: qv_b
    real(PS) :: qv_max!,qv_w,qv_i,sw_max
    integer,dimension(LMAX) :: iqvlmt
    integer,dimension(LMAX) :: imethod
    integer,dimension(LMAX) :: mbx,mbx2
    integer,dimension(LMAX) :: icond1 ! ,ierror1
    integer,dimension(mxnbin+1,LMAX) :: icond3,icond4
    integer,dimension(LMAX) :: iphase
    integer,dimension(mxnbin+1,LMAX)             :: error_number
!    integer, pointer, dimension(:) :: iqvlmt
!    integer, pointer, dimension(:) :: imethod
!    integer, pointer, dimension(:) :: mbx,mbx2
!    integer, pointer, dimension(:) :: icond1, ierror1
!    integer, pointer, dimension(:,:) :: icond3,icond4
!    integer, pointer, dimension(:) :: iphase
!    integer, pointer, dimension(:,:)             :: error_number

    ! supersaturation limit where an adjustment scheme works
    real(PS) :: sw_allow=0.02
!!c    real(PS) :: sw_allow=0.00

    ! t il
    real(PS),dimension(LMAX) :: til
!    real(PS), pointer, dimension(:) :: til
    real(PS),parameter :: Racp=287.04_PS/1004.64_PS,p00=1.0e+6 ! chiarui, origin 287.0/1004.0
    real(PS),dimension(LMAX,ncamx) :: sum_ac,sum_am
    real(PS),dimension(LMAX) :: sum_rc,sum_rm
    real(PS),dimension(LMAX) :: sum_sc,sum_sm
!    real(PS), pointer, dimension(:,:) :: sum_ac,sum_am
!    real(PS), pointer, dimension(:) :: sum_rc,sum_rm
!    real(PS), pointer, dimension(:) :: sum_sc,sum_sm

    integer :: Lbx,Lbx2
    real(PS) :: dum1
    ! supersaturatrion over ice, mass of water, molality
    real(PS) :: si,mw,molality
    real(PS) :: sigma_sv,sigma_is,sigma_iv,Bsv,Tc
    real(PS) :: Lmef,Gn,Hvfr,Hfhet,r_cr,r_d,rd_h
    ! contact parameter between ice and solution
    real(PS),parameter :: mis=0.52
    !
    real(PS),parameter :: Ceps=1.7e11
    ! elastic strain associated with the substrate [-]
    real(PS), parameter :: epsi=0.0
    ! bolzman constant [erg/K]
    real(PS),parameter :: ak=1.38e-16

    real(PS) :: dFact,Swcr,Adhf!,aJfhet,dFcr
    real(PS) :: dFcr1,dFac1,Adhf1
    ! conversion coef from log10 to log
    real(PS),parameter :: alogcnv=2.30258509299405
    !real :: y1,y2,y3,th1,th2,th3,alpha,fgeo1
    ! coefficient for immersion freezing:
    ! Aimm=coef_imm*T/r^2*sqrt(sig/kT)*sqrt(f)
    ! see equation (10) of Savre & Ekman (2014)
    real(PS),parameter :: coef_imm=1.36208874e+3
    !
    real(PS),dimension(N_bin_a,ncat_a,LMAX) ::  M_DHF,N_DHF
!    real(PS), pointer, dimension(:,:,:) ::  M_DHF,N_DHF
    !real(PS) :: scmin
    real(PS),dimension(N_bin_a,ncat_a,LMAX) ::  s_c_dhf
    real(PS),dimension(LMAX) :: s_c_dhfmin,ds_allDHF
!    real(PS), pointer, dimension(:,:,:) ::  s_c_dhf
!    real(PS), pointer, dimension(:) :: s_c_dhfmin,ds_allDHF
    integer :: idry
    !
    ! for deposition nucleation
    !   taken from Table 1 of Savre and Ekman (2014)
    !  Dust (various natural dusts)
    real(PS),parameter :: Adep=1.8e-12
    real(PS) :: dGg1,dGg,dGdes,alogAdep,alogAdep1
    real(PS),parameter :: miv=0.963630453208623        ! 15.5 deg
    ! ak * nus where water molecule frequency of vibration nus=1.0e+13 [s^{-1}]
    real(PS),parameter :: akn=1.38e-3
    ! 16*pi/3.0
    real(PS),parameter :: coef16pi3=16.7551608191456
    real(PS),dimension(N_bin_a,LMAX) ::  M_dep,N_dep
    real(PS),dimension(LMAX) :: used_Ma_dep
    real(PS),dimension(LMAX) :: si_alldep
!    real(PS), pointer, dimension(:,:) ::  M_dep,N_dep
!    real(PS), pointer, dimension(:) :: used_Ma_dep
!    real(PS), pointer, dimension(:) :: si_alldep
    real(PS) :: akk_dep,mean_mass_dep
    real(PS),dimension(LMAX) :: sum_sc_dep,sum_sm_dep
!    real(PS), pointer, dimension(:) :: sum_sc_dep,sum_sm_dep
    integer :: N_bin_dep
    !
    ! Gauss-quadrature method weights and nodes
    !
!    real(PS),parameter,dimension(5) :: x_gq=(/0.0,0.9061798459,0.5384693101 &
!                                             ,-0.9061798459,-0.5384693101 /)
!    real(PS),parameter,dimension(5) :: w_gq=(/0.5688888889,0.2369268851,0.4786286705 &
!                                             ,0.2369268851,0.4786286705 /)
!    real(PS),dimension(5) :: th_gq,fncr,J_gq
!   ! geometric factor
!    real(PS),dimension(5) :: fgeo

!    real(PS),parameter,dimension(8) :: x_gq=&
!                (/-0.9602898565,-0.7966664774,-0.5255324099,-0.1834346425,&
!                   0.1834346425, 0.5255324099, 0.7966664774, 0.9602898565/)
!    real(PS),parameter,dimension(8) :: w_gq=&
!                (/ 0.1012285363, 0.2223810345, 0.3137066459, 0.3626837834,&
!                   0.3626837834, 0.3137066459, 0.2223810345, 0.1012285363/)
    real(PS),parameter,dimension(40) :: w_gq = (/0.004817653796123656, 0.011636585223421486, 0.01534368104372197, 0.022860204610427523, 0.028209344252646654, 0.03341413653303035, 0.038795611982134603, 0.04387757550900829, 0.048700736168824386, 0.05322740599328632, 0.05743966083129328, 0.06130624822181248, 0.06480401437895715, 0.06791204580435271, 0.07061164737201063, 0.07288658239595315, 0.07472316905785292, 0.07611036190063131, 0.07703981816424778, 0.07750594797842483, 0.07750594797842483, 0.07703981816424778, 0.07611036190063131, 0.07472316905785292, 0.07288658239595315, 0.07061164737201063, 0.06791204580435271, 0.06480401437895715, 0.06130624822181248, 0.05743966083129328, 0.05322740599328632, 0.048700736168824386, 0.04387757550900829, 0.038795611982134603, 0.03341413653303035, 0.028209344252646654, 0.022860204610427523, 0.01534368104372197, 0.011636585223421486, 0.004817653796123656/)

    real(PS),parameter,dimension(40) :: x_gq = (/-0.998242892194369, -0.9907278892919245, -0.977277059406946, -0.9579161898188518, -0.9328158132815395, -0.902101168229306, -0.8659603056567768, -0.8246110976324008, -0.7783048322990261, -0.7273182247387979, -0.6719566492471739, -0.6125538965992597, -0.5494671240345872, -0.48307580174619236, -0.4137792043667943, -0.3419940908253989, -0.26815218500726834, -0.1926975807013714, -0.11608407067525514, -0.03877241750605083, 0.03877241750605083, 0.11608407067525514, 0.1926975807013714, 0.26815218500726834, 0.3419940908253989, 0.4137792043667943, 0.48307580174619236, 0.5494671240345872, 0.6125538965992597, 0.6719566492471739, 0.7273182247387979, 0.7783048322990261, 0.8246110976324008, 0.8659603056567768, 0.902101168229306, 0.9328158132815395, 0.9579161898188518, 0.977277059406946, 0.9907278892919245, 0.998242892194369/)
    integer :: quadrature_loop

    real(PS),dimension(40) :: fgeo
    real(PS),dimension(40) :: th_gq,fncr,J_gq

    real(PS) :: amis,pdf,f_gq,f_gqN,thmid
    real(PS),parameter :: thmax=180.0_PS
!!!    real(PS),parameter :: thmax=100.0_PS
!!!    real(PS),parameter :: thmax=120.0_PS
    !
    integer,dimension(LMAX) :: icycle_n
!    integer,dimension(LMAX*mxnbin) :: ierror
!    integer, pointer, dimension(:) :: icycle_n
!    integer, pointer, dimension(:) :: ierror

    real(PS), parameter :: Rdvchiarui=287.04_PS/461.50_PS

    integer  :: i,j,k,n,ica,m,mm

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!$    ! start initializing pointers
!!$    allocate(binb3d(mxnbin+1,ag%L,2))
!!$    allocate(a2d(mxnbin+1,ag%L,4))
!!$    allocate(new_N(mxnbin,LMAX))
!!$    allocate(new_M(mxnbin,ag%L,1+mxnmasscomp))
!!$    allocate(new_Q(mxnbin,ag%L,mxnnonmc))
!!$    allocate(Np(mxnbin+1,LMAX),Npd(mxnbin+1,LMAX))
!!$    allocate(Mp(mxnbin+1,LMAX),Mpd(mxnbin+1,LMAX))
!!$    allocate(ratio_Mp(mxnbin+1,ag%L,mxnmasscomp))
!!$    allocate(Qp(mxnbin+1,ag%L,mxnnonmc+2))
!!$    allocate(new_mtend(mxnbin,LMAX))
!!$    allocate(mtend(mxnbin+1,LMAX))
!!$    allocate(axr_p(mxnbin+1,ag%L,mxnaxis-1))
!!$    allocate(den_ip_p(mxnbin+1,LMAX),den_ic_p(mxnbin+1,LMAX))
!!$    allocate(habit_p(mxnbin+1,LMAX))
!!$    allocate(asr_p(mxnbin+1,LMAX))
!!$    allocate(type_p(mxnbin+1,LMAX))
!!$    allocate(actINF_p(mxnbin+1,LMAX))
!!$    allocate(rag_p(mxnbin+1,LMAX),rcg_p(mxnbin+1,LMAX))
!!$    allocate(n_exice_p(mxnbin+1,LMAX))
!!$    allocate(ap_dN(LMAX),ap_dM(LMAX))
!!$    allocate(sw(LMAX),sw_n(LMAX),sw_b(LMAX),sw_b2(LMAX),si_n(LMAX),si_b(LMAX),sw_m(LMAX),si_m(LMAX),sw_o(LMAX))
!!$    allocate(cs1_i_depmode(LMAX))
!!$    allocate(zn(N_binb_a))
!!$    allocate(noccn(N_bin_a,ncat_a,LMAX))
!!$    allocate(noindep(LMAX),noccnt(LMAX),nodhft(LMAX))
!!$    allocate(s_c(N_bin_a,ncat_a,LMAX),a_c(N_bin_a,ncat_a,LMAX))
!!$    allocate(M_act(N_bin_a,ncat_a,LMAX),N_act(N_bin_a,ncat_a,LMAX),mean_mass(N_bin_a,ncat_a,LMAX))
!!$    allocate(sw_allact(LMAX))
!!$    allocate(akk_lmt(LMAX),akk_lmt_DHF(LMAX),akk(LMAX),akk_DHF(LMAX))
!!$    allocate(gain_Mi_frn(LMAX),gain_Mi_rim(LMAX))
!!$    allocate(used_Ma_act(LMAX),used_Na_act(LMAX))
!!$    allocate(used_Mr_act(LMAX),used_Mr_vap(LMAX), used_Mi_act(LMAX),used_Mi_vap(LMAX), &
!!$             used_Mi_vapliq(LMAX),loss_Mi_mlt(LMAX),trans_Mi(LMAX),liq_left(LMAX), &
!!$             ice_left(LMAX))
!!$    allocate(used_Ma_DHF(LMAX),used_Na_DHF(LMAX))
!!$    allocate(phase2(mxnbini,LMAX))
!!$    allocate(TS_A1(mxnbini,LMAX),TS_B11(mxnbini,LMAX),TS_B12(mxnbini,LMAX),TS_B13(mxnbini,LMAX),TS_D1(mxnbini,LMAX))
!!$    allocate(Tmax(mxnbini,LMAX))
!!$    allocate(E_L01(mxnbini,LMAX))
!!$    allocate(T_a_n(LMAX),T_a_b(LMAX),T_a_m(LMAX),T_a_o(LMAX))
!!$    allocate(qr_0(LMAX),qi_0(LMAX),nr_0(LMAX),ni_0(LMAX))
!!$    allocate(qr(LMAX),qi(LMAX),qv(LMAX),qv_n(LMAX),qr_b(LMAX),qi_b(LMAX),qr_b2(LMAX),qi_b2(LMAX),qr2(LMAX),qi2(LMAX))
!!$    allocate(iqvlmt(LMAX))
!!$    allocate(imethod(LMAX))
!!$    allocate(mbx(LMAX),mbx2(LMAX))
!!$    allocate(icond1(LMAX),ierror1(LMAX))
!!$    allocate(icond3(mxnbin+1,LMAX),icond4(mxnbin+1,LMAX))
!!$    allocate(iphase(LMAX))
!!$    allocate(error_number(mxnbin+1,LMAX))
!!$    allocate(til(LMAX))
!!$    allocate(sum_ac(LMAX,ncamx),sum_am(LMAX,ncamx))
!!$    allocate(sum_rc(LMAX),sum_rm(LMAX))
!!$    allocate(sum_sc(LMAX),sum_sm(LMAX))
!!$    allocate(M_DHF(N_bin_a,ncat_a,LMAX),N_DHF(N_bin_a,ncat_a,LMAX))
!!$    allocate(s_c_dhf(N_bin_a,ncat_a,LMAX))
!!$    allocate(s_c_dhfmin(LMAX),ds_allDHF(LMAX))
!!$    allocate(M_dep(N_bin_a,LMAX),N_dep(N_bin_a,LMAX))
!!$    allocate(used_Ma_dep(LMAX))
!!$    allocate(si_alldep(LMAX))
!!$    allocate(sum_sc_dep(LMAX),sum_sm_dep(LMAX))
!!$    allocate(icycle_n(LMAX))
!!$    allocate(ierror(LMAX*mxnbin))
!!$    ! end of initialization of pointers


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    if(mxnbin+1<N_bin_a) then
       LOG_ERROR("cal_aptact_var8_kc04dep",*) "var8: Error. Increase mxnbin",mxnbin,n_bin_a
       call PRC_abort
    endif

    zn=(/-3.090232306,-2.472185845,-1.854139384,-1.236092922,-0.618046461,0.0&
         ,0.618046461,1.236092922,1.854139384,2.472185845,3.090232306/)

    fact_c=(/0.005714484,0.025145127,0.076352402,0.160060344,0.231727644 &
            ,0.231727644,0.160060344,0.076352402,0.025145127,0.005714484/)

!!c    coef_a=2.0_PS*sigma_vw/(den_w*R_v)
    coef_a=2.0_PS/(den_w*R_v)

!!c    coef_al1=g*L_e/(c_pa*R_v)
!!c    coef_al2=-g*M_a/R_u
    coef_al1=g*L_e*Rdvchiarui*M_a/(c_pa*R_u)
    coef_al2=-g*M_a/R_u

    rm_frg1=coef4pi3*r_frg1**3

    do n=1,ag%L

      ! figure out the grid boxes to be skipped for CCN activation
      icycle_n(n)=0

      if( mes_rc(n) == 0 ) then
        icycle_n(n)=1
      elseif(mes_rc(n)==1) then
        if( qtp(n)>1.0e-20_PS.and.&
              ((flagp_r>0.and.ag%TV(n)%s_v(1)>0.0_PS).or.&
               (flagp_s>0.and.iflg_inuc>0.and.(&
                   (iflg_dep>0.and.ag%TV(n)%s_v(2)>0.0_PS.and.ag%TV(n)%T<T_0).or.&
                   (iflg_dhf>0.and.ag%TV(n)%s_v(2)>0.0_PS.and.ag%TV(n)%T<T_0)  ) &
                  )&
               ) ) then
        else
          icycle_n(n)=1
        endif
      endif
    enddo

    if(all(icycle_n(1:ag%L)==1)) then
!!$       deallocate(binb3d)
!!$       deallocate(a2d)
!!$       deallocate(new_N)
!!$       deallocate(new_M)
!!$       deallocate(new_Q)
!!$       deallocate(Np,Npd)
!!$       deallocate(Mp,Mpd)
!!$       deallocate(ratio_Mp)
!!$       deallocate(Qp)
!!$       deallocate(new_mtend)
!!$       deallocate(mtend)
!!$       deallocate(axr_p)
!!$       deallocate(den_ip_p,den_ic_p)
!!$       deallocate(habit_p)
!!$       deallocate(asr_p)
!!$       deallocate(type_p)
!!$       deallocate(actINF_p)
!!$       deallocate(rag_p,rcg_p)
!!$       deallocate(n_exice_p)
!!$       deallocate(ap_dN,ap_dM)
!!$       deallocate(sw,sw_n,sw_b,sw_b2,si_n,si_b,sw_m,si_m,sw_o)
!!$       deallocate(cs1_i_depmode)
!!$       deallocate(zn)
!!$       deallocate(noccn)
!!$       deallocate(noindep,noccnt,nodhft)
!!$       deallocate(s_c,a_c)
!!$       deallocate(M_act,N_act,mean_mass)
!!$       deallocate(sw_allact)
!!$       deallocate(akk_lmt,akk_lmt_DHF,akk,akk_DHF)
!!$       deallocate(gain_Mi_frn,gain_Mi_rim)
!!$       deallocate(used_Ma_act,used_Na_act)
!!$       deallocate(used_Mr_act,used_Mr_vap, used_Mi_act,used_Mi_vap, &
!!$                used_Mi_vapliq,loss_Mi_mlt,trans_Mi,liq_left, &
!!$                ice_left)
!!$       deallocate(used_Ma_DHF,used_Na_DHF)
!!$       deallocate(phase2)
!!$       deallocate(TS_A1,TS_B11,TS_B12,TS_B13,TS_D1)
!!$       deallocate(Tmax)
!!$       deallocate(E_L01)
!!$       deallocate(T_a_n,T_a_b,T_a_m,T_a_o)
!!$       deallocate(qr_0,qi_0,nr_0,ni_0)
!!$       deallocate(qr,qi,qv,qv_n,qr_b,qi_b,qr_b2,qi_b2,qr2,qi2)
!!$       deallocate(iqvlmt)
!!$       deallocate(imethod)
!!$       deallocate(mbx,mbx2)
!!$       deallocate(icond1,ierror1)
!!$       deallocate(icond3,icond4)
!!$       deallocate(iphase)
!!$       deallocate(error_number)
!!$       deallocate(til)
!!$       deallocate(sum_ac,sum_am)
!!$       deallocate(sum_rc,sum_rm)
!!$       deallocate(sum_sc,sum_sm)
!!$       deallocate(M_DHF,N_DHF)
!!$       deallocate(s_c_dhf)
!!$       deallocate(s_c_dhfmin,ds_allDHF)
!!$       deallocate(M_dep,N_dep)
!!$       deallocate(used_Ma_dep)
!!$       deallocate(si_alldep)
!!$       deallocate(sum_sc_dep,sum_sm_dep)
!!$       deallocate(icycle_n)
!!$       deallocate(ierror)
       return
    endif

    do n=1,ag%L
      ! initialization
      ag%TV(n)%svw0=ag%TV(n)%s_v(1)

      qr_0(n)=0.0_PS
      qi_0(n)=0.0_PS
      nr_0(n)=0.0_PS
      ni_0(n)=0.0_PS


      used_Ma_act(n)=0.0_PS
      used_Na_act(n)=0.0_PS

      used_Ma_DHF(n)=0.0_PS
      used_Na_DHF(n)=0.0_PS

      used_Ma_dep(n)=0.0_PS

      used_Mr_vap(n)=0.0_PS
      used_Mr_act(n)=0.0_PS
      used_Mi_vap(n)=0.0_PS
      used_Mi_vapliq(n)=0.0_PS
      used_Mi_act(n)=0.0_PS
      loss_Mi_mlt(n)=0.0_PS

      gain_Mi_frn(n)=0.0_PS
      gain_Mi_rim(n)=0.0_PS

      akk_lmt(n)=1.0_PS
      akk_lmt_DHF(n)=1.0_PS

      sw(n)=ag%TV(n)%s_v(1)
      sw_n(n)=sw(n)
      sw_m(n)=sw(n)
      T_a_n(n)=ag%TV(n)%T
!!c      write(*,*) "sw,t",ag%TV(n)%s_v(1),ag%TV(n)%T

      sw_b(n)=sw_n(n)
      T_a_b(n)=T_a_n(n)

      em(n)=0
      iqvlmt(n)=0
      noccnt(n)=1
      nodhft(n)=1
      noindep(n)=1

      ! imethod
      !   0:
      imethod(n)=0
      iphase(n)=0

      sum_rc(n)=0.0_PS
      sum_rm(n)=0.0_PS

      s_c_dhfmin(n)=999.0
      sum_sc(n)=0.0_PS
      sum_sm(n)=0.0_PS

      sum_sc_dep(n)=0.0_PS
      sum_sm_dep(n)=0.0_PS
    enddo

    do i=1,gr%n_bin
!CDIR NODEP
      do n=1,gr%L
        if(mes_rc(n)==2.or.mes_rc(n)==4) then
          qr_0(n)=qr_0(n)+max(0.0_PS,gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))

          gain_Mi_frn(n)=gain_Mi_frn(n) &
                ! contact freezing
                +max(0.0_DS,-(gr%MS(i,n)%dmassdt(rmt,8)-gr%MS(i,n)%dmassdt(rmat,8)))&
                ! immersion freezing
                +max(0.0_DS,-(gr%MS(i,n)%dmassdt(rmt,11)-gr%MS(i,n)%dmassdt(rmat,11)))&
                ! homogeneous freezing
                +max(0.0_DS,-(gr%MS(i,n)%dmassdt(rmt,12)-gr%MS(i,n)%dmassdt(rmat,12)))

          nr_0(n)=nr_0(n)+gr%MS(i,n)%con
        endif
      enddo
    enddo

    do i=1,gs%n_bin
!CDIR NODEP
      do n=1,gs%L
        if(mes_rc(n)==3.or.mes_rc(n)==4) then

          E_L01(i,n)=4.0_PS*PI*gs%MS(i,n)%CAP*ag%TV(n)%k_a*gs%MS(i,n)%fh
!!c             gain_Mi_rim=gain_Mi_rim+gs%MS(i,n)%dmassdt(imt,4)
          gain_Mi_rim(n)=gain_Mi_rim(n)+(gs%MS(i,n)%dmassdt(imt,4)-gs%MS(i,n)%dmassdt(imat,4))

          qi_0(n)=qi_0(n)+max(0.0_PS,gs%MS(i,n)%mass(imt)-gs%MS(i,n)%mass(imat))
          ni_0(n)=ni_0(n)+gs%MS(i,n)%con

        end if
        ! coefficients to calculate surface temperature of ice particles
        ! calculate modified thermal conductivity
        if(gs%MS(i,n)%con>=1.0e-30_PS.and.gs%MS(i,n)%mass(1)>=1.0e-30_PS) then
          mk_a = get_mod_thermal_cond(sqrt(gs%MS(i,n)%semi_a**2+gs%MS(i,n)%semi_c**2),&
                                      ag%TV(n)%K_a,ag%TV(n)%T,ag%TV(n)%den)
        else
          mk_a = ag%TV(n)%K_a
        endif
        call cal_coef_Ts3(gs%MS(i,n),ag%TV(n),gs%token &
                         ,TS_A1(i,n),TS_B11(i,n),TS_B12(i,n),TS_B13(i,n),TS_D1(i,n) &
                         ,phase2(i,n),Tmax(i,n),mk_a)
      enddo
    enddo

    do n=1,gs%L
      qr_0(n)=qr_0(n)/ag%TV(n)%den
      qi_0(n)=qi_0(n)/ag%TV(n)%den
      gain_Mi_rim(n)=gain_Mi_rim(n)*gs%dt
      gain_Mi_frn(n)=gain_Mi_frn(n)*gs%dt

!      ierror(n)=0
      if(ga(1)%MS(1,n)%p(1).eq.0.0.or.ga(1)%MS(1,n)%p(2).eq.0.0) then
         LOG_ERROR("cal_aptact_var8_kc04dep",*) "cal_aptact_var8>distribution parameters are 0, check them",&
                   KD(n),ID(n),JD(n),ga(1)%MS(1,n)%p,ga(1)%MS(1,n)%con, ga(1)%MS(1,n)%mass(1)
         call PRC_abort
      endif
    enddo


    ! initialization
    do n=1,ag%L

      qv(n)=ag%TV(n)%rv
!!c      write(*,*) "ck qv in var8:",kd(n),id(n),jd(n),n,qv(n),qr_0(n),qi_0(n)
      qr_b(n)=qr_0(n)
      qr_b2(n)=qr_0(n)
      qi_b(n)=qi_0(n)
      qi_b2(n)=qi_0(n)

      if(ag%TV(n)%T<T_0) then
        call cal_coef_svsteady_init(ga(2),n,cs1_i_depmode(n))
      end if

    enddo

!    do in=1,ag%L*ncat_a
!      ica=(in-1)/ag%L+1
!      n=in-(ica-1)*ag%L
    do ica = 1, ncat_a
    do n = 1, ag%L
      sum_ac(n,ica)=0.0_PS
      sum_am(n,ica)=0.0_PS
    enddo
    enddo

!    do ijn=1,N_bin_a*ncat_a*ag%L
!      jn=(ijn-1)/N_bin_a+1
!      i=ijn-(jn-1)*N_bin_a
!      n=(jn-1)/ncat_a+1
!      ica=jn-(n-1)*ncat_a
    do n = 1, ag%L
    do ica = 1, ncat_a
    do i = 1, N_bin_a

      noccn(i,ica,n)=1
      a_c(i,ica,n)=1.0e+5_PS
      s_c(i,ica,n)=1.0e+5_PS
      N_act(i,ica,n)=0.0_PS
      M_act(i,ica,n)=0.0_PS

      ! size-invariant coef
      AA=coef_a*ag%TV(n)%sig_wa

      ! calculate critical supersaturation for mass bins for each category of aerosols

      ! molecular weight is the one of soluble material of the aerosol.
!org        BB(ica)=nu_aps(ica)*phi_aps(ica)*ga(ica)%MS(1,n)%eps_map*M_W*ga(ica)%MS(1,n)%den/(M_aps(ica)*den_w)

      if(ica/=2) then
        ! mass bin boundary
        dum1=coef4pi3*ga(ica)%MS(1,n)%den*&
                    exp(ga(ica)%MS(1,n)%p(2))*ga(ica)%MS(1,n)%p(1) &
                       *ga(ica)%MS(1,n)%p(1)*ga(ica)%MS(1,n)%p(1)

        binba(1)=dum1*exp(3.0*zn(i))
        binba(2)=dum1*exp(3.0*zn(i+1))

        ! moles of soluble material
!org        n_aps=ga(ica)%MS(1,n)%mass(ams)/ga(ica)%MS(1,n)%con/M_aps(ica)

        N_act(i,ica,n)=fact_c(i)*ga(ica)%MS(1,n)%con
!!c        fact_m=getznorm2(dble( zn(i+1)-3.0_PS*ga(ica)%MS(1,n)%p(2)))-&
!!c               getznorm2(dble(   zn(i)-3.0_PS*ga(ica)%MS(1,n)%p(2)))

        xi2=zn(i+1)-3.0_PS*ga(ica)%MS(1,n)%p(2)
!        i1=max(1,min(snrml%n-1 &
!            ,int((abs(xi2)-snrml%xs)/snrml%dx)+1))
!        x1=real(i1-1)*snrml%dx+snrml%xs
!        wx=min(1.0_RP,max(0.0_RP,(abs(xi2)-x1)/snrml%dx))
!        yi2=min(1.0_RP,max(0.0_RP, &
!                   (1.0_RP-wx)*snrml%y(i1)+ &
!                        wx*snrml%y(i1+1) ))
        yi2=interp_data1d_lut_big(snrml,abs(xi2))

        xi1=zn(i)-3.0_PS*ga(ica)%MS(1,n)%p(2)
!        i1=max(1,min(snrml%n-1 &
!            ,int((abs(xi1)-snrml%xs)/snrml%dx)+1))
!        x1=real(i1-1)*snrml%dx+snrml%xs
!        wx=min(1.0_RP,max(0.0_RP,(abs(xi1)-x1)/snrml%dx))
!        yi1=min(1.0_RP,max(0.0_RP, &
!                   (1.0-wx)*snrml%y(i1)+ &
!                        wx*snrml%y(i1+1) ))
        yi1=interp_data1d_lut_big(snrml,abs(xi1))

        if(xi1>=0.0_RP) then
          fm2=yi1-yi2
        elseif(xi1<=0.0_RP.and.xi2>0.0_RP) then
          fm2=1.0-yi1-yi2
        else
          fm2=yi2-yi1
        endif

!!c        write(*,*) "ck fact_m",fact_m,fm2,xi1,xi2,yi1,yi2
!       stop

        fact_m=fm2

        M_act(i,ica,n)=min(max_fact,fact_m)*ga(ica)%MS(1,n)%mean_mass*ga(ica)%MS(1,n)%con

!!!        write(*,*) "ck aerosol",ica,ga(ica)%ms(1,n)%con,n_act(i,ica,n),m_act(i,ica,n)



        if(icycle_n(n)==0.and.sw(n)>0.0_PS.and.&
           N_act(i,ica,n)>=nlmt.and.M_act(i,ica,n)>=mlmt.and.&
           ga(ica)%MS(1,n)%eps_map>=min_eps_ccn) then

          ! dry radius in micron meter
          r_n=1.0e+4_PS*(M_act(i,ica,n)/N_act(i,ica,n)/ga(ica)%MS(1,n)%den/coef4pi3)**(1.0/3.0)

          ! calculate critical radius for given molality and temperature (in micro meter)
!tmp                   rd_c=get_critrad_itr(AA/ag%TV(n)%T*1.0e+4_PS,BB(ica),n_aps*1.0e+12_PS,r_n)

          ! BB defined by Khvorostyanov and Curry (unitless for beta=0.5)
          sb=nu_aps(ica)*ga(ica)%MS(1,n)%eps_map*M_W*ga(ica)%MS(1,n)%den/(M_aps(ica)*den_w)*phi_aps(ica)
          beta=0.5

          rd_c=1.0e+4_PS*get_critrad_anal(AA/ag%TV(n)%T,sb,beta,r_n*1.0e-4_PS)  ! [micron]
          a_c(i,ica,n)=rd_c*1.0e-4_PS  ! [cm]

          ! haze radius for the given S [cm]
          rd_h=get_hazerad_anal(AA/ag%TV(n)%T,sb,beta,1.0+sw(n),r_n*1.0e-4_PS)

            ! get critical super saturation at the bin boundary
!tmp                   s_c(i,ica)=dexp(real(AA/ag%TV(n)%T*1.0e+4_PS/rd_c-&
!tmp                      BB(ica)*get_osm(1,1.0e+3_PS*n_aps/(coef4pi3*(rd_c**3-r_n**3)))*&
!tmp                      r_n**3/(rd_c**3-r_n**3),8)  )-1.0d+0
          s_c(i,ica,n)=dexp( real(AA/ag%TV(n)%T*1.0e+4_PS/rd_c-&
                          sb*r_n**(2.0*(1.0+beta))/&
                          (rd_c**3-r_n**3),8) ) -1.0d+0

          if(s_c(i,ica,n)<=sw(n).and.r_n<=max_r_n.and.s_c(i,ica,n)<=sw_allow) then

            ! use the haze size for the mass growth over one time step
!test            mean_mass(i,ica,n)=coef4pi3*(den_w*(rd_h*rd_h*rd_h-r_n*r_n*r_n*1.0e-12_PS)+&
!test                               ga(ica)%MS(1,n)%den*r_n*r_n*r_n*1.0e-12_PS)
!org            mean_mass(i,ica,n)=coef4pi3*(den_w*(a_c(i,ica,n)*a_c(i,ica,n)*a_c(i,ica,n)-&
!org                                 r_n*r_n*r_n*1.0e-12_PS)+&
!org                               ga(ica)%MS(1,n)%den*r_n*r_n*r_n*1.0e-12_PS)


            mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)

            ! assume the growth of 5% by mass, just to transfer them into liquid
            ! spectrum
            mean_mass(i,ica,n)=max(gr%binb(1)*1.05_PS,mean_mass_ap*1.05_PS)

!org            m_clv=binba(2)+&
!org                    (mean_mass(i,ica,n)-mean_mass_ap)*(binba(2)/mean_mass_ap)**(1.0/3.0)
!org            if(m_clv>=gr%binb(1).and.mean_mass(i,ica,n)>mean_mass_ap ) then

              noccn(i,ica,n)=0

!dbg              write(*,*) "ck a_c",n,ica,i,a_c(i,ica,n),rd_h,r_n,AA/ag%TV(n)%T,sb,ga(ica)%MS(1,n)%den &
!dbg                       ,ga(ica)%MS(1,n)%eps_map,rd_c,s_c(i,ica,n),N_act(i,ica,n)
!org            endif
          endif
        endif
      endif
    enddo
    enddo
    enddo

!org    if(flagp_a==-3.or.flagp_a==-1.or.flagp_a==-6.or.flagp_a==-4) then
!org      do n=1,ag%L
!org        ni_0(n)=0.0_PS
!org      enddo
!org    endif

!!!    write(*,*) "Im kc04",iflg_inuc,iflg_dhf
!
!    Deliquescence-heterogeneous freezing
!
    DHF_IF1: if(iflg_inuc>0.and.iflg_dhf>0) then
!      do ijn=1,N_bin_a*ncat_a*ag%L
!        jn=(ijn-1)/N_bin_a+1
!        i=ijn-(jn-1)*N_bin_a
!        n=(jn-1)/ncat_a+1
!        ica=jn-(n-1)*ncat_a
       do n = 1, ag%L
       do ica = 1, ncat_a
       do i = 1, N_bin_a

        N_DHF(i,ica,n)=0.0_PS
        M_DHF(i,ica,n)=0.0_PS


        si=ag%TV(n)%s_v(2)
        Tc=ag%TV(n)%T-T_0

        if(si>0.0_PS.and.Tc<0.0.and.ica/=2.and.&
!!!           sw(n)<0.0_PS.and.&   ! it does not change the results
           N_act(i,ica,n)>=nlmt.and.M_act(i,ica,n)>=mlmt.and.&
           ga(ica)%MS(1,n)%eps_map>=min_eps_ccn.and.&
           ga(ica)%MS(1,n)%th00_cp<thmax.and.&
           noccn(i,ica,n)==1) then

           ! unit is now in cm
           AA=coef_a*ag%TV(n)%sig_wa

           ! BB defined by Khvorostyanov and Curry (unitless for beta=0.5)
           sb=nu_aps(ica)*ga(ica)%MS(1,n)%eps_map*M_W*ga(ica)%MS(1,n)%den/(M_aps(ica)*den_w)*phi_aps(ica)
           beta=0.5

           ! dry aerosol radius in cm
           mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)
           r_n=(mean_mass_ap/ga(ica)%MS(1,n)%den/coef4pi3)**(1.0/3.0)

           ! haze radius for the given S [cm]
           rd_h=get_hazerad_anal(AA/ag%TV(n)%T,sb,beta,1.0+sw(n),r_n)

           if(abs(rd_h-r_n)/r_n<1.0e-5) then
             idry=1
             rd_h=r_n*1.05
           else
             idry=0
           endif
           mw=coef4pi3*(rd_h*rd_h*rd_h-r_n*r_n*r_n)*den_w

           ! molality [mol/kg]
           !!!write(*,*) "ck mw",ica,i,n,M_aps(ica),mean_mass_ap,ga(ica)%MS(1,n)%eps_map,mw,rd_h,r_n
           Molality=1.0e+3/M_aps(ica)*mean_mass_ap*ga(ica)%MS(1,n)%eps_map/mw

           ! surface tension between ice and air
           !   Hoose and Mohler (2012)
           sigma_iv=76.1-0.155*(ag%TV(n)%T-T_0)+28.5+0.25*(ag%TV(n)%T-T_0)
!           if(Tc>-36.0) then
!             sigma_iv=ag%TV(n)%sig_wa+(28.0+0.25*Tc)
!           else
!             sigma_iv=ag%TV(n)%sig_wa+189.081+13.1625*Tc+0.3469*Tc*Tc+3.125e-3*Tc*Tc*Tc
!           endif

           ! surface tension between solution and air
           !  for (NH4)2SO4
!           Bsv=2.353
!           sigma_sv=ag%TV(n)%sig_wa+Bsv*molality
           ! mass concentration by weight, Tabazadeh et al. 1997
!           dum1=mean_mass_ap*ga(ica)%MS(1,n)%eps_map/mw
!           sigma_sv=142.35-0.96525*dum1-ag%TV(n)%T*(0.22954-0.0033948*dum1)
           ! from table A1 of Chen 1994
           Bsv=2.17_RP/(M_w*1.0e-3_RP)
           sigma_sv=ag%TV(n)%sig_wa+Bsv*M_w*1.0e-3_RP*molality/(1.0_RP+M_w*1.0e-3_RP*molality)


           sigma_is=abs(sigma_sv-sigma_iv)


           ! effective latent heat of melting
           ! (8.8.12b)  in [erg/g]
           Lmef=(79.7_RP+0.463_RP*Tc)*4.1868e+7_RP

           ! G parameter
           Gn=R_u*ag%TV(n)%T/(M_w*Lmef)

           ! Hvfr parameter (no pressure term)
           Hvfr=2.0*sigma_sv/(den_i*Lmef*rd_h)+Ceps*epsi*epsi/(den_i*Lmef)

           ! critical radius of freezing
           dum1=log(T_0/ag%TV(n)%T)+Gn*log(1.0+sw(n))-Hvfr
           r_cr=2.0_RP*sigma_is/(den_i*Lmef*max(1.0e-30_RP,dum1))
!!!           if( abs(Lmef*(log(T_0/ag%TV(n)%T)+Gn*log(1.0+sw(n))-Hvfr)) < 1.0e-30) then
!!!             ierror_dhf(i,ica,n)=1
!!!           endif
!!!           write(*,*) "ck1-2:",(log(T_0/ag%TV(n)%T)+Gn*log(1.0+sw(n))-Hvfr)

           ! activation energy
           dFact=0.694e-12_RP*(1.0_RP+0.027_RP*(Tc+30.0_RP))
           if(Tc<=-30.0_RP) then
             dFact=dFact*exp(0.01*(Tc+30.0_RP))
           endif

           ! insoluble aerosol radius
           r_d=max(1.0e-7_RP,(mean_mass_ap*(1.0-ga(ica)%MS(1,n)%eps_map)/&
                      ga(ica)%MS(1,n)%den_ai/coef4pi3)**(1.0_RP/3.0_RP))

!org           if(dum1>1.0e-25.and.r_cr>1.0e-10.and.r_n<=max_r_n_DHF.and.idry==0) then
           if(dum1>1.0e-25_RP.and.r_cr>1.0e-10_RP.and.r_n<=max_r_n_DHF.and.idry==0.and.&
              r_d>CRIC_RN_IMM) then

             !
             ! The theta-PDF scheme based on Savre and Ekman (2014)
             !
             ! integration is done with Gauss Quadrature method
             ! geometrical factor under large limit of convex aerosol
             !

             thmid=0.5_RP*(gr%MS(i,n)%th00_cp+thmax)
             do quadrature_loop = 1, 40
               th_gq(quadrature_loop)=0.5*(thmax-gr%MS(i,n)%th00_cp)*x_gq(quadrature_loop)+thmid  ! [deg]
             enddo

             f_gq=0.0_PS
             f_gqN=0.0_PS

             dFcr1=coef4pi3*sigma_is*r_cr*r_cr/(ak*ag%TV(n)%T)
             dFac1=dFact/(ak*ag%TV(n)%T)
             Adhf1=coef_imm*ag%TV(n)%T/(r_cr*r_cr)*sqrt(sigma_is/(ak*ag%TV(n)%T))

             do quadrature_loop = 1, 40
               amis=cos(th_gq(quadrature_loop)*coefpi180)
               ! geometrical factor under large limit of convex aerosol
               fgeo(quadrature_loop)=0.25*(2.0+amis)*(1.0-amis)*(1.0-amis)
               pdf=0.5*((th_gq(quadrature_loop)-ap_mean_cp(ica))/ap_sig_cp(ica))*((th_gq(quadrature_loop)-ap_mean_cp(ica))/ap_sig_cp(ica))
               Adhf=Adhf1*sqrt(fgeo(quadrature_loop))
               J_gq(quadrature_loop)=pi*r_d*r_d*Adhf*exp(-dFac1-dFcr1*fgeo(quadrature_loop))
               fncr(quadrature_loop)=(1.0-exp(-J_gq(quadrature_loop)*ga(ica)%dt))*exp(-pdf)
               f_gq=f_gq+w_gq(quadrature_loop)*fncr(quadrature_loop)
               f_gqN=f_gqN+w_gq(quadrature_loop)*exp(-pdf)
             enddo

             !f_gq=f_gq/(coefsq2p*ap_sig_cp(ica)*cdf_cp_180m0(ica))
             f_gq=f_gq/f_gqN


!org             N_DHF(i,ica,n)=N_act(i,ica,n)*min(1.0,aJfhet*ga(ica)%dt)
             N_DHF(i,ica,n)=N_act(i,ica,n)*f_gq*frac_dust

!org           M_DHF(i,ica,n)=max(gs%binb(1)*1.1_PS,mean_mass_ap+mw)*N_DHF(i,ica,n)
             M_DHF(i,ica,n)=max(gs%binb(1)*1.05_PS,mean_mass_ap*1.05_PS)*N_DHF(i,ica,n)

!org                used_Mi_act(n)=used_Mi_act(n)+&
!org                    max(0.0_PS,cs1_i_depmode(n)*xi,gs%binb(1)*1.1_PS-M_act(i,ica,n)/N_act(i,ica,n))*&
!org                      N_acti_DHF

             ! Hfhet parameter
             Hfhet=sqrt(-16.7551608191456*fgeo(1)*sigma_is*sigma_is*sigma_is/&
                (ak*ag%TV(n)%T*(-alogcnv*(39.0+2.0*log10(r_d)))+dFact))/(den_i*Lmef)  ! J=10^(-11)
!!!              (ak*ag%TV(n)%T*(-alogcnv*(34.0+2.0*log10(r_d)))+dFact))/(den_i*Lmef)  ! J=10^(-6)
!!!!              (ak*ag%TV(n)%T*(-alogcnv*(28.0+2.0*log10(r_d)))+dFact))/(den_i*Lmef)  ! J=1
!!!           Hfhet=0.0_PS   ! ln(J) is -inf as J -> 0.
             ! threshold saturation ratio
!org           Swcr=(ag%TV(n)%T/T_0*exp(Hfhet+Hvfr))**(1.0/Gn)
             Swcr=(ag%TV(n)%T/T_0)**(1.0/Gn)*(1.0+Hfhet/Gn+Hvfr/Gn)

             s_c_dhf(i,ica,n)=Swcr-1.0
             if(Swcr<=1.0+sw(n).and.N_DHF(i,ica,n)>=1.0e-25.and.M_DHF(i,ica,n)>=1.0e-25) then
               noccn(i,ica,n)=2

             endif

!dbg             write(*,'("ck1,dhf:",2I5,7ES15.6)') i,ica,molality,ag%TV(n)%sig_wa,sigma_sv,sigma_iv,sigma_is,r_n,rd_h
!dbg             write(*,'("ck2,dhf:",2I5,8ES15.6)') i,ica,ag%TV(n)%T,Lmef,Hvfr,Gn,r_cr,dFcr,dFact,mw
!dbg             write(*,'("ck3,dhf:",2I5,4ES15.6)') i,ica,r_d,aJfhet,N_dhf(i,ica,n),M_dhf(i,ica,n)
!dbg             write(*,'("ck4,dhf:",2I5,4ES15.6)') i,ica,sw(n),Hfhet,Swcr-1.0,si
!dbg             write(*,'("ck5,dhf:",2I5,5ES15.6)') i,ica,f_gq,dFcr1,dFac1,thmax,ga(ica)%MS(1,n)%th00_cp
!dbg             write(*,'("ck6,dhf:",2I5,8ES15.6)') i,ica,w_gq
!dbg             write(*,'("ck7,dhf:",2I5,8ES15.6)') i,ica,th_gq
!dbg             write(*,'("ck8,dhf:",2I5,8ES15.6)') i,ica,fgeo
!dbg             write(*,'("ck9,dhf:",2I5,8ES15.6)') i,ica,sqrt(fgeo)*Adhf1
!dbg             write(*,'("ck10,dhf:",2I5,8ES15.6)') i,ica,J_gq
!dbg             write(*,'("ck11,dhf:",2I5,8ES15.6)') i,ica,fncr
!dbg             write(*,*) " :"

           endif
         endif

      enddo
      enddo
      enddo

      ! find the minimum critical super saturation
!      do in=1,N_bin_a*ncat_a
!        ica=(in-1)/N_bin_a+1
!        i=in-(ica-1)*N_bin_a
      do ica = 1, ncat_a
      do i = 1, N_bin_a
         do n=1,ag%L
            if(noccn(i,ica,n)==2) then
               s_c_dhfmin(n)=min(s_c_dhfmin(n),s_c_dhf(i,ica,n))
            endif
         enddo
      enddo
      enddo

    endif DHF_IF1
!
!   Deposition nucleation
!
    Dep_IF1: if(iflg_inuc>0.and.iflg_dep==1) then
      ica=2
      if(ga(ica)%MS(1,1)%dis_type==4) then
        ! mono disperse
        i=1
!CDIR NODEP
        do n=1,ag%L
          N_dep(i,n)=0.0_PS
          M_dep(i,n)=0.0_PS

          si=ag%TV(n)%s_v(2)
          Tc=ag%TV(n)%T-T_0

          mean_mass_ap=ga(ica)%MS(i,n)%mean_mass
          if(si>0.0_PS.and.Tc<0.0.and.sw(n)<0.0_PS.and. &
            ga(ica)%MS(1,n)%con>=nlmt.and.ga(ica)%MS(1,n)%mass(1)>=mlmt ) then

            ! surface tension between ice and air
            !   Hoose and Mohler (2012)
            sigma_iv=76.1-0.155*(ag%TV(n)%T-T_0)+28.5+0.25*(ag%TV(n)%T-T_0)

            ! insoluble aerosol radius
            r_d=(mean_mass_ap*(1.0-ga(ica)%MS(1,n)%eps_map)/&
                      ga(ica)%MS(1,n)%den_ai/coef4pi3)**(1.0/3.0)

            !
            ! The theta-PDF scheme based on Savre and Ekman (2014)
            !
            ! integration is done with Gauss Quadrature method
            ! geometrical factor under large limit of convex aerosol
            !
            thmid=0.5*(gr%MS(i,n)%th00_cp+thmax)
            do quadrature_loop = 1, 40
              th_gq(quadrature_loop)=0.5*(thmax-gr%MS(i,n)%th00_cp)*x_gq(quadrature_loop)+thmid  ! [deg]
            enddo

            f_gq=0.0_PS
            f_gqN=0.0_PS

            dGdes=Adep*exp(0.03678*(ag%TV(n)%T-T_0))
            dGg1=coef16pi3*sigma_iv*sigma_iv*sigma_iv/(den_i*R_v*ag%TV(n)%T*log(1.0_PS+ag%TV(n)%s_v(2)))**2
            alogAdep1=2.0*log(r_d)+2.0*log(ag%TV(n)%e)-log(akn*ag%TV(n)%T)+0.5*log(sigma_iv)

            ! condensation coef = 1, and denstity of water molucule in supercooled
            ! region = 1 [g/cm3]
            do quadrature_loop = 1, 40
              amis=cos(th_gq(quadrature_loop)*coefpi180)
              ! geometrical factor under large limit of convex aerosol
              fgeo(quadrature_loop)=0.25*(2.0+amis)*(1.0-amis)*(1.0-amis)
              pdf=0.5*((th_gq(quadrature_loop)-ap_mean_cp(ica))/ap_sig_cp(ica))*((th_gq(quadrature_loop)-ap_mean_cp(ica))/ap_sig_cp(ica))
              alogAdep=alogAdep1-0.5*log(ak*ag%TV(n)%T*fgeo(quadrature_loop))
              dGg=dGg1*fgeo(quadrature_loop)
              fncr(quadrature_loop)=(1.0-exp(-exp(alogAdep+(-dGdes-dGg)/(ak*ag%TV(n)%T))*ga(ica)%dt))*exp(-pdf)
              f_gq=f_gq+w_gq(quadrature_loop)*fncr(quadrature_loop)
              f_gqN=f_gqN+w_gq(quadrature_loop)*exp(-pdf)
            enddo

            !f_gq=f_gq/(coefsq2p*ap_sig_cp(ica)*cdf_cp_180m0(ica))
            f_gq=f_gq/f_gqN

            N_dep(i,n)=ga(ica)%MS(i,n)%con*f_gq
!org            N_dep(i,n)=get_inact_cnt(ag%TV(n)%e,si,ag%TV(n)%T, &
!org              mean_mass_ap,0.0_PS,ga(ica)%MS(i,n)%den_ai,&
!org              Ax,miv,ga(ica)%MS(i,n)%con,ga(ica)%dt)

            M_dep(i,n)=max(gs%binb(1)*1.05_PS,mean_mass_ap*1.05_PS)*N_dep(i,n)

!dbg            write(*,'("ck0,dep:",2I5,6ES15.6)') i,ica,r_d,si,sw(n),exp(alogAdep),N_dep(i,n),M_dep(i,n)
!dbg            write(*,'("ck1,dep:",2I5,5ES15.6)') i,ica,f_gq,dFcr1,thmax,ga(ica)%MS(1,n)%th00_cp,dGdes
!dbg            write(*,'("ck2,dep:",2I5,8ES15.6)') i,ica,w_gq(1:8)
!dbg            write(*,'("ck3,dep:",2I5,8ES15.6)') i,ica,th_gq(1:8)
!dbg            write(*,'("ck4,dep:",2I5,8ES15.6)') i,ica,fgeo(1:8)
!dbg            write(*,'("ck5,dep:",2I5,8ES15.6)') i,ica,fgeo(1:8)*dGg1
!dbg            write(*,'("ck6,dep:",2I5,8ES15.6)') i,ica,fncr(1:8)

            if(N_dep(i,n)<1.0e-25.or.M_dep(i,n)<1.0e-25) then
              N_dep(i,n)=0.0_PS
              M_dep(i,n)=0.0_PS
            endif
          endif

          used_Ma_dep(n)=used_Ma_dep(n)+max(0.0_PS,M_dep(i,n)-mean_mass_ap*N_dep(i,n))

        enddo
      elseif(ga(ica)%MS(1,1)%dis_type==3) then
        ! log normal distribution
      endif
    elseif(iflg_inuc>0.and.iflg_dep==2) then
      ica=2
      i=1
!CDIR NODEP
      do n=1,ag%L
        N_dep(i,n)=0.0_PS
        M_dep(i,n)=0.0_PS

        si=ag%TV(n)%s_v(2)
        Tc=ag%TV(n)%T-T_0

        mean_mass_ap=ga(ica)%MS(i,n)%mean_mass

        if(  ( (Tc<-5.0.and.sw(n)>0.0_PS) .or.&
             ((si >= 0.05_PS).and.(Tc < 0.0 ))) .and. &
          ga(ica)%MS(1,n)%con>=nlmt.and.ga(ica)%MS(1,n)%mass(1)>=mlmt ) then

! <<< 2014/10 T. Hashino modified for sheba
!tmp                     N_dep(i,n)=min(get_inact(si),ga(ica)%MS(1,n)%con)
!tmp                     N_dep(i,n)=min(get_inact_tropic(si,ag%TV(n)%T),ga(ica)%MS(1,n)%con)
!          N_dep(i,n)=max( min(get_inact_tropic(si,ag%TV(n)%T),ga(ica)%MS(1,n)%con)-ni_0(n)&
!                        ,0.0_PS)
          N_dep(i,n)=min(get_inact(si),ga(ica)%MS(1,n)%con)
! >>> 2014/10 T. Hashino modified for sheba

          M_dep(i,n)=max(gs%binb(1)*1.05_PS,mean_mass_ap*1.05_PS)*N_dep(i,n)

          if(N_dep(i,n)<1.0e-25.or.M_dep(i,n)<1.0e-25) then
            N_dep(i,n)=0.0_PS
            M_dep(i,n)=0.0_PS
          endif
        endif

        used_Ma_dep(n)=used_Ma_dep(n)+max(0.0_PS,M_dep(i,n)-mean_mass_ap*N_dep(i,n))

      enddo
    endif dep_IF1
!!!           stop


    ! calculate the number and mass of aerosols activated.
    do ica=1,ncat_a
      do i=1,N_bin_a
        do n=1,ag%L
          if(noccn(i,ica,n)==0) then
            used_Ma_act(n)=used_Ma_act(n)+max(0.0_PS,N_act(i,ica,n)*mean_mass(i,ica,n)-M_act(i,ica,n))
            used_Na_act(n)=used_Na_act(n)+N_act(i,ica,n)
          elseif(noccn(i,ica,n)==2) then
            mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)
            used_Ma_DHF(n)=used_Ma_DHF(n)+max(0.0_PS,M_DHF(i,ica,n)-mean_mass_ap*N_DHF(i,ica,n))
            used_Na_DHF(n)=used_Na_DHF(n)+N_DHF(i,ica,n)
          endif
        enddo
      enddo
    enddo

    do n=1,ag%L

      e_n=ag%TV(n)%P*(ag%TV(n)%rv_sat(1)+used_Ma_act(n)/ag%TV(n)%den)/&
                     (Rdvchiarui+(ag%TV(n)%rv_sat(1)+used_Ma_act(n)/ag%TV(n)%den))
      sw_allact(n)=e_n/ag%TV(n)%e_sat(1)-1.0_PS

      e_n=ag%TV(n)%P*(ag%TV(n)%rv_sat(1)+used_Ma_DHF(n)/ag%TV(n)%den)/&
                     (Rdvchiarui+(ag%TV(n)%rv_sat(1)+used_Ma_DHF(n)/ag%TV(n)%den))
      ds_allDHF(n)=e_n/ag%TV(n)%e_sat(1)-1.0_PS-s_c_dhfmin(n)

      e_n=ag%TV(n)%P*(ag%TV(n)%rv_sat(1)+used_Ma_dep(n)/ag%TV(n)%den)/&
                     (Rdvchiarui+(ag%TV(n)%rv_sat(1)+used_Ma_dep(n)/ag%TV(n)%den))

      dum1=e_n/ag%TV(n)%e_sat(1)-1.0_PS
      e_satw=get_sat_vapor_pres_lk(1,ag%TV(n)%T,ag%estbar,ag%esitbar)
      e_sati=get_sat_vapor_pres_lk(2,min(T_0,ag%TV(n)%T),ag%estbar,ag%esitbar)
      r_e=e_satw/e_sati
      si_alldep(n)=r_e*(dum1+1.0_PS)-1.0_PS

      ! analytical estimates on the DHF limit wrt saturation

!!c      write(*,*) "used_ma_act",n,e_n,sw_allact(n),ag%TV(n)%rv_sat(1),used_ma_act(n),ag%TV(n)%den
!!c      write(*,*) "minimum critical sup for DHF",s_c_dhfmin(n),ds_alldhf(n),used_Ma_dhf(n)

    enddo


    ! set limit on activation based on the exisiting concentration
! <<< 2017/04 T. Hashino modified for SHEBA
    if(flagp_a==-3.or.flagp_a==-2.or.flagp_a==-6.or.flagp_a==-5) then
      do n=1,ag%L
!org        akk_lmt(n)=max(0.0_PS,(used_Na_act(n)-nr_0(n))/max(1.0e-30_PS,used_Na_act(n)))
        akk_lmt(n)=max(0.0_PS,(min(CCNMAX,used_Na_act(n))-nr_0(n))&
                  /max(1.0e-30_PS,used_Na_act(n)))

        akk_lmt_DHF(n)=max(0.0_PS,(min(INMAX,used_Na_DHF(n))-ni_0(n))&
                  /max(1.0e-30_PS,used_Na_DHF(n)))
      enddo
    endif
! >>> 2017/04 T. Hashino for SHEBA

    do n=1,ag%L
      ! +++ calculate T_il from thil +++
      til(n)=thil(n)*(ag%TV(n)%P/p00)**(Racp)

      T_a_r=cal_air_temp(Til(n),qr_0(n),qi_0(n))

!      ierror(n)=0
      if(abs(T_a_r-ag%TV(n)%T)/ag%TV(n)%T>1.0e-5_PS) then
         LOG_ERROR("cal_aptact_var8_kc04dep",'("T is not right",3I5,10ES15.6)') KD(n),ID(n),JD(n),T_a_r,ag%TV(n)%T &
                     ,Til(n), qr_0(n), qi_0(n), ag%TV(n)%P
         call PRC_abort
      endif
    enddo

    !   initialize
    m=0
    do n=1,ag%L
      if(icycle_n(n)==0.and.imethod(n)==0) then
        ! these grids will be considered.
        m=m+1
        mbx(m)=n
        icond1(m)=1
      endif
    enddo
    Lbx=m

    mbx2(1:Lbx)=mbx(1:Lbx)
    Lbx2=Lbx


! +++ Ong Chia Rui comments
! used_mr_vap: change in liq mass (modified by checking whether loss mass > existing mass, final mass < activation critical mass) due to vapor deposition
! used_Ma_act: change in liq mass (modified by checking whether number of activated CCN > limit value, mass transfer from vapor > existing vapor mass) due to activation

! T_a_b: old temperature (n)
! T_a_n: new temperature (n+1)
! b2: indicate even older (n-1) variable, n is current time step

! 1.) based on current temperature and super saturation, calculate the liquid and ice contents resulted from activation and deposition processes
! 2.) then based on conservation of Til and Qt, calculate the new temperature and new vapor content
! 3.) then loop until new temperature and vapor content agree with old temperature and vapor content
! +++

    ! ----------------------------------------------------------
    ! 1. Backward Euler - Til-Qt conservation method
    ! ----------------------------------------------------------
    ! initialize the effective grid numbers, mbx
    !   this will incldue all the grids
    iter1_loop: do iter=1,ITMAX


      ! ++++++++++++++++++++++++++++
      !  calculate mass formed based on the supersaturation and temperature
      call func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                          ,mbx2,Lbx2,sw_b)!,T_a_b

      call func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                          ,noindep,nodhft &
                          ,mbx2,Lbx2,sw_b,T_a_b)
      ! ++++++++++++++++++++++++++++

!!!!CDIR NOVECTOR
!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx2
        n=mbx2(m)

        ! ++++ calculate new mixing ratio of hydrometeors at t^(n+1)++++
        trans_Mi(n)=loss_Mi_mlt(n)-min(liq_left(n),gain_Mi_rim(n)+gain_Mi_frn(n))

        qr(n)=max(0.0_PS,qr_0(n)+&
          (used_Mr_act(n)+used_Mr_vap(n)+trans_Mi(n))/ag%TV(n)%den)
        qi(n)=max(0.0_PS,qi_0(n)+&
          (used_Mi_vap(n)+used_Mi_vapliq(n)+used_Mi_act(n)-trans_Mi(n))/ag%TV(n)%den)

        em(n)=0
        if(qr(n)+qi(n)>=qtp(n)) then
          em(n)=1
!!c            write(*,*) "n,qr,qi",n,em(n),qr(n),qi(n),qtp(n)
        endif
        !
        ! ++++ calculate new air temperature (y_n) at t^(n+1) ++++
        T_a_n(n)=cal_air_temp(Til(n),qr(n),qi(n))
        !
        ! ++++ calculate new supersaturation (x_n) at t^(n+1) ++++
        e_satw=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
        qv_n(n)=max(0.0_PS,qtp(n)-qr(n)-qi(n))
        sw_n(n)=ag%TV(n)%P*qv_n(n)/(Rdvchiarui+qv_n(n))/e_satw-1.0_PS

        e_sati=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
        r_e=e_satw/e_sati
        si_n(n)=r_e*(sw_n(n)+1.0_PS)-1.0_PS
        ! +++++++++++++++++++++++++++++++++++++++++++++++++

!!c          dif=abs(2.0*(sw_n-sw_b)/(sw_n+sw_b))
!!c          dif=abs(2.0*(qv_n-qv)/(qv_n+qv))
!!c          difT=abs(2.0*(T_a_n-T_a_b)/(T_a_n+T_a_b))
!!c          dif=abs((sw_n-sw_b)/sw_b)
        dif=abs((qv_n(n)-qv(n))/qv(n))
        difT=abs((T_a_n(n)-T_a_b(n))/T_a_b(n))

        if(&
           (&
           ( (qi(n)>1.0e-20_PS.and.&
             (qi_b(n)<qi(n).and.qi_b2(n)>qi_b(n).and.T_a_b(n)<T_0)).or.&
             (qr(n)>1.0e-20_PS.and.&
             (qr_b(n)<qr(n).and.qr_b2(n)>qr_b(n)))&
             ).and.iter>=10)   .or.&
             (em(n)>=1) &
               )   then
          ! case of using zbrent method.
          imethod(n)=1
          icond1(m)=0

        elseif(dif<=alim1.and.difT<=alim2) then

          ! convergence OK
          sw_n(n)=sw_b(n)
          T_a_m(n)=T_a_n(n)
          T_a_n(n)=T_a_b(n)

          qv_n(n)=qtp(n)-qr(n)-qi(n)

          imethod(n)=-1
          icond1(m)=0

        else
          sw_b2(n)=sw_b(n)
          T_a_b2=T_a_b(n)

          sw_b(n)=sw_n(n)
          si_b(n)=si_n(n)
          T_a_b(n)=T_a_n(n)
          qv(n)=qv_n(n)

          qr_b2(n)=qr_b(n)
          qi_b2(n)=qi_b(n)
          qr_b(n)=qr(n)
          qi_b(n)=qi(n)

        endif

!!c        write(*,*) "ck backeuler",m,mbx2(m),imethod(n),icond1(m)
      enddo
      if(any(icond1(1:Lbx2)>0)) then
        !   initialize for next iteration
!!c        write(*,*) "ck bfmx",mbx2(1:Lbx2)
        mm=0
!CDIR NOVECTOR
        do m=1,Lbx2
          if(icond1(m)==1) then
            mm=mm+1
            mbx2(mm)=mbx2(m)
            icond1(mm)=1
          endif
        enddo
        Lbx2=mm

!!c        write(*,*) 'ck afmx',mbx2(1:Lbx2)
!!c        write(*,*) 'ck Lbx2:',Lbx2
      else
        Lbx2=0
        exit
      endif
    enddo iter1_loop

    if(Lbx2>0) then
       if (debug) write(*,*) "cal_aptact_var8_vec, back-Euler failed. zbrent is used.",Lbx2
      do m=1,Lbx2
        n=mbx2(m)
        imethod(n)=1
      enddo
    endif
!!c    do n=1,ag%L
!!c      write(*,*) "imethod,em",n,icycle_n(n),imethod(n),em(n)
!!c    enddo

    ! ----------------------------------------------------------
    ! 2. Zbrent method
    ! ----------------------------------------------------------
    !   initialize
    m=0
    do n=1,ag%L
      if(icycle_n(n)==0.and.imethod(n)==1) then
        m=m+1
        mbx(m)=n
      endif
    enddo
    Lbx=m

!CDIR NODEP
!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)

      ! case of both liquid and ice exist.
      !  The minimum possible vapor is the ice saturation if liquid also exhosted.
      T_a_n(n)=ag%TV(n)%T
      T_a_b(n)=ag%TV(n)%T
      T_a_o(n)=ag%TV(n)%T
      sw_n(n)=ag%TV(n)%s_v(1)
      sw_b(n)=ag%TV(n)%s_v(1)
      sw_o(n)=ag%TV(n)%s_v(1)
      qv(n)=ag%TV(n)%rv
!!!        qv_b(n)=ag%TV(n)%rv

      iqvlmt(n)=1


      ! calculate max supersaturation over water in mixed phase
!org        sw_max=(ag%TV(n)%P*(qtp(n)-qi_0)/(0.622+(qtp(n)-qi_0)))/ag%TV(n)%e_sat(1)-1.0
      if(mes_rc(n)==3.and.abs(used_mi_vapliq(n))<1.0e-25_PS.and.T_a_n(n)<T_0) then
        ! This case is ice saturation.
        iphase(n)=2
      else
        iphase(n)=1
      endif
    enddo

    call zbrent_act_vec(sw_n,iphase,1,mbx,Lbx,sw_o,T_a_o,sw_b,T_a_b)

!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)
      qr_b(n)=qr2(n)
      qi_b(n)=qi2(n)
    enddo

    !+++++++++++++++++++++++++++++++++++++++++
    ! oscillation check (only for zbrent grids)
    call func_vec(sw_m,T_a_m,si_m,fret,0,mbx,Lbx,sw_n,T_a_b)

!    do n=1,ag%L
!      ierror1(n)=0
!    enddo

    mm=0
!CDIR NODEP
!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)
      if(abs(fret(n))>0.1) then
        sw_n(n)=ag%TV(n)%s_v(1)
        T_a_b(n)=ag%TV(n)%T
        qr_b(n)=qr_0(n)
        qi_b(n)=qi_0(n)

        if(iphase(n)==1) then
          ! error message set to 1, which is used in the repair
          gr%mark_er(n)=1
          if ( debug ) then
             write(*,*) "qv limit oscillation 1",&
                  KD(n),ID(n),JD(n),n,em(n),iterzi(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                  sw_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qr2(n)
             write(*,*) "used_Mr_act,mr_vap,mi_vap,mi_vapliq,mi_act,lmlt,grm,grf,tmi,lqlft",&
                  used_Mr_act(n),used_Mr_vap(n),&
                  used_Mi_vap(n),used_Mi_vapliq(n),&
                  used_Mi_act(n),loss_Mi_mlt(n),gain_Mi_rim(n),gain_Mi_frn(n),trans_Mi(n),liq_left(n)
             write(*,*) "noccnt,used_Ma_act,used_Na_act,sw_allact", &
                  noccnt(n),used_Ma_act(n),used_Na_act(n),sw_allact(n)
             write(*,*) "akk_lmt",akk_lmt(n)
          end if
        else
           if ( debug ) then
              write(*,*) "qv limit oscillation 2",&
                   KD(n),ID(n),JD(n),n,iterzi(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                   sw_m(n),ag%TV(n)%s_v(2),si_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qi2(n)
           end if
        endif

        mm=mm+1
        mbx2(mm)=n
      endif
    enddo
    Lbx2=mm

    call func_vec(sw_m,T_a_m,si_m,fret,0,mbx2,Lbx2,sw_n,T_a_b)

    if(debug) then

      if(any(sw_m(1:ag%L)>0.10).or.&
         any(sw_b(1:ag%L)>0.10)) then
        do m=1,Lbx
          n=mbx(m)
          if(sw_m(n)>0.10.or.&
             sw_b(n)>0.10) then
              write(*,*) "qv limit done 1_2: k,i,j,em,iter,qv,qr,qi,swo,swb,swn,swm,to,tn,tm,fret,qr2",&
                   KD(n),ID(n),JD(n),em(n),iterzi(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                   sw_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qr2(n)
!!c                      write(*,'("con",3I5,40ES15.6)') KD(n),ID(n),JD(n),(gr%MS(i,n)%con,i=1,gr%N_BIN)
!!c                      write(*,'("coef1",3I5,40ES15.6)') KD(n),ID(n),JD(n),(gr%MS(i,n)%coef(1),i=1,gr%N_BIN)
!!c                      write(*,'("coef2",3I5,40ES15.6)') KD(n),ID(n),JD(n),(gr%MS(i,n)%coef(2),i=1,gr%N_BIN)
!!c                      write(*,'("dm",3I5,40ES15.6)') KD(n),ID(n),JD(n),((gr%MS(i,n)%coef(1)*sw_n+gr%MS(i,n)%coef(2))*gr%dt,i=1,gr%N_BIN)
          endif
        enddo
      endif

      if(any(si_m(1:ag%L)>0.30)) then
        do m=1,Lbx
          n=mbx(m)
          if(si_m(n)>0.30) then
            write(*,*) "qv limit done 2_2: k,i,j,iter,qv,qr,qi,swo,swb,swn,swm,sio,sim,to,tn,tm,fret,qi2",&
                     KD(n),ID(n),JD(n),qv_n(n),qr(n),qi(n),ag%TV(n)%s_v(1),sw_b(n),sw_n(n),&
                     sw_m(n),ag%TV(n)%s_v(2),si_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qi2(n)

          endif
        enddo
      endif
    endif ! debug
    !+++++++++++++++++++++++++++++++++++++++++

    ! check if we need to run zbrent again for water saturation.
    m=0
    do n=1,ag%L
      if(icycle_n(n)==0.and.&
         qr_0(n)>1.0e-10_PS.and.(&
        (iqvlmt(n)==0.and.sw_n(n)>sw_allow).or.(iqvlmt(n)==1.and.sw_m(n)>sw_allow))) then
        ! This is unrealistic high supersaturation
        ! run the water saturation adjustment
        m=m+1
        mbx(m)=n
      endif
    enddo
    Lbx=m

!OCL INDEPENDENT
    do m=1,Lbx
      n=mbx(m)
      iphase(n)=1
      T_a_n(n)=ag%TV(n)%T
      T_a_b(n)=ag%TV(n)%T
      T_a_o(n)=ag%TV(n)%T
      sw_n(n)=sw(n)
      sw_b(n)=sw(n)
      qv(n)=ag%TV(n)%rv
!!!        qv_b(n)=ag%TV(n)%rv

      iqvlmt(n)=2
    enddo
    call zbrent_act_vec(sw_n,iphase,2,mbx,Lbx,sw,T_a_o,sw_b,T_a_b)

    call func_vec(sw_m,T_a_m,si_m,fret,0,mbx,Lbx,sw_n,T_a_b)

    if(debug) then
      do m=1,Lbx
        n=mbx(m)
        write(*,*) "qv limit done 1_3: k,i,j,em,iter,qv,qr,qi,swo,swb,swn,swm,to,tn,tm,fret,qr2",&
                   KD(n),ID(n),JD(n),em(n),iterzi(n),qv_n(n),qr(n),qi(n),sw(n),sw_b(n),sw_n(n),&
                   sw_m(n),ag%TV(n)%T,T_a_n(n),T_a_m(n),fret(n),qr2(n)
      enddo

       do n=1,ag%L
!      ierror1(n)=0
          if((iqvlmt(n)==0.and.sw_n(n)>0.10).or.(iqvlmt(n)==1.and.sw_m(n)>0.10)) then
          write(*,*) "large supersaturation:k,i,j",KD(n),ID(n),JD(n)
          write(*,110) iterzi(n),sw(n), sw_n(n), ag%TV(n)%W, ag%TV(n)%T,T_a_n(n)
110       format("iter,sw,sw_n,W,T,T_a_n",I5,5ES15.6)
          do ica=1,ncat_a
            write(*,*) "k,i,j,ica,noccn", KD(n),ID(n),JD(n),ica,(noccn(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,sc", KD(n),ID(n),JD(n),ica,(s_c(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,m_act", KD(n),ID(n),JD(n),ica,(m_act(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,n_act", KD(n),ID(n),JD(n),ica,(n_act(i,ica,n), i=1,N_bin_a)
            write(*,*) "k,i,j,ica,init m, n", KD(n),ID(n),JD(n),ica &
                                ,ga(ica)%MS(1,n)%mass(amt),ga(ica)%MS(1,n)%con
          enddo
          write(*,*) "iqvlmt,em,sw_b,sw_n,si_b,si_n", &
                      iqvlmt(n),em(n),sw_b(n),sw_n(n),si_b(n),si_n(n)
          write(*,*) "used_Mr_act,mr_vap,mi_vap,mi_vapliq,mi_act,lmlt,grm,grf,tmi,lqlft", &
            used_Mr_act(n),used_Mr_vap(n),&
            used_Mi_vap(n),used_Mi_vapliq(n),&
            used_Mi_act(n),loss_Mi_mlt(n),gain_Mi_rim(n),gain_Mi_frn(n),trans_Mi(n),liq_left(n)
          write(*,*) "noccnt,used_Ma_act,used_Na_act,sw_allact", noccnt(n),used_Ma_act(n),used_Na_act(n),sw_allact(n)
          write(*,*) "akk_lmt", akk_lmt(n)

          write(*,*) "k,i,j,qtp,qv0,qv2,qv3,qr0,qr,qi0,qi", KD(n),ID(n),JD(n),&
               qtp(n),ag%TV(n)%rv,qtp(n)-qr_0(n)-qi_0(n),qtp(n)-qr(n)-qi(n),qr_0(n),qr(n),qi_0(n),qi(n)

          endif
       enddo
    end if ! debug

    if(sum(noccnt(1:ag%L))==ag%L) goto 5555

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! grow the activated droplets to deplete excess water
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization
!    do in=1,mxnbin*ag%L
!      n=(in-1)/mxnbin+1
!      i=in-(n-1)*mxnbin
    do n = 1, ag%L
    do i = 1, mxnbin
      new_N(i,n)=0.0d+0
      new_mtend(i,n)=0.0_PS
    enddo
    enddo
!    do in=1,(mxnbin+1)*ag%L
!      n=(in-1)/(mxnbin+1)+1
!      i=in-(n-1)*(mxnbin+1)
    do n = 1, ag%L
    do i = 1, mxnbin+1
      Np(i,n)=0.0_PS
      Mp(i,n)=0.0_PS
      Npd(i,n)=0.0d+0
      Mpd(i,n)=0.0d+0
      mtend(i,n)=0.0e+0

      icond3(i,n)=0
      icond4(i,n)=0
      error_number(i,n)=0
    enddo
    enddo
!    do ijn=1,mxnbin*(1+mxnmasscomp)*ag%L
!      jn=(ijn-1)/mxnbin+1
!      i=ijn-(jn-1)*mxnbin
!      n=(jn-1)/(1+mxnmasscomp)+1
!      j=jn-(n-1)*(1+mxnmasscomp)
    do j = 1, 1+mxnmasscomp
    do n = 1, ag%L
    do i = 1, mxnbin
      new_M(i,n,j) = 0.0d+0
    enddo
    enddo
    enddo
!    do ijn=1,mxnmasscomp*(mxnbin+1)*ag%L
!      in=(ijn-1)/mxnmasscomp+1
!      j=ijn-(in-1)*mxnmasscomp
!      n=(in-1)/(mxnbin+1)+1
!      i=in-(n-1)*(mxnbin+1)
    do j = 1, mxnmasscomp
    do n = 1, ag%L
    do i = 1, mxnbin+1
      ratio_Mp(i,n,j) = 0.0_PS
    enddo
    enddo
    enddo
!    do ijn=1,mxnbin*mxnnonmc*ag%L
!      in=(ijn-1)/mxnnonmc+1
!      j=ijn-(in-1)*mxnnonmc
!      n=(in-1)/mxnbin+1
!      i=in-(n-1)*mxnbin
    do j = 1, mxnnonmc
    do n = 1, ag%L
    do i = 1, mxnbin
      new_Q(i,n,j) = 0.0d+0
    enddo
    enddo
    enddo


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    category_loop1: do ica=1,ncat_a

      do n=1,ag%L
        ! initialize con and mass of aerosol transports
        ap_dN(n) = 0.0e+0
        ap_dM(n) = 0.0e+0
      enddo

!      do in=1,N_bin_a*ag%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, ag%L
      do i = 1, N_bin_a

!!!        write(*,*) "ica,i,n",ica,i,n,ga(ica)%MS(1,n)den,&
!!!                       ga(ica)%MS(1,n)%p(1:2)
        icond4(i,n)=0

        if(noccn(i,ica,n)==0) then
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! grow the activated droplets using Twomey lower bound estimates
             !                          th_var,phase,alpha,Sd_max,dt,min_dt,r0,m0
!             shifted_bound(1)=get_vapdepact_v2(ag%TV(n),1&
!                  ,sw_n,ga(ica)%dt,r1,shifted_bound(1))
!             shifted_bound(2)=get_vapdepact_v2(ag%TV(n),1&
!                  ,sw_n,ga(ica)%dt,r2,shifted_bound(2))

!             mean_mass_ap=coef4pi3*a_c(i,ica)**3
!             mean_mass=get_vapdepact_v2(ag%TV(n),1,sw_n,ga(ica)%dt,a_c(i,ica),mean_mass_ap)


!             mean_mass_ap=M_act(i,ica)/N_act(i,ica)
!             mean_mass=coef4pi3*den_w*a_h(i,ica)**3

!             mean_mass_ap=coef4pi3*den_w*a_h(i,ica)**3
!             mean_mass=get_vapdepact_v2(ag%TV(n),1,sw_n,ga(ica)%dt,a_h(i,ica),mean_mass_ap)

!             mean_mass=coef4pi3*den_w*a_c(i,ica)**3

!             mean_mass=get_vapdepact_v2(ag%TV(n),1,sw_n,ga(ica)%dt,a_h(i,ica),mean_mass_ap)

          mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)

          dum1=coef4pi3*ga(ica)%MS(1,n)%den*&
                    exp(ga(ica)%MS(1,n)%p(2))*ga(ica)%MS(1,n)%p(1) &
                       *ga(ica)%MS(1,n)%p(1)*ga(ica)%MS(1,n)%p(1)

          binb3d(i,n,1)=dum1*exp(3.0_PS*zn(i))
          binb3d(i,n,2)=dum1*exp(3.0_PS*zn(i+1))

! why why, maybe include consendation growth factor of m^1/3
          binb3d(i,n,1)=binb3d(i,n,1)+&
                (mean_mass(i,ica,n)-mean_mass_ap)*(binb3d(i,n,1)/mean_mass_ap)**(1.0_PS/3.0_PS)
          binb3d(i,n,2)=binb3d(i,n,2)+&
                (mean_mass(i,ica,n)-mean_mass_ap)*(binb3d(i,n,2)/mean_mass_ap)**(1.0_PS/3.0_PS)

!kid             if((iqvlmt==0.and.sw_n>0.10).or.(iqvlmt==1.and.sw_m>0.10)) then
!             if((iqvlmt==0.and.sw_n>0.50).or.(iqvlmt==1.and.sw_m>0.50)) then
!                write(*,*) "k,i,j,ac,p1,p2", KD(n),ID(n),JD(n) &
!                     ,a_c(:,ica),ga(ica)%MS(1,n)%p(1),ga(ica)%MS(1,n)%p(2)
!             endif

          if(sw_allact(n)>1.0e-25_PS) then
! <<< 2014/10 T. Hashino modified for KiD, following Stevens 1996
!tmp                akk=min(1.0_PS,max(0.0_PS,sw_n/sw_allact))
            akk(n)=min(1.0_PS,akk_lmt(n),max(0.0_PS,sw_n(n)/sw_allact(n)))
! >>> 2014/10 T. Hashino modified for KiD, following Stevens 1996
          else
! <<< 2018/02 T. Hashino testing
!org            akk(n)=1.0_PS
            akk(n)=min(1.0_PS,max(0.0_PS,akk_lmt(n)))
! >>> 2018/02 T. Hashino testing
          endif
          Mp(i,n)=N_act(i,ica,n)*akk(n)*mean_mass(i,ica,n)
          Np(i,n)=N_act(i,ica,n)*akk(n)

          icond3(i,n)=1
          if(Np(i,n)<=1.0e-25_PS.or.Mp(i,n)<=1.0e-25_PS) then
            icond3(i,n)=0
            Np(i,n)=0.0_PS
            Mp(i,n)=0.0_PS

            ratio_Mp(i,n,rmat_m)=0.0_PS
            ratio_Mp(i,n,rmas_m)=0.0_PS
            ratio_Mp(i,n,rmai_m)=0.0_PS

          elseif(binb3d(i,n,1)>=mean_mass(i,ica,n).or.mean_mass(i,ica,n)>=binb3d(i,n,2)) then
            icond3(i,n)=0
            icond4(i,n)=1
!!c            write(*,*) "ck addsim0:",i,n,ica,Np(i,n),Mp(i,n),mean_mass(i,ica,n),&
!!c                 binb3d(i,n,1:2)
            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! set up mass ratio
            ratio_Mp(i,n,rmat_m)=M_act(i,ica,n)*akk(n)/Mp(i,n)
            ratio_Mp(i,n,rmas_m)=ga(ica)%MS(1,n)%eps_map*ratio_Mp(i,n,rmat_m)
            ratio_Mp(i,n,rmai_m)=max(0.0_PS,ratio_Mp(i,n,rmat_m)-ratio_Mp(i,n,rmas_m))

          else

            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! set up mass ratio
            ratio_Mp(i,n,rmat_m)=M_act(i,ica,n)*akk(n)/Mp(i,n)
            ratio_Mp(i,n,rmas_m)=ga(ica)%MS(1,n)%eps_map*ratio_Mp(i,n,rmat_m)
            ratio_Mp(i,n,rmai_m)=max(0.0_PS,ratio_Mp(i,n,rmat_m)-ratio_Mp(i,n,rmas_m))

          endif

          Npd(i,n)=Np(i,n)
          Mpd(i,n)=Mp(i,n)
        else
          ! those ignored for transfer_bin
          icond3(i,n)=0
          binb3d(i,n,1)=0.0_PS
          binb3d(i,n,2)=0.0_PS
          Np(i,n)=0.0_PS
          Mp(i,n)=0.0_PS
          Npd(i,n)=0.0d+0
          Mpd(i,n)=0.0d+0
          ratio_Mp(i,n,rmat_m)=0.0_PS
          ratio_Mp(i,n,rmas_m)=0.0_PS
          ratio_Mp(i,n,rmai_m)=0.0_PS
        endif

!!c        write(*,'("ck actINF_p",3I5,2ES15.6)') ica,i,n,Np(i,n),actINF_p(i,n)
      enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      !  case where the mean mass is not constrained.
      call add_simple_vec(N_bin_a,ag%L,icond4,gr,Np,Mp,ratio_Mp,new_N,new_M, &
                          new_Q,Qp)
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of parameters for linear distribution in the shifted bin
      call cal_lincubprms_vec(mxnbin+1,N_bin_a,gr%L,Npd,Mpd,binb3d  &
                         ,a2d,error_number,"cal_apact_1")

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! turn on the error_number flag for neglible concentration and mass
      !  since these do not have the properties diagnosed above.
!      do in=1,N_bin_a*gr%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, gr%L
      do i = 1, N_bin_a
        if(icond3(i,n)==0) then
          error_number(i,n)=10
        endif
      enddo
      enddo

      if(any(error_number(1:N_bin_a,1:gr%L)>=1.and.error_number(1:N_bin_a,1:gr%L)<=4)) then
        do j=1,gr%N_BIN
!          do in=1,N_bin_a*gr%L
!            n=(in-1)/N_bin_a+1
!            i=in-(n-1)*N_bin_a
           do n = 1, gr%L
           do i = 1, N_bin_a
            if(1<=error_number(i,n).and.error_number(i,n)<=4) then
              if(gr%binb(j)<mean_mass(i,ica,n).and.gr%binb(j+1)>mean_mass(i,ica,n)) then
                binb3d(i,n,1)=gr%binb(j)
                binb3d(i,n,2)=gr%binb(j+1)

                a2d_0d(1) = a2d(i,n,1)
                a2d_0d(2) = a2d(i,n,2)
                a2d_0d(3) = a2d(i,n,3)
                a2d_0d(4) = a2d(i,n,4)
                call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                       binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                       error_number(i,n))
              end if
            end if
          end do
          end do
        end do
      endif

!      ierror(1:N_bin_a*gr%L)=0
!      do in=1,N_bin_a*gr%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, gr%L
      do i = 1, N_bin_a
        if(1<=error_number(i,n).and.error_number(i,n)<=4) then
           if ( debug ) then
              write(*,*) "cal_ap_act_var8: Warning: Modified pre-growth linear method also does not work at" &
                   ,i,n
              write(*,*) "       : Ignored con and mass:",Np(i,n),Mp(i,n)
           end if
           error_number(i,n)=10
        endif
      enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculation of transferred concentration and mass into original bins
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      call cal_transbin_vec(gr%token &
                           ,gr%L,gr%N_masscom &
                           ,gr%N_bin,N_bin_a &
                           ,real(gr%binb,PS_KIND) &
                           ,error_number &
                           ,a2d,binb3d,mtend &
                           ,new_N,new_M,new_Q &
                           ,new_mtend &
                           ,ratio_Mp,den_ip_p,axr_p,spx_p &
                           ,habit_p,den_ic_p &
                           ,rag_p,rcg_p,n_exice_p &
                           ,actINF_p &
                           ,0)
      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      do i=1,N_bin_a
        do n=1,gr%L
          if(noccn(i,ica,n)==0) then
!!c            write(*,'("ck np",5I5,10ES15.6)') ica,i,kd(n),noccn(i,ica,n),icond3(i,n) &
!!c                          ,Np(i,n),N_act(i,ica,n),akk(n),mean_mass(i,ica,n)
            sum_ac(n,ica)=sum_ac(n,ica)+Np(i,n)
            sum_am(n,ica)=sum_am(n,ica)+M_act(i,ica,n)*akk(n)
          endif
        enddo
      enddo
      do n=1,gr%L
        sum_ac(n,ica)=sum_ac(n,ica)-ap_dN(n)
        sum_am(n,ica)=sum_am(n,ica)-ap_dM(n)
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate used aerosol tendencies
      do n=1,gr%L
        ga(ica)%MS(1,n)%dcondt(pro_type)=-sum_ac(n,ica)/gr%dt
      enddo
!      do in=1,(1+ga(ica)%N_masscom)*gr%L
!        n=(in-1)/(1+ga(ica)%N_masscom)+1
!        j=in-(n-1)*(1+ga(ica)%N_masscom)
      do n = 1, gr%L
      do j = 1, 1+ga(ica)%N_masscom
        ga(ica)%MS(1,n)%dmassdt(j,pro_type)=-sum_am(n,ica)*&
                     ga(ica)%MS(1,n)%mass(j)/ga(ica)%MS(1,n)%mass(1)/gr%dt
      end do
      end do
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    enddo category_loop1

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the tendency of liquid activated.
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      gr%MS(i,n)%dcondt(pro_type)=new_N(i,n)/gr%dt

      gr%MS(i,n)%dmassdt(rmt,pro_type)=new_M(i,n,rmt)/gr%dt

!      ierror(in)=0
      if( new_N(i,n) < -1.0d+10 .or. new_N(i,n) > 1.0d+10) then
         LOG_ERROR("cal_aptact_var8_kc04dep",*) "Tendency unrealistic", (new_N(j,n),j=1,gr%N_BIN)
         LOG_ERROR_CONT(*) "sw,sw_n",sw(n),sw_n(n)
         LOG_ERROR_CONT(*) "a_c",a_c(1:N_bin_a,1:ncat_a,n)
         !LOG_ERROR_CONT(*) "p(1)",ga(1:ncat_a)%MS(1,n)%p(1) [ Component 'ga' to right of part references with nonzero rank must not have ALLOCATABLE attribute. ]
         !LOG_ERROR_CONT(*) "p(2)",ga(1:ncat_a)%MS(1,n)%p(2) [ Component 'ga' to right of part references with nonzero rank must not have ALLOCATABLE attribute. ]
         LOG_ERROR_CONT(*) "Nact",N_act(1:N_bin_a,1:ncat_a,n)
         LOG_ERROR_CONT(*) "Mact",M_act(1:N_bin_a,1:ncat_a,n)
         ! Ong Chia Rui, delete due to unknown compile error, recovered
         !LOG_ERROR_CONT(*) "con,mass",ga(1:ncat_a)%MS(1,n)%con,ga(1:ncat_a)%MS(1,n)%mass(1)
         LOG_ERROR_CONT(*) KD(n),ID(n),JD(n),i,(new_M(i,n,k),k=1,1+gr%N_masscom)
         call PRC_abort
      endif
      if( new_M(i,n,rmt) < -1.0d+10 .or. new_M(i,n,rmt) > 1.0d+10) then
         call PRC_abort
      endif
    enddo
    enddo

!    do j=2,(1+gr%N_masscom)
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
       do j=2,(1+gr%N_masscom)
        gr%MS(i,n)%dmassdt(j,pro_type)=new_M(i,n,j)/gr%dt

        !ierror(in)=0
        if( new_M(i,n,j) < -1.0e+10_PS .or. new_M(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("cal_aptact_var8_kc04dep",*) "Tendency unrealistic",KD(n),ID(n),JD(n)
           call PRC_abort
        endif
        gr%MS(i,n)%dmassdt(j,pro_type)=&
                 min(abs(gr%MS(i,n)%dmassdt(rmt,pro_type))&
                ,max(-abs(gr%MS(i,n)%dmassdt(rmt,pro_type)),gr%MS(i,n)%dmassdt(j,pro_type)))

      enddo
    enddo
    enddo

    do n=1,gr%L
      do i=1,gr%N_bin
        sum_rc(n)=sum_rc(n)+new_N(i,n)
        sum_rm(n)=sum_rm(n)+new_M(i,n,rmt)-new_M(i,n,rmat)
      enddo
    enddo

    if(debug) then
      do n=1,gr%L
        write(*,*) "var8 ck5555>sw_n,si_n,T_a_n", KD(n),ID(n),JD(n) &
            ,sw_n(n),r_e*(sw_n(n)+1.0_PS)-1.0_PS,T_a_n(n),sum_rc(n),sum_ac(n,1:ncat_a) &
            ,sum_rm(n),sum_am(n,1:ncat_a)
      enddo
    endif

5555 continue

    if(sum(nodhft(1:ag%L))==ag%L) goto 6666

  DHF_IF2: if(iflg_inuc==1.and.iflg_dhf==1) then
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! transfer the DHF frozen particles
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! initialization
!    do in=1,ag%L*ncat_a
!      ica=(in-1)/ag%L+1
!      n=in-(ica-1)*ag%L
    do ica = 1, ncat_a
    do n = 1, ag%L
      sum_ac(n,ica)=0.0_PS
      sum_am(n,ica)=0.0_PS
    enddo
    enddo

    do j=1,gs%N_nonmass
!      do in=1,N_bin_a*ag%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
       do n = 1, ag%L
       do i = 1, N_bin_a
        Qp(i,n,j)=0.0_PS
      enddo
      enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    category_loop2: do ica=1,ncat_a

      ! do not include the deposition freezing aerosols
      if(ica==2) cycle

      ! initialization
!      do in=1,(mxnbin+1)*ag%L
!        n=(in-1)/(mxnbin+1)+1
!        i=in-(n-1)*(mxnbin+1)
      do n = 1, ag%L
      do i = 1, mxnbin+1
        Npd(i,n)=0.0d+0
        Mpd(i,n)=0.0d+0

        icond4(i,n)=0
      enddo
      enddo
!      do ijn=1,mxnmasscomp*(mxnbin+1)*ag%L
!        in=(ijn-1)/mxnmasscomp+1
!        j=ijn-(in-1)*mxnmasscomp
!        n=(in-1)/(mxnbin+1)+1
!        i=in-(n-1)*(mxnbin+1)
      do j = 1, mxnmasscomp
      do n = 1, ag%L
      do i = 1, mxnbin+1
        ratio_Mp(i,n,j) = 0.0_PS
      enddo
      enddo
      enddo

!      do in=1,N_bin_a*ag%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, ag%L
      do i = 1, N_bin_a

        if(noccn(i,ica,n)==2) then
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)

          ! mean mass of frozen particle
          mean_mass_dhf=M_DHF(i,ica,n)/N_DHF(i,ica,n)

          Qp(i,n,iacr)=(mean_mass_dhf/den_i/coef3s)**(1.0_PS/3.0_PS)
          Qp(i,n,iccr)=Qp(i,n,iacr)
          Qp(i,n,ivcs)=coef4pi3*(Qp(i,n,iacr)**2+Qp(i,n,iccr)**2)**1.5_PS

          Qp(i,n,iacr)=Qp(i,n,iacr)**3
          Qp(i,n,iccr)=Qp(i,n,iccr)**3

!try          if(ds_allDHF(n)>1.0e-25_PS.and.used_Ma_DHF(n)>1.0e-25_PS) then
          if(ds_allDHF(n)>1.0e-25_PS) then
!org            akk_DHF(n)=max(0.0_PS,min(1.0_PS,(sw_n(n)-s_c_dhfmin(n))/ds_allDHF(n)))
            akk_DHF(n)=max(0.0_PS,min(1.0_PS,akk_lmt_DHF(n), &
                          (sw_n(n)-s_c_dhfmin(n))/ds_allDHF(n)))
          else
            akk_DHF(n)=0.0_PS
          endif
          if(akk_DHF(n)>1.0e-6) then
            Mpd(i,n)=M_DHF(i,ica,n)*akk_DHF(n)
            Npd(i,n)=N_DHF(i,ica,n)*akk_DHF(n)
          endif

          if(Npd(i,n)>1.0e-25_PS.and.Mpd(i,n)>1.0e-25_PS) then
            icond4(i,n)=1
            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! set up mass ratio
!            ratio_Mp(i,n,imat_m)=mean_mass_ap*Npd(i,n)/Mpd(i,n)
            ratio_Mp(i,n,imat_m)=mean_mass_ap/mean_mass_dhf
            ratio_Mp(i,n,imas_m)=ga(ica)%MS(1,n)%eps_map*ratio_Mp(i,n,imat_m)
            ratio_Mp(i,n,imai_m)=max(0.0_PS,ratio_Mp(i,n,imat_m)-ratio_Mp(i,n,imas_m))
          endif

        endif
      enddo
      enddo

      do i=1,N_bin_a
        ! find the ice bin that contain the am1(n).
        do n=1,ag%L
          icond3(i,n)=1
        enddo
        do j=1,gs%N_BIN
!CDIR NODEP
          do n=1,ag%L
            if(icond4(i,n)==1) then
              mean_mass_DHF=Mpd(i,n)/Npd(i,n)
              if(gs%binb(j)<=mean_mass_DHF.and.mean_mass_DHF<gs%binb(j+1)) then
                icond3(i,n)=j
              endif
            end if
          enddo
        end do

        do n=1,gs%L
          if(noccn(i,ica,n)==2) then
!!c            write(*,'("ck np",5I5,10ES15.6)') ica,i,kd(n),noccn(i,ica,n),icond3(i,n) &
!!c                          ,Np(i,n),N_act(i,ica,n),akk(n),mean_mass(i,ica,n)
            sum_ac(n,ica)=sum_ac(n,ica)+Npd(i,n)
            sum_am(n,ica)=sum_am(n,ica)+Mpd(i,n)
          endif
        enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate used aerosol tendencies
      do n=1,ag%L
        ga(ica)%MS(1,n)%dcondt(pro_type_dhf_aer)=-sum_ac(n,ica)/gs%dt

      enddo
!      do jn=1,(1+ga(ica)%N_masscom)*ag%L
!        n=(jn-1)/(1+ga(ica)%N_masscom)+1
!        j=jn-(n-1)*(1+ga(ica)%N_masscom)
      do n = 1, ag%L
      do j = 1, 1+ga(ica)%N_masscom
        ga(ica)%MS(1,n)%dmassdt(j,pro_type_dhf_aer)=-sum_am(n,ica)*&
                     ga(ica)%MS(1,n)%mass(j)/ga(ica)%MS(1,n)%mass(amt)/gs%dt
      end do
      end do
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!      do in=1,N_bin_a*ag%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
      do n = 1, ag%L
      do i = 1, N_bin_a
        gs%MS(icond3(i,n),n)%dmassdt(imt,pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dmassdt(imt,pro_type_dhf_ice)&
                    +Mpd(i,n)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imc,pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dmassdt(imc,pro_type_dhf_ice)&
                    +Mpd(i,n)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imat,pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dmassdt(imat,pro_type_dhf_ice)&
                    +Mpd(i,n)*ratio_Mp(i,n,imat_m)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imas,pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dmassdt(imas,pro_type_dhf_ice)&
                    +Mpd(i,n)*ratio_Mp(i,n,imas_m)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imai,pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dmassdt(imai,pro_type_dhf_ice)&
                    +Mpd(i,n)*ratio_Mp(i,n,imai_m)/gs%dt


        gs%MS(icond3(i,n),n)%dcondt(pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dcondt(pro_type_dhf_ice)&
                    +Npd(i,n)/gs%dt

!        write(*,*) "ck dmassdt_s",i,n,icond3(i,n),gs%MS(icond3(i,n),n)%dmassdt(imt,pro_type_dhf_ice) &
!                      ,gs%MS(icond3(i,n),n)%dmassdt(imat,pro_type_dhf_ice),ratio_Mp(i,n,imat_m) &
!                      ,gs%MS(icond3(i,n),n)%dcondt(pro_type_dhf_ice)
      enddo
      enddo

!      do j=1,gs%N_nonmass
!        do in=1,N_bin_a*ag%L
!          n=(in-1)/N_bin_a+1
!          i=in-(n-1)*N_bin_a
      do n = 1, ag%L
      do i = 1, N_bin_a
      do j=1,gs%N_nonmass
          gs%MS(icond3(i,n),n)%dvoldt(j,pro_type_dhf_ice)=gs%MS(icond3(i,n),n)%dvoldt(j,pro_type_dhf_ice)&
                          +Npd(i,n)/gs%dt*Qp(i,n,j)
      enddo
      enddo
      enddo

    enddo category_loop2

    do i=1,gs%N_bin
      do n=1,gs%L
        sum_sc(n)=sum_sc(n)+gs%MS(i,n)%dcondt(pro_type_dhf_ice)*gs%dt
        sum_sm(n)=sum_sm(n)+gs%MS(i,n)%dmassdt(imt,pro_type_dhf_ice)*gs%dt
      enddo
    enddo

  endif DHF_IF2

  if(debug) then
    do n=1,gr%L
      write(*,*) "var8 ck6666>sw_n,si_n,T_a_n", KD(n),ID(n),JD(n) &
          ,sw_n(n),r_e*(sw_n(n)+1.0_PS)-1.0_PS,T_a_n(n),sum_sc(n),sum_ac(n,1:ncat_a) &
          ,sum_sm(n),sum_am(n,1:ncat_a)
    enddo
  endif


6666 continue

    if(sum(noindep(1:ag%L))==ag%L) goto 7777

  DEP_IF2: if(iflg_inuc==1.and.iflg_dep>0) then
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! transfer the deposition nucleation particles
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! initialization
!    do in=1,ag%L*ncat_a
!      ica=(in-1)/ag%L+1
!      n=in-(ica-1)*ag%L
     do ica = 1, ncat_a
     do n = 1, ag%L
      sum_ac(n,ica)=0.0_PS
      sum_am(n,ica)=0.0_PS
    enddo
    enddo

    do j=1,gs%N_nonmass
!      do in=1,N_bin_a*ag%L
!        n=(in-1)/N_bin_a+1
!        i=in-(n-1)*N_bin_a
       do n = 1, ag%L
       do i = 1, N_bin_a
        Qp(i,n,j)=0.0_PS
      enddo
      enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! only category 2 is considered for now
    ica=2

!!!    category_loop2: do ica=1,ncat_a


      ! initialization
!      do in=1,(mxnbin+1)*ag%L
!        n=(in-1)/(mxnbin+1)+1
!        i=in-(n-1)*(mxnbin+1)
      do n = 1, ag%L
      do i = 1, mxnbin+1
        Npd(i,n)=0.0d+0
        Mpd(i,n)=0.0d+0

        icond4(i,n)=0
      enddo
      enddo
!      do ijn=1,mxnmasscomp*(mxnbin+1)*ag%L
!        in=(ijn-1)/mxnmasscomp+1
!        j=ijn-(in-1)*mxnmasscomp
!        n=(in-1)/(mxnbin+1)+1
!        i=in-(n-1)*(mxnbin+1)
      do j = 1, mxnmasscomp
      do n = 1, ag%L
      do i = 1, mxnbin+1
        ratio_Mp(i,n,j) = 0.0_PS
      enddo
      enddo
      enddo

      if(ga(ica)%MS(1,1)%dis_type==4) then
        ! monodisperse
        N_bin_dep=1
      else
        N_bin_dep=N_bin_a
      endif


!      do in=1,N_bin_dep*ag%L
!        n=(in-1)/N_bin_dep+1
!        i=in-(n-1)*N_bin_dep
      do n = 1, ag%L
      do i = 1, N_bin_dep

        if(N_dep(i,n)>=1.0e-25) then
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          if(N_bin_dep==1) then
            mean_mass_ap=ga(ica)%MS(i,n)%mean_mass
          else
            mean_mass_ap=M_act(i,ica,n)/N_act(i,ica,n)
          endif

          ! mean mass of frozen particle
          mean_mass_dep=M_dep(i,n)/N_dep(i,n)

          Qp(i,n,iacr)=(mean_mass_dep/den_i/coef3s)**(1.0_PS/3.0_PS)
          Qp(i,n,iccr)=Qp(i,n,iacr)
          Qp(i,n,ivcs)=coef4pi3*(Qp(i,n,iacr)**2+Qp(i,n,iccr)**2)**1.5_PS

          Qp(i,n,iacr)=Qp(i,n,iacr)**3
          Qp(i,n,iccr)=Qp(i,n,iccr)**3

          e_satw=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
          e_sati=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
          r_e=e_satw/e_sati
          si=r_e*(sw_n(n)+1.0_PS)-1.0_PS

          if(si_alldep(n)>1.0e-25_PS) then
            akk_dep=min(1.0_PS,si/si_alldep(n))
          else
            akk_dep=0.0_PS
          endif

          if(akk_dep>1.0e-6) then
            Mpd(i,n)=M_dep(i,n)*akk_dep
            Npd(i,n)=N_dep(i,n)*akk_dep
          endif

          if(Npd(i,n)>1.0e-25_PS.and.Mpd(i,n)>1.0e-25_PS) then
            icond4(i,n)=1
            ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            ! set up mass ratio
!            ratio_Mp(i,n,imat_m)=mean_mass_ap*Npd(i,n)/Mpd(i,n)
            ratio_Mp(i,n,imat_m)=mean_mass_ap/mean_mass_dep
            ratio_Mp(i,n,imas_m)=ga(ica)%MS(1,n)%eps_map*ratio_Mp(i,n,imat_m)
            ratio_Mp(i,n,imai_m)=max(0.0_PS,ratio_Mp(i,n,imat_m)-ratio_Mp(i,n,imas_m))

          endif

        endif
      enddo
      enddo

      do i=1,N_bin_dep
        ! find the ice bin that contain the am1(n).
        do n=1,ag%L
          icond3(i,n)=1
        enddo
        do j=1,gs%N_BIN
!CDIR NODEP
          do n=1,ag%L
            if(icond4(i,n)==1) then
              mean_mass_dep=Mpd(i,n)/Npd(i,n)
              if(gs%binb(j)<=mean_mass_dep.and.mean_mass_dep<gs%binb(j+1)) then
                icond3(i,n)=j
              endif
            end if
          enddo
        end do

        do n=1,gs%L
          if(Npd(i,n)>1.0e-25) then
!!c            write(*,'("ck np",5I5,10ES15.6)') ica,i,kd(n),noccn(i,ica,n),icond3(i,n) &
!!c                          ,Np(i,n),N_act(i,ica,n),akk(n),mean_mass(i,ica,n)
            sum_ac(n,ica)=sum_ac(n,ica)+Npd(i,n)
            sum_am(n,ica)=sum_am(n,ica)+Mpd(i,n)
          endif
        enddo
      enddo

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate used aerosol tendencies
      do n=1,ag%L
        ga(ica)%MS(1,n)%dcondt(pro_type_dep_aer)=-sum_ac(n,ica)/gs%dt

      enddo
!      do jn=1,(1+ga(ica)%N_masscom)*ag%L
!        n=(jn-1)/(1+ga(ica)%N_masscom)+1
!        j=jn-(n-1)*(1+ga(ica)%N_masscom)
      do n = 1, ag%L
      do j = 1, 1+ga(ica)%N_masscom
        ga(ica)%MS(1,n)%dmassdt(j,pro_type_dep_aer)=-sum_am(n,ica)*&
                     ga(ica)%MS(1,n)%mass(j)/ga(ica)%MS(1,n)%mass(amt)/gs%dt
      end do
      end do
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!      do in=1,N_bin_dep*ag%L
!        n=(in-1)/N_bin_dep+1
!        i=in-(n-1)*N_bin_dep
      do n = 1, ag%L
      do i = 1, N_bin_dep
        gs%MS(icond3(i,n),n)%dmassdt(imt,pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dmassdt(imt,pro_type_dep_ice)&
                    +Mpd(i,n)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imc,pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dmassdt(imc,pro_type_dep_ice)&
                    +Mpd(i,n)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imat,pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dmassdt(imat,pro_type_dep_ice)&
                    +Mpd(i,n)*ratio_Mp(i,n,imat_m)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imas,pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dmassdt(imas,pro_type_dep_ice)&
                    +Mpd(i,n)*ratio_Mp(i,n,imas_m)/gs%dt
        gs%MS(icond3(i,n),n)%dmassdt(imai,pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dmassdt(imai,pro_type_dep_ice)&
                    +Mpd(i,n)*ratio_Mp(i,n,imai_m)/gs%dt


        gs%MS(icond3(i,n),n)%dcondt(pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dcondt(pro_type_dep_ice)&
                    +Npd(i,n)/gs%dt

!        write(*,*) "ck dmassdt_s",i,n,icond3(i,n),gs%MS(icond3(i,n),n)%dmassdt(imt,pro_type_dep_ice) &
!                      ,gs%MS(icond3(i,n),n)%dmassdt(imat,pro_type_dep_ice),ratio_Mp(i,n,imat_m) &
!                      ,gs%MS(icond3(i,n),n)%dcondt(pro_type_dep_ice)
      enddo
      enddo

!        do in=1,N_bin_dep*ag%L
!          n=(in-1)/N_bin_dep+1
!          i=in-(n-1)*N_bin_dep
      do n = 1, ag%L
      do i = 1, N_bin_dep
      do j=1,gs%N_nonmass
          gs%MS(icond3(i,n),n)%dvoldt(j,pro_type_dep_ice)=gs%MS(icond3(i,n),n)%dvoldt(j,pro_type_dep_ice)&
                          +Npd(i,n)/gs%dt*Qp(i,n,j)
      enddo
      enddo
      enddo

!!!    enddo category_loop2

    do i=1,gs%N_bin
      do n=1,gs%L
        sum_sc_dep(n)=sum_sc_dep(n)+gs%MS(i,n)%dcondt(pro_type_dep_ice)*gs%dt
        sum_sm_dep(n)=sum_sm_dep(n)+gs%MS(i,n)%dmassdt(imt,pro_type_dep_ice)*gs%dt
      enddo
    enddo

  endif DEP_IF2

  if(debug) then
    do n=1,gr%L
      write(*,*) "var8 ck7777>sw_n,si_n,T_a_n", KD(n),ID(n),JD(n) &
          ,sw_n(n),r_e*(sw_n(n)+1.0_PS)-1.0_PS,T_a_n(n),sum_sc_dep(n),sum_ac(n,1:ncat_a) &
          ,sum_sm_dep(n),sum_am(n,1:ncat_a)
    enddo
  endif


7777 continue

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! finalize it by updatting thermo variables
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    do n=1,gr%L
      if(icycle_n(n)==0) then
        ag%TV(n)%e_sat_n(1)=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
        ag%TV(n)%e_sat_n(2)=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
        r_e= ag%TV(n)%e_sat_n(1)/ag%TV(n)%e_sat_n(2)
        ag%TV(n)%T_n=T_a_n(n)
        ag%TV(n)%T_m=T_a_m(n)

        ! +++ update the steady state saturation +++
        ag%TV(n)%s_v_n(1)=sw_n(n)
        ag%TV(n)%s_v_n(2)=r_e*(sw_n(n)+1.0_PS)-1.0_PS

!        ierror(n)=0
        if((iqvlmt(n)==0.and.sw_n(n)>0.10).or.(iqvlmt(n)==1.and.sw_m(n)>0.10).or.&
          debug) then
          ag%TV(n)%e_sat_n(1)=get_sat_vapor_pres_lk(1,T_a_n(n),ag%estbar,ag%esitbar)
          ag%TV(n)%e_sat_n(2)=get_sat_vapor_pres_lk(2,min(T_0,T_a_n(n)),ag%estbar,ag%esitbar)
          r_e= ag%TV(n)%e_sat_n(1)/ag%TV(n)%e_sat_n(2)
          if (debug) write(*,*) "var8,final>sw_n,si_n,T_a_n", KD(n),ID(n),JD(n) &
               ,sw_n(n),r_e*(sw_n(n)+1.0_PS)-1.0_PS,T_a_n(n),sum_rc(n),sum_ac(n,1:ncat_a) &
               ,sum_rm(n),sum_am(n,1:ncat_a)
        endif
      endif
    enddo

!!!    stop
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!$    ! start deallocating pointers
!!$    deallocate(binb3d)
!!$    deallocate(a2d)
!!$    deallocate(new_N)
!!$    deallocate(new_M)
!!$    deallocate(new_Q)
!!$    deallocate(Np,Npd)
!!$    deallocate(Mp,Mpd)
!!$    deallocate(ratio_Mp)
!!$    deallocate(Qp)
!!$    deallocate(new_mtend)
!!$    deallocate(mtend)
!!$    deallocate(axr_p)
!!$    deallocate(den_ip_p,den_ic_p)
!!$    deallocate(habit_p)
!!$    deallocate(asr_p)
!!$    deallocate(type_p)
!!$    deallocate(actINF_p)
!!$    deallocate(rag_p,rcg_p)
!!$    deallocate(n_exice_p)
!!$    deallocate(ap_dN,ap_dM)
!!$    deallocate(sw,sw_n,sw_b,sw_b2,si_n,si_b,sw_m,si_m,sw_o)
!!$    deallocate(cs1_i_depmode)
!!$    deallocate(zn)
!!$    deallocate(noccn)
!!$    deallocate(noindep,noccnt,nodhft)
!!$    deallocate(s_c,a_c)
!!$    deallocate(M_act,N_act,mean_mass)
!!$    deallocate(sw_allact)
!!$    deallocate(akk_lmt,akk_lmt_DHF,akk,akk_DHF)
!!$    deallocate(gain_Mi_frn,gain_Mi_rim)
!!$    deallocate(used_Ma_act,used_Na_act)
!!$    deallocate(used_Mr_act,used_Mr_vap, used_Mi_act,used_Mi_vap, &
!!$             used_Mi_vapliq,loss_Mi_mlt,trans_Mi,liq_left, &
!!$             ice_left)
!!$    deallocate(used_Ma_DHF,used_Na_DHF)
!!$    deallocate(phase2)
!!$    deallocate(TS_A1,TS_B11,TS_B12,TS_B13,TS_D1)
!!$    deallocate(Tmax)
!!$    deallocate(E_L01)
!!$    deallocate(T_a_n,T_a_b,T_a_m,T_a_o)
!!$    deallocate(qr_0,qi_0,nr_0,ni_0)
!!$    deallocate(qr,qi,qv,qv_n,qr_b,qi_b,qr_b2,qi_b2,qr2,qi2)
!!$    deallocate(iqvlmt)
!!$    deallocate(imethod)
!!$    deallocate(mbx,mbx2)
!!$    deallocate(icond1,ierror1)
!!$    deallocate(icond3,icond4)
!!$    deallocate(iphase)
!!$    deallocate(error_number)
!!$    deallocate(til)
!!$    deallocate(sum_ac,sum_am)
!!$    deallocate(sum_rc,sum_rm)
!!$    deallocate(sum_sc,sum_sm)
!!$    deallocate(M_DHF,N_DHF)
!!$    deallocate(s_c_dhf)
!!$    deallocate(s_c_dhfmin,ds_allDHF)
!!$    deallocate(M_dep,N_dep)
!!$    deallocate(used_Ma_dep)
!!$    deallocate(si_alldep)
!!$    deallocate(sum_sc_dep,sum_sm_dep)
!!$    deallocate(icycle_n)
!!$    deallocate(ierror)
!!$    ! end of deallocation of pointers


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    return

!end subroutine cal_aptact_var8_kc04dep
  contains

    subroutine cal_coef_svsteady_init(g,n,a)
      ! +++++++++++++++++++++++++++++++++++++++++++++++++
      ! this coefficient is given per perticle
      type (Group)        :: g
      integer :: n!,i
      real(PS) :: a

      a=g%MS(1,n)%coef(1)*g%dt
    end subroutine cal_coef_svsteady_init

    function cal_air_temp(Til,qr,qi) result(T)
      real(PS),intent(in) :: Til,qr,qi
      real(PS) :: T
!!c      integer :: i_y_gt253

!!c      i_y_gt253=0.5*(1.0-sign(1.0,253.0_PS-T))
!!c      T=Til*(1.0_PS+(L_e*qr+L_s*qi)/(c_pa*253.0_PS))
!!c      T=(1.0-real(i_y_gt253))*T+&
!!c               real(i_y_gt253)*&
!!c          0.5*(Til+sqrt(Til**2+4.0_PS*Til/c_pa*(L_e*qr+L_s*qi)))

      T=Til*(1.0_PS+(L_e*qr+L_s*qi)/(c_pa*253.0_PS))
      if(T>253.0_PS) then
         T=0.5*(Til+sqrt(Til**2+4.0_PS*Til/c_pa*(L_e*qr+L_s*qi)))
      endif
    end function cal_air_temp

    subroutine func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                          ,mbx,Lbx,x)
      ! -------------------------------------------------------------
      !   calculate formed and left mass of liquid due to
      !    activation and depositional growth
      ! -------------------------------------------------------------
      integer,intent(in) :: Lbx
      integer,intent(in),dimension(*) :: mbx
      real(PS),dimension(*),intent(in) :: x!,y
      real(PS),dimension(*),intent(inout) :: used_mr_vap,used_Mr_act,liq_left
      integer,dimension(*),intent(inout) :: noccnt

      real(PS) :: d_mean_mass
      integer :: m,n

      do m=1,Lbx
        n=mbx(m)

        used_Mr_vap(n)=0.0_PS
        used_Mr_act(n)=0.0_PS
        liq_left(n)=0.0_PS
        noccnt(n)=1
      enddo

      if(flagp_r>0) then

!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx
          n=mbx(m)

          if(x(n)>0.0_PS.and.sw(n)>0.0_PS.and.used_Ma_act(n)>1.0e-25_PS) then
            if(sw_allact(n)>1.0e-25_PS) then

! <<< 2014/10 T. Hashino modified for KiD, following Stevens 1996
!tmp               akk=min(1.0_PS,x/sw_allact)    ! original
              akk(n)=min(1.0_PS,akk_lmt(n),x(n)/sw_allact(n))
! >>> 2014/10 T. Hashino modified for KiD, following Stevens 1996
            else
! <<< 2018/02 T. Hashino testing
!org              akk(n)=1.0_PS
              akk(n)=min(1.0_PS,max(0.0_PS,akk_lmt(n)))
! >>> 2018/02 T. Hashino testing
            endif

            used_Mr_act(n)=used_Mr_act(n)+akk(n)*used_Ma_act(n)
            noccnt(n)=0
          endif
        enddo
!!c         evr=0.0_PS
        do j=1,gr%N_BIN
!CDIR NODEP
!OCL INDEPENDENT
          do m=1,Lbx
            n=mbx(m)
            if((mes_rc(n)==2.or.mes_rc(n)==4).and.&
               gr%MS(j,n)%con>=nlmt.and.gr%MS(j,n)%mass(rmt)>=mlmt ) then

!!$                  d_mean_mass=gr%MS(j,n)%coef(1)*x(n)*gr%dt

              d_mean_mass=(gr%MS(j,n)%coef(1)*x(n)+gr%MS(j,n)%coef(2))*gr%dt
!!c               d_mean_mass=(gr%MS(j,n)%coef(1)*x(n)+gr%MS(j,n)%coef(2)/y(n)+gr%MS(j,n)%coef(3))*gr%dt

              if(d_mean_mass*gr%MS(j,n)%con&
                    <=gr%MS(j,n)%mass(rmat)-gr%MS(j,n)%mass(rmt)) then
                  ! evaporated
                used_Mr_vap(n)=used_Mr_vap(n)-(gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat))

!!c                     write(*,'("bin 1",I5,5ES15.6)') &
!!c                          j,gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat),gr%MS(j,n)%coef(1)
                liq_left(n)=liq_left(n)+0.0_PS

              elseif(d_mean_mass<0.0_PS.and.&
                    (gr%MS(j,n)%r_act>&
                  coef3i4p1i3*((gr%MS(j,n)%mean_mass+d_mean_mass)/gr%MS(j,n)%den)**(1.0/3.0)&
                  )) then
                ! transfer to haze particles
                used_Mr_vap(n)=used_Mr_vap(n)-(gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat))
!!c                     write(*,'("bin 3",I5,5ES15.6)') &
!!c                          j,gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat),gr%MS(j,n)%coef(1) &
!!c                          ,(-gr%MS(j,n)%coef(2)/y(n)-gr%MS(j,n)%coef(3))/gr%MS(j,n)%coef(1) &
!!c                          ,gr%MS(j,n)%r_act,gr%MS(j,n)%a_len
                liq_left(n)=liq_left(n)+0.0_PS

              else
                used_Mr_vap(n)=used_Mr_vap(n)+d_mean_mass*gr%MS(j,n)%con
!!c                     write(*,'("bin 2",I5,5Es15.6)') &
!!c                          j,d_mean_mass,d_mean_mass*gr%MS(j,n)%con,gr%MS(j,n)%coef(1)

!!c                     liq_left=liq_left+gr%MS(j,n)%mass(rmt)+d_mean_mass*gr%MS(j,n)%con
                liq_left(n)=liq_left(n)+gr%MS(j,n)%mass(rmt)-gr%MS(j,n)%mass(rmat)+d_mean_mass*gr%MS(j,n)%con
              end if
            endif
          enddo
        enddo
      endif

    end subroutine func_liqvap_vec

    subroutine func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                          ,noindep,nodhft &
                          ,mbx,Lbx,x,y)
      use class_Thermo_Var, only: &
         get_sat_vapor_pres_lk
      use class_Ice_Shape, only: &
         get_vip, &
         cal_semiac_ip
      ! -------------------------------------------------------------
      !   calculate formed and left mass of ice due to
      !    activation and depositional growth, and others
      ! -------------------------------------------------------------
      integer,intent(in) :: Lbx
      integer,dimension(*),intent(in) :: mbx
      real(PS),dimension(*),intent(in) :: x,y
      real(PS),dimension(*),intent(inout) :: used_Mi_vap,used_Mi_vapliq,used_Mi_act &
              ,loss_Mi_mlt,ice_left
      integer,dimension(*),intent(inout) :: noindep,nodhft
      !
      real(PS) :: xi,xw,tmp,tmp_bf,d_mean_mass,m_w,m_icore,m_w_c,&
             v_cs_p,semi_aip_p,semi_cip_p,v_w,v_ip,v_space,m_shed,&
             dm_w,mass_ap,dia_icore,q
      real(PS) :: x0,x1,x2,gx0,gx1,gx2,dT_w
      real(8) :: TS_B1,TS_D2,w0,w1,w2 &
              ,aL,bL,dL
      real(PS) :: flg1
      !integer :: emts,i_phase_eq1
      integer :: m,n



!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)

        used_Mi_vap(n)=0.0_PS
        used_Mi_vapliq(n)=0.0_PS
        used_Mi_act(n)=0.0_PS
        loss_Mi_mlt(n)=0.0_PS
        ice_left(n)=0.0_PS
        noindep(n)=1
        nodhft(n)=1
      enddo

!!c      if(flagp_s>0.and.(si_b/=xi.or.sw_b/=x2)) then
      if(flagp_s>0) then
!!c         ice_left=1.0e+3_PS
         bin_loop1: do j=1,gs%N_BIN
!CDIR NODEP
!OCL INDEPENDENT
           do m=1,Lbx
             n=mbx(m)
             if((mes_rc(n)==3.or.mes_rc(n)==4).and.&
               gs%MS(j,n)%con>=nlmt.and.gs%MS(j,n)%mass(1)>=mlmt ) then

               e_satw=get_sat_vapor_pres_lk(1,y(n),ag%estbar,ag%esitbar)
               e_sati=get_sat_vapor_pres_lk(2,min(T_0,y(n)),ag%estbar,ag%esitbar)
               r_e=e_satw/e_sati

               xi=r_e*(x(n)+1.0_PS)-1.0_PS
               xw=x(n)


!               i_phase_eq1=max(0.0_RP,(-isign(1,phase2(j,n)-1)*max(0,phase2(j,n)-1)+1.0_RP))*&
!                           max(0.0_RP,(-isign(1,phase2(j,n)-1)*min(0,phase2(j,n)-1)+1.0_RP))
               if(T_0>ag%TV(n)%T.and.T_0>y(n)) then
                 if(phase2(j,n)==1) then
                    TS_B1=TS_B11(j,n)*e_satw/y(n) * (xw + 1.0_PS) + &
                          TS_B12(j,n)+TS_B13(j,n)*y(n)
                 else
                    TS_B1=TS_B11(j,n)*e_sati/y(n) * (xi + 1.0_PS) + &
                          TS_B12(j,n)+TS_B13(j,n)*y(n)
                 endif
!                 TS_B1=real(i_phase_eq1)*(TS_B11(j,n)*e_satw/y(n) * (xw + 1.0_PS) + &
!                         TS_B12(j,n)+TS_B13(j,n)*y(n)) +&
!                       real(1-i_phase_eq1)*(TS_B11(j,n)*e_sati/y(n) * (xi + 1.0_PS) + &
!                         TS_B12(j,n)+TS_B13(j,n)*y(n))
!
                 ! locally fit a parabora using Lagrange polynomial
                 ! the fit equation is
                 !   g(x)=esi(Tsfc)/Tsfc
                 ! fit the polynomical
                 !  First trial
                 dT_w=20.0
                 x2=min(Tmax(j,n),gs%MS(j,n)%tmp+dT_w)
                 x1=x2-dT_w
                 x0=x1-dT_w
                 gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                 gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                 gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                 w0=gx0/((x0-x1)*(x0-x2))
                 w1=gx1/((x1-x0)*(x1-x2))
                 w2=gx2/((x2-x0)*(x2-x1))
                 aL=w0+w1+w2
                 bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                 dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                 tmp_bf=gs%MS(j,n)%tmp

                 TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                               4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                 if(TS_D2>=0.0d+0) then
                   tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                       sqrt(TS_D2)  )/ &
                       (2.0*TS_D1(j,n)*aL)
                 else
                   tmp=tmp_bf
                 endif

                 tmp=min(tmp,Tmax(j,n))

                 !  second trial
                 tmp_bf=tmp
                 dT_w=10.0
                 x2=min(Tmax(j,n),tmp+dT_w)
                 x1=x2-dT_w
                 x0=x1-dT_w
                 gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                 gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                 gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                 w0=gx0/((x0-x1)*(x0-x2))
                 w1=gx1/((x1-x0)*(x1-x2))
                 w2=gx2/((x2-x0)*(x2-x1))
                 aL=w0+w1+w2
                 bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                 dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                 TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                               4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                 if(TS_D2>=0.0d+0) then
                   tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                       sqrt(TS_D2)  )/ &
                       (2.0*TS_D1(j,n)*aL)
                 else
                   tmp=tmp_bf
                 endif

                 tmp=min(tmp,Tmax(j,n))
                 if(abs(tmp-tmp_bf)/tmp_bf>1.0e-4) then
                   !  third trial
                   tmp_bf=tmp
                   dT_w=5.0
                   x2=min(Tmax(j,n),tmp+dT_w)
                   x1=x2-dT_w
                   x0=x1-dT_w
                   gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                   gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                   gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                   w0=gx0/((x0-x1)*(x0-x2))
                   w1=gx1/((x1-x0)*(x1-x2))
                   w2=gx2/((x2-x0)*(x2-x1))
                   aL=w0+w1+w2
                   bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                   dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                   TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                                 4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                   if(TS_D2>=0.0d+0) then
                     tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                         sqrt(TS_D2)  )/ &
                         (2.0*TS_D1(j,n)*aL)
                   else
                     tmp=tmp_bf
                   endif

                   tmp=min(tmp,Tmax(j,n))
                 endif
                 if(abs(tmp-tmp_bf)/tmp_bf>1.0e-4) then
                   !  fourth trial
                   tmp_bf=tmp
                   dT_w=1.0
                   x2=min(Tmax(j,n),tmp+dT_w)
                   x1=x2-dT_w
                   x0=x1-dT_w
                   gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                   gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                   gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                   w0=gx0/((x0-x1)*(x0-x2))
                   w1=gx1/((x1-x0)*(x1-x2))
                   w2=gx2/((x2-x0)*(x2-x1))
                   aL=w0+w1+w2
                   bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                   dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                   TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                                 4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                   if(TS_D2>=0.0d+0) then
                     tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                         sqrt(TS_D2)  )/ &
                         (2.0*TS_D1(j,n)*aL)
                   else
                     tmp=tmp_bf
                   endif

                   tmp=min(tmp,Tmax(j,n))
                 endif
                 if(abs(tmp-tmp_bf)/tmp_bf>1.0e-4) then
                   !  fifth trial
                   tmp_bf=tmp
                   dT_w=0.5
                   x2=min(Tmax(j,n),tmp+dT_w)
                   x1=x2-dT_w
                   x0=x1-dT_w
                   gx0=get_sat_vapor_pres_lk(phase2(j,n),x0,ag%estbar,ag%esitbar)/x0
                   gx1=get_sat_vapor_pres_lk(phase2(j,n),x1,ag%estbar,ag%esitbar)/x1
                   gx2=get_sat_vapor_pres_lk(phase2(j,n),x2,ag%estbar,ag%esitbar)/x2

                   w0=gx0/((x0-x1)*(x0-x2))
                   w1=gx1/((x1-x0)*(x1-x2))
                   w2=gx2/((x2-x0)*(x2-x1))
                   aL=w0+w1+w2
                   bL=-w0*(x1+x2)-w1*(x0+x2)-w2*(x0+x1)
                   dL=w0*x1*x2+w1*x0*x2+w2*x0*x1

                   TS_D2=(TS_D1(j,n)*bL+TS_A1(j,n))*(TS_D1(j,n)*bL+TS_A1(j,n))-&
                                 4.0*TS_D1(j,n)*aL*(TS_D1(j,n)*dL-TS_B1)

                   if(TS_D2>=0.0d+0) then
                     tmp=(-(TS_D1(j,n)*bL+TS_A1(j,n))+&
                         sqrt(TS_D2)  )/ &
                         (2.0*TS_D1(j,n)*aL)
                   else
                     tmp=tmp_bf
                   endif
                   tmp=min(tmp,Tmax(j,n))

                 endif
               else
                 tmp=T_0
               end if

               if(phase2(j,n)==2) then

                 d_mean_mass=(gs%MS(j,n)%coef(1)*e_sati/y(n)*(xi+1.0_PS)+&
                       gs%MS(j,n)%coef(2)*get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)/&
                       tmp)*gs%dt


                 if((gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))/gs%MS(j,n)%con+d_mean_mass&
                       <=0.0_PS) then
                     ! evaporated
!!c                  evi(j)=1.0_PS
                   used_Mi_vap(n)=used_Mi_vap(n)-(gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))

                   ice_left(n)=0.0_PS
!!c                     ice_left=min(ice_left,0.0_PS)
                 else
                   used_Mi_vap(n)=used_Mi_vap(n)+d_mean_mass*gs%MS(j,n)%con

!!c                     ice_left=gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con
                   ice_left(n)=gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat)+d_mean_mass*gs%MS(j,n)%con
!!c                     ice_left=min(ice_left,gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con)
                 end if
!!c                 write(*,*) "used_mi_vap",xi,y(n),used_mi_vap(n),d_mean_mass,gs%MS(j,n)%con

                 if(tmp==T_0) then
                   ! +++ melting +++
                   m_w=(&
                        L_s*(gs%MS(j,n)%coef(1)*e_sati/y(n)*(xi+1.0_PS)+&
                        gs%MS(j,n)%coef(2)*&
                        get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)&
                        /tmp)+&
                        (L_f+C_w*(y(n)-tmp))*gs%MS(j,n)%Ldmassdt(2)&
                        -E_L01(j,n)*(tmp-y(n))&
                        )*gs%dt/L_f
                 else
                   m_w=0.0_PS
                 endif

               else
                 d_mean_mass=(gs%MS(j,n)%coef(1)*e_satw/y(n)*(xw+1.0_PS)+&
                       gs%MS(j,n)%coef(2)*get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)/&
                       tmp)*gs%dt


                 if((gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))/gs%MS(j,n)%con+d_mean_mass&
                       <=0.0_PS) then
                     ! evaporated
                   used_Mi_vapliq(n)=used_Mi_vapliq(n)-(gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))

                   ice_left(n)=0.0_PS
!!c                     ice_left=min(ice_left,0.0_PS)
                 else
                   used_Mi_vapliq(n)=used_Mi_vapliq(n)+d_mean_mass*gs%MS(j,n)%con

!!c                     ice_left=gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con
                   ice_left(n)=gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat)+d_mean_mass*gs%MS(j,n)%con
!!c                     ice_left=min(ice_left,gs%MS(j,n)%mass(1)+d_mean_mass*gs%MS(j,n)%con)
                 end if

                 if(T_0<=ag%TV(n)%T) then
                   ! +++ melting +++
                   m_w=max(0.0_PS,(&
                        L_e*(gs%MS(j,n)%coef(1)*e_satw/y(n)*(x(n)+1.0_PS)+&
                        gs%MS(j,n)%coef(2)*&
                        get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)&
                        /tmp)+&
                        c_w*(y(n)-tmp)*gs%MS(j,n)%Ldmassdt(2)&
                        -E_L01(j,n)*(tmp-y(n))&
                        )*gs%dt/L_f)
                 else
                   if(tmp==T_0) then
                     m_w=(&
                           L_e*(gs%MS(j,n)%coef(1)*e_satw/y(n)*(x(n)+1.0_PS)+&
                           gs%MS(j,n)%coef(2)*&
                           get_sat_vapor_pres_lk(phase2(j,n),tmp,ag%estbar,ag%esitbar)&
                           /tmp)+&
                           (L_f+c_w*(y(n)-tmp))*gs%MS(j,n)%Ldmassdt(2)&
                           -E_L01(j,n)*(tmp-y(n))&
                           )*gs%dt/L_f
                   else
                     m_w=0.0_PS
                   endif
                 endif
               endif


               ! +++ melting process tendency +++
               if(level<=3) then
                 mass_ap=0.0_PS
               else
                 mass_ap=gs%MS(j,n)%mass(imat)/gs%MS(j,n)%con
               end if
               dm_w=m_w
               m_w=gs%MS(j,n)%mass(imw)/gs%MS(j,n)%con+m_w

               if((level<=5.and.m_w>0.0_PS).or.&
                  (level>=6.and.m_w>0.0_PS.and.&
                     (gs%MS(j,n)%mass(imw)/gs%MS(j,n)%con>1.0e-12_PS.or.&
                      dm_w/=0.0_PS))) then

                 if(gs%MS(j,n)%mean_mass-mass_ap<=m_w) then
                   ! whole ice melt
!!c                        loss_Mi_mlt=loss_Mi_mlt+max(0.0_PS,min(ice_left,gs%MS(j,n)%mass(1)))
                   loss_Mi_mlt(n)=loss_Mi_mlt(n)+max(0.0_PS,min(ice_left(n),&
                                 gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat)))
!!c                        loss_Mi_mlt=loss_Mi_mlt+gs%MS(j,n)%mass(1)
!!c                     if(ice_left(n)<0.0) then
!!c                       write(*,*) "icelft neg",j,ice_left(n),gs%MS(j,n)%mass(1)
!!c                     endif
                 else

                   m_icore=gs%MS(j,n)%mean_mass-m_w
                   m_w_c=0.268_PS+0.1389_PS*m_icore

                   V_cs_p=m_icore/gs%IS(j,n)%den_ip
                   call cal_semiac_ip(gs%IS(j,n)%is_mod(2),gs%IS(j,n)%phi_cs,&
                                        V_cs_p,semi_aip_p,semi_cip_p)

                   dia_icore=2.0_PS*max(semi_aip_p,semi_cip_p)
                   V_w = m_w/den_w
                   V_ip=get_vip(gs%IS(j,n)%is_mod(2),gs%IS(j,n)%phi_cs,semi_aip_p)
                   V_space=max(0.0_PS,V_ip-m_icore/den_i)

                   q=max(dia_icore-0.9_PS,0.0_PS)
                   q = 1.0_PS+10.67_PS*q-&
                       10.81_PS*q*q+&
                       10.26_PS*q*q*q

                   if(V_space<V_w.and.dia_icore>=0.9_PS.and.m_w>=m_w_c) then
                     m_shed=m_w-gs%MS(j,n)%mean_mass/q
                   elseif(V_space<V_w.and.dia_icore<0.9_PS.and.m_w>rm_frg1) then
                     m_shed=rm_frg1
                   else
                     m_shed=0.0_PS
                   endif
                   loss_Mi_mlt(n)=loss_Mi_mlt(n)+max(0.0_ps,min(ice_left(n),&
                         m_shed*gs%MS(j,n)%con*&
                         (gs%MS(j,n)%mass(1)-gs%MS(j,n)%mass(imat))/gs%MS(j,n)%mass(1)))
                 endif

               endif
             endif
           enddo
         enddo bin_loop1

!
!    Deposition freezing nucleation
!
         if(iflg_inuc>0.and.iflg_dep>0) then
           if(iflg_dep==1) then
             ! classical nucleation theory
             flg1=x(n)
           else
             ! Meyer's secheme
             flg1=-1.0
           endif
!CDIR NODEP
!OCL INDEPENDENT
           do m=1,Lbx
             n=mbx(m)

             e_satw=get_sat_vapor_pres_lk(1,y(n),ag%estbar,ag%esitbar)
             e_sati=get_sat_vapor_pres_lk(2,min(T_0,y(n)),ag%estbar,ag%esitbar)
             r_e=e_satw/e_sati

             xi=r_e*(x(n)+1.0_PS)-1.0_PS
!!!             xw=x(n)

             if(( xi>0.0_PS.and.y(n) < T_0.and.flg1<0.0_PS) .and. &
                ( ga(2)%MS(1,n)%con>=nlmt.and.ga(2)%MS(1,n)%mass(1)>=mlmt )) then

               if(si_alldep(n)>1.0e-25_PS) then

                 akk_dep=min(1.0_PS,xi/si_alldep(n))
               else
                 akk_dep=0.0_PS
               endif

               used_Mi_act(n)=used_Mi_act(n)+akk_dep*used_Ma_dep(n)

               noindep(n)=0
             end if
           enddo
         endif
!
!    Deliquescence-heterogeneous freezing
!
         if(iflg_inuc>0.and.iflg_dhf>0) then
!CDIR NODEP
!OCL INDEPENDENT
           do m=1,Lbx
             n=mbx(m)

!org             e_satw=get_sat_vapor_pres_lk(1,y(n),ag%estbar,ag%esitbar)
!org             e_sati=get_sat_vapor_pres_lk(2,min(T_0,y(n)),ag%estbar,ag%esitbar)
!org             r_e=e_satw/e_sati

!org             xi=r_e*(x(n)+1.0_PS)-1.0_PS
!org             if(xi>0.0_PS.and.used_Ma_DHF(n)>1.0e-25_PS) then
!try             if(x(n)>s_c_dhfmin(n).and.used_Ma_DHF(n)>1.0e-25_PS) then
             if(x(n)>s_c_dhfmin(n)) then
               if(ds_allDHF(n)>1.0e-25_PS) then
!org                 akk_DHF(n)=max(0.0_PS,min(1.0_PS,(x(n)-s_c_dhfmin(n))/ds_allDHF(n)))
                 akk_DHF(n)=max(0.0_PS,min(1.0_PS,akk_lmt_DHF(n),&
                               (x(n)-s_c_dhfmin(n))/ds_allDHF(n)))
               else
                 akk_DHF(n)=0.0_PS
               endif

               if(akk_DHF(n)>1.0e-6) then
                 used_Mi_act(n)=used_Mi_act(n)+akk_DHF(n)*used_Ma_DHF(n)
                 nodhft(n)=0
               endif
             endif
           enddo
         endif
      endif


    end subroutine func_icevap_vec

    subroutine zbrent_act_vec(sw_n,iphase,iswitch,mbx,Lbx,sw_o,T_a_o,sw_b,T_a)
      use class_Thermo_Var, only: &
         get_sat_vapor_pres_lk
      integer,intent(in) :: iswitch
      integer,dimension(*),intent(in) :: iphase
      integer,intent(in) :: Lbx
      integer,dimension(*),intent(in) :: mbx
      real(PS),dimension(*),intent(in) :: sw_o,T_a_o
      real(PS),dimension(*),intent(in) :: sw_b,T_a
      real(PS),dimension(*),intent(inout) :: sw_n

      integer,dimension(LMAX) :: icond2
!      integer, pointer, dimension(:) :: icond2
      integer :: Lbx2
      integer,dimension(LMAX) :: mbx2
!      integer, pointer, dimension(:) :: mbx2
      REAL(PS) :: tol=1.0e-6
      real(PS) :: eps
      PARAMETER (EPS=3.0e-8)
      !  Using Brent's method, find the root of a function func known to lie between x1 and x2.
      !  The root, returned as zbrent, will be refined until its accuracy is tol.

      !  Parameters: Maximum allowed number of iterations, and machine floating-point precision.
      REAL(PS),dimension(LMAX) :: a,b,c,d,e,fa,fb,fc
!      REAL(PS), pointer, dimension(:) :: a,b,c,d,e,fa,fb,fc
      REAL(PS) :: p,q,r,s,tol1,xm
      real(PS),dimension(LMAX) :: dum1,dum2,dum3
!      real(PS), pointer, dimension(:) :: dum1,dum2,dum3
      integer,parameter :: nb_it=20

      integer :: itr,m,mm,n
      integer,parameter :: ITMAX_ini=30
      integer,parameter :: ITMAX=50

      integer :: ierror1(ag%L)


      if (Lbx == 0) return ! CHIARUI DEBUG
      ! initialize the bounds
!!$      ! start initializing pointers
!!$      allocate(icond2(LMAX),mbx2(LMAX))
!!$      allocate(a(LMAX),b(LMAX),c(LMAX),d(LMAX),e(LMAX),fa(LMAX),fb(LMAX),fc(LMAX))
!!$      allocate(dum1(LMAX),dum2(LMAX),dum3(LMAX))
!!$      ! end of initialization of pointers

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)

        if(iphase(n)==1) then
          b(n)=-0.5_PS
          a(n)=0.2_PS

        elseif(iphase(n)==2) then
          e_satw=get_sat_vapor_pres_lk(1,T_a_o(n),ag%estbar,ag%esitbar)
          e_sati=get_sat_vapor_pres_lk(2,min(T_0,T_a_o(n)),ag%estbar,ag%esitbar)
          r_e=e_satw/e_sati

          ! super saturation over ice is -0.5
          b(n)=(-0.5_PS+1.0_PS)/r_e-1.0_PS

          a(n)=0.2_PS

        endif
      enddo

      do m=1,Lbx
        icond2(m)=1
        mbx2(m)=mbx(m)
      enddo
      Lbx2=Lbx

      do n=1,ag%L
        iterz(n)=0
        iterzi(n)=0
        ierror1(n)=0
      enddo

      do itr=1,ITMAX_ini

        call func_vec(dum1,dum2,dum3,fa,iswitch,mbx2,Lbx2,a,T_a)
        call func_vec(dum1,dum2,dum3,fb,iswitch,mbx2,Lbx2,b,T_a)

!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx2
          n=mbx2(m)

          if(fa(n).lt.0.0_PS.and.fb(n).lt.0.0_PS) then
            if(iswitch==2) then
               a(n)=a(n)*2.0_PS
            else
               a(n)=a(n)+0.2_PS
            endif

            if(a(n)>1.0e+4) then
              ierror1(n)=1
              icond2(m)=0
            endif
          elseif(fa(n).gt.0.0_PS.and.fb(n).gt.0.0_PS) then

            b(n)=b(n)-0.2_PS

            if(b(n)<-2.0e+0) then
              ierror1(n)=2
              icond2(m)=0
            endif
          else
            icond2(m)=0
          end if
        enddo
        if(any(icond2(1:Lbx2)>0)) then
          iterzi(n)=iterzi(n)+1

          ! initialize for next iteration
          mm=0
!CDIR NOVECTOR
          do m=1,Lbx2
            if(icond2(m)==1) then
              mm=mm+1
              mbx2(mm)=mbx2(m)
              icond2(mm)=1
            endif
          enddo
          Lbx2=mm
        else
          Lbx2=0
          exit
        endif
      enddo

      do m=1,Lbx2
        n=mbx2(m)
        ierror1(n)=3
      enddo

      if(any(ierror1(1:ag%L)>0)) then
        do m=1,Lbx
          n=mbx(m)
          if(ierror1(n)>0) then
             qv_max=ag%TV(n)%rv+qr_0(n)+qi_0(n)

             if ( debug ) then
                write(*,*) "initialization for zbrent failed",ierror1(n),iphase(n),iswitch
                write(*,*) "n,iter,em,sw,sw_n,a,b,fa,fb", &
                     KD(n),ID(n),JD(n),iterzi(n),em(n),sw_b(n),sw_n(n),a(n),b(n),fa(n),fb(n)
                write(*,*) "W,a_c,N_act,M_act,T,r_e",ag%TV(n)%W, a_c, N_act,M_act, ag%TV(n)%T,r_e
                write(*,*) "sv1,sv2,qv_max,rvsat1", ag%TV(n)%s_v(1),ag%TV(n)%s_v(2),qv_max,&
                     ag%TV(n)%rv_sat(1)
                write(*,*) "k,i,j,used_Mr_vap,used_Mr_act,used_Mi_vap+vapliq,used_Mi_act,used_Mi_vapliq", &
                     KD(n),ID(n),JD(n),used_Mr_vap(n),used_Mr_act(n),(used_Mi_vap(n)+used_Mi_vapliq(n)),used_Mi_act(n),used_Mi_vapliq(n)

                do i=1,gr%N_BIN
                   write(*,'(I5,4ES15.6)') i,gr%MS(i,n)%con,gr%MS(i,n)%mass(rmt),gr%MS(i,n)%coef(1),gr%MS(i,n)%coef(2)
                end do
                do i=1,gs%N_BIN
                   write(*,'(I5,4ES15.6)') i,gs%MS(i,n)%con,gs%MS(i,n)%mass(imt),gs%MS(i,n)%coef(1),gs%MS(i,n)%coef(2)
                end do
             end if

             sw_n(n)=sw_o(n)
          endif
        enddo
      endif

      ! start the zbrent algorithm
      do m=1,Lbx
        icond2(m)=1
        mbx2(m)=mbx(m)
      enddo
      Lbx2=Lbx

      do m=1,Lbx
        n=mbx(m)
        c(n)=b(n)
        fc(n)=fb(n)
      enddo

!!c      write(*,*) "bf iter",c(1),fc(1)
      do itr=1,ITMAX


!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx2
          n=mbx2(m)

          if((fb(n).gt.0.0_PS.and.fc(n).gt.0.0_PS).or.(fb(n).lt.0.0_PS.and.fc(n).lt.0.0_PS))then
            c(n)=a(n) ! Rename a, b, c and adjust bounding interval d.
            fc(n)=fa(n)
            d(n)=b(n)-a(n)
            e(n)=d(n)
          endif
          if(abs(fc(n)).lt.abs(fb(n))) then
            a(n)=b(n)
            b(n)=c(n)
            c(n)=a(n)
            fa(n)=fb(n)
            fb(n)=fc(n)
            fc(n)=fa(n)
          endif
          tol1=2.0_PS*EPS*abs(b(n))+0.5_PS*tol ! Convergence check.
          xm=0.5_PS*(c(n)-b(n))
          if(abs(xm).le.tol1 .or. fb(n).eq.0.)then
            sw_n(n)=b(n)
            icond2(m)=0
          else
            if(abs(e(n)).ge.tol1 .and. abs(fa(n)).gt.abs(fb(n))) then
              s=fb(n)/fa(n) ! Attempt inverse quadratic interpolation.
              if(a(n).eq.c(n)) then
                p=2.0_PS*xm*s
                q=1.0_PS-s
              else
                q=fa(n)/fc(n)
                r=fb(n)/fc(n)
                p=s*(2.*xm*q*(q-r)-(b(n)-a(n))*(r-1.0_PS))
                q=(q-1.0_PS)*(r-1.0_PS)*(s-1.0_PS)
              endif
              if(p.gt.0.) q=-q ! Check whether in bounds.
              p=abs(p)
              if(2.0_PS*p .lt. min(3.0_PS*xm*q-abs(tol1*q),abs(e(n)*q))) then
                e(n)=d(n) ! Accept interpolation.
                d(n)=p/q
              else
                d(n)=xm ! Interpolation failed, use bisection.
                e(n)=d(n)
              endif
            else ! Bounds decreasing too slowly, use bisection.
              d(n)=xm
              e(n)=d(n)
            endif
            a(n)=b(n) ! Move last best guess to a.
            fa(n)=fb(n)
            if(abs(d(n)) .gt. tol1) then ! Evaluate new trial root.
              b(n)=b(n)+d(n)
            else
              b(n)=b(n)+sign(tol1,xm)
            endif

            iterz(n)=iterz(n)+1
            sw_n(n)=b(n)

!!c              write(*,*) "zbrent ck",a(n),b(n),c(n),d(n),e(n),fa(n),fb(n),fc(n)
          endif
        enddo
        if(any(icond2(1:Lbx2)>0)) then
          call func_vec(dum1,dum2,dum3,fb,iswitch,mbx2,Lbx2,b,T_a)
!!c          write(*,*) "zbrent ck2:",b(1),T_a(1),fb(1)

          ! initialize for next iteration
          mm=0
!CDIR NOVECTOR
          do m=1,Lbx2
            if(icond2(m)==1) then
              mm=mm+1
              mbx2(mm)=mbx2(m)
              icond2(mm)=1
            endif
          enddo
          Lbx2=mm

        else
          Lbx2=0
          exit
        endif
      enddo

      if ( debug ) then
         do m=1,Lbx2
            n=mbx2(m)
            write(*,'("brent exceeding maximum iterations. n,sw,sw_n,a,b,fa,fb",2I5,12ES15.6)') &
                 n,sw_b(n),sw_n(n),a(n),b(n),fa(n),fb(n)
            write(*,'("W,a_c,N_act,M_act,T,r_e",10ES15.6)') ag%TV(n)%W, a_c, N_act,M_act, ag%TV(n)%T
         enddo
      end if

!!$      ! start deallocating pointers
!!$      deallocate(icond2,mbx2)
!!$      deallocate(a,b,c,d,e,fa,fb,fc)
!!$      deallocate(dum1,dum2,dum3)
!!$      ! end of deallocation of pointers

     end subroutine zbrent_act_vec

     subroutine func_vec(x_n,y_n,xi_n,  fa,iswitch,mbx,Lbx,x,y)
      use class_Thermo_Var, only: &
         get_sat_vapor_pres_lk
      ! x: supersaturation over water at current time
      ! y: temperature at current time
      ! x_n: x at next time
      ! y_n: y at next time
      real(PS),dimension(*),intent(in) :: x,y
      real(PS),dimension(*),intent(inout) :: x_n,xi_n,y_n,fa
      integer,intent(in) :: iswitch
      integer,intent(in) :: Lbx
      integer,dimension(*),intent(in) :: mbx

      if (Lbx == 0) return ! CHIARUI DEBUG

      call func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                          ,mbx,Lbx,   x)

      call func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                          ,noindep,nodhft &
                          ,mbx,Lbx,   x,y)

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)

        ! ++++ calculate new mixing ratio of hydrometeors ++++
        trans_Mi(n)=loss_Mi_mlt(n)-min(liq_left(n),gain_Mi_rim(n)+gain_Mi_frn(n))

        qr(n)=max(0.0_PS,qr_0(n)+&
            (used_Mr_act(n)+used_Mr_vap(n)+trans_Mi(n))/ag%TV(n)%den)
        qi(n)=max(0.0_PS,qi_0(n)+&
            (used_Mi_vap(n)+used_Mi_vapliq(n)+used_Mi_act(n)-trans_Mi(n))/ag%TV(n)%den)

        if(qr(n)+qi(n)>=qtp(n)) then
          em(n)=iswitch+10
        else
          em(n)=0
        endif
      enddo

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)
        !
        ! ++++ calculate new air temperature (y_n) at t^(n+1) ++++
        y_n(n)=cal_air_temp(Til(n),qr(n),qi(n))
        !
      enddo

!CDIR NODEP
!OCL INDEPENDENT
      do m=1,Lbx
        n=mbx(m)
        ! ++++ calculate new supersaturation (x_n) at t^(n+1) ++++
        e_satw=get_sat_vapor_pres_lk(1,y_n(n),ag%estbar,ag%esitbar)
        qv_n(n)=max(0.0_PS,qtp(n)-qr(n)-qi(n))
        x_n(n)=ag%TV(n)%P*qv_n(n)/(Rdvchiarui+qv_n(n))/e_satw-1.0_PS

        e_sati=get_sat_vapor_pres_lk(2,min(T_0,y_n(n)),ag%estbar,ag%esitbar)
        r_e=e_satw/e_sati
        xi_n(n)=r_e*(x_n(n)+1.0_PS)-1.0_PS
        ! +++++++++++++++++++++++++++++++++++++++++++++++++

      enddo

      select case(iswitch)
      case(1)
        call func_liqvap_vec(used_Mr_vap,used_Mr_act,liq_left,noccnt &
                            ,mbx,Lbx,   x_n)

        call func_icevap_vec(used_Mi_vap,used_Mi_vapliq,used_Mi_act,loss_Mi_mlt,ice_left &
                            ,noindep,nodhft &
                            ,mbx,Lbx,   x_n,y_n)

!CDIR NODEP
!OCL INDEPENDENT
        do m=1,Lbx
          n=mbx(m)

          trans_Mi(n)=loss_Mi_mlt(n)-min(liq_left(n),gain_Mi_rim(n)+gain_Mi_frn(n))
          qr2(n)=max(0.0_PS,qr_0(n)+&
                (used_Mr_act(n)+used_Mr_vap(n)+trans_Mi(n))/ag%TV(n)%den)

          qi2(n)=max(0.0_PS,qi_0(n)+&
                (used_Mi_vap(n)+used_Mi_vapliq(n)+used_Mi_act(n)-trans_Mi(n))/ag%TV(n)%den)

          fa(n)=(qr(n)+qi(n)-qr2(n)-qi2(n))/max(1.0e-9_RP,ag%TV(n)%rv)

!!c            write(*,*) "fa check",trans_Mi(n),qr2(n),qi2(n),fa(n), &
!!c                used_Mr_act(n),used_Mr_vap(n),trans_Mi(n), &
!!c                used_Mi_vap(n),used_Mi_vapliq(n),used_Mi_act(n),trans_Mi(n),&
!!c                qr(n),qi(n)

        enddo
      case(2)
        do m=1,Lbx
          n=mbx(m)
          fa(n)=-x_n(n)+sw_allow
        enddo
      case(0)
        do m=1,Lbx
          n=mbx(m)
          fa(n)=(qr(n)+qi(n)-qr_b(n)-qi_b(n))/max(1.0e-9_RP,ag%TV(n)%rv)
        enddo
      case default

      end select
     end subroutine func_vec
  end subroutine cal_aptact_var8_kc04dep

  subroutine mv_ice2liq(gs,gr,ga,ag,mes_rc)
  use mod_amps_utility, only: cal_lincubprms_vec, &
                              cal_linprms_vec_s, &
                              cal_transbin_vec
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Move ice bins that have too much melt liquid on it to liquid bins.
    !
    ! This has to be called in order to keep diagnosed density of dry ice particle
    ! finite. Other way is to reduce melt mass component, so that mean_mass-m_mlt
    ! stays non-zero.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! rain group
    type (Group), intent(inout)   :: gr
    ! aerosol group
    type (Group), dimension(*)  :: ga
    ! thermo variable object
    type (AirGroup), intent(in)  :: ag

    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc

    ! level of complexity
    !integer, intent(in)           :: level
    ! grid box number
    integer            :: n

    real(PS), dimension(mxnbin+1,gs%L,2)           :: binb3d

    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,gs%L,1+mxnmasscomp)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,gs%L,mxnnonmc)          :: new_Q

    ! index array to remember bins with nonzero con or mass
!tmp    integer, pointer,  dimension(:)            :: index_bin

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,gs%L,mxnmasscomp)      :: ratio_Mp

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
    real(PS), dimension(mxnbin+1,gs%L,mxnnonmc+2)             :: Qp

    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,gs%L,mxnaxis-1) :: axr_p
    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
    ! aspect ratio of ice particle
    !real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
    ! type in shifted bin
    !integer, dimension(mxnbin+1,LMAX)          :: type_p

    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,gs%L,4)           :: a2d

    ! concentration and mass to be moved into aerosol groups
    !   soluble (1) or insoluble (2) categories
    real(8),dimension(LMAX,2)            :: ap_dN, ap_dM
    !    soluble mass and activated IN
    real(8),dimension(LMAX,2)            :: ap_dMS, ap_dNI, ap_dMV
    ! indication of evaporation due to the mass less than the boundary
    !   the value corresonds to the aerosol category that
    !   particles were transfered due to evaporation
    integer,dimension(mxnbin,LMAX) :: inevp

    integer,dimension(mxnbin+1,LMAX)             :: error_number

    integer,dimension(LMAX) :: icycle_n
    integer,dimension(mxnbin+1,LMAX) :: icond3,icond4,melt
!    integer,dimension((mxnbin+1)*LMAX) :: ierror

    ! flag to transfer aerosol particles in ice to dry aerosol particles
    integer :: iaer_src

    !integer :: em
    integer :: i,j,icat
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!tmp    call allocate_mvice2liq
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization

    new_N(:,:)=0.0d+0
    new_mtend(:,:)=0.0d+0

    mtend(:,:)=0.0_PS

    do n = 1, gs%L
    do i = 1, gs%N_bin
      binb3d(i,n,1)=gs%binb(i)
      binb3d(i,n,2)=gs%binb(i+1)
    enddo
    enddo

    inevp(:,:)=0

    new_M(:,:,:) = 0.0d+0

    new_Q(:,:,:) = 0.0d+0

    ratio_Mp(:,:,:) = 0.0_PS

    ! initialize con and mass of aerosol transports
    if(gs%binb(1)>=gr%binb(1)) then
      iaer_src=0
    else
      iaer_src=1
      ap_dN(:,:) = 0.0d+0
      ap_dM(:,:) = 0.0d+0
      ap_dMS(:,:) = 0.0d+0
      ap_dNI(:,:) = 0.0d+0
      ap_dMV(:,:) = 0.0d+0
    endif

    do n=1,gs%L
      if(( mes_rc(n) == 0 ).or.&
         ( gs%mark_cm(n) == 3 )) then
        icycle_n(n)=1
      else
        icycle_n(n)=0
      endif
    enddo

    melt(:,:)=0

    icond4(:,:)=0

    do n = 1, gs%L
    do i = 1, gs%N_bin
      ! +++ check of positive ness +++
      icond3(i,n)=0
! <<< 2015/03 T. Hashino modified for KiD
      if( icycle_n(n)==0.and.&
          ( gs%MS(i,n)%inmlt==2.or.&
            (ag%TV(n)%T-273.16>5.0_PS.and.gs%IS(i,n)%sh_type<=4)).and.&
          ( gs%MS(i,n)%con > 1.0e-30_PS .and. &
            gs%MS(i,n)%mass(imt) > 1.0e-30_PS) ) then
!org          if(gs%MS(i,n)%inmlt==2) then
! >>> 2015/03 T. Hashino modified for KiD
        icond3(i,n)=1
      end if
    enddo
    enddo

!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin

      if(icond3(i,n)==1) then

        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! total concentration in the shifted bin
        Npd(i,n)=real(gs%MS(i,n)%con,8)
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! total mass in the shifted bin
        Mpd(i,n)=real(gs%MS(i,n)%mass(imt),8)
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        Np(i,n)=Npd(i,n)
        Mp(i,n)=Mpd(i,n)

        melt(i,n)=1
!!c             write(*,'("melt mv working for :",2I5,10ES15.6)') i,gs%MS(i,n)%inmlt,gs%MS(i,n)%con,gs%MS(i,n)%mass
        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! set up mass ratio
        ! assume that frozen drops are ice crystals.
        ratio_Mp(i,n,rmat_m)=gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(imt)
        ratio_Mp(i,n,rmas_m)=gs%MS(i,n)%mass(imas)/gs%MS(i,n)%mass(imt)

      else

        Npd(i,n)=0.0d+0
        Mpd(i,n)=0.0d+0

        Np(i,n)=Npd(i,n)
        Mp(i,n)=Mpd(i,n)

      end if
    enddo
    enddo

!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin
      melt(1,n)=melt(1,n)+melt(i,n)
    enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of parameters for linear distribution in the shifted bin
    call cal_lincubprms_vec(mxnbin+1,gs%N_BIN,gs%L,Npd,Mpd,binb3d  &
                         ,a2d,error_number,"mv_ice2liq_0")

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin
      if(icond3(i,n)==1.and.error_number(i,n)>0) then
        error_number(i,n)=10
        icond4(i,n)=1

        if ( debug ) then
           write(fid_alog,'("mv_ice2liq> cal_linear_prm failed, so just put it",2I5)') &
                i,n
        end if
      endif
    enddo
    enddo

    if(sum(melt(1,1:gs%L))>0) then
      call add_simple_vec(gs%N_bin,gs%L,icond4,gr,Np,Mp,ratio_Mp &
                         ,new_N,new_M,new_Q,Qp)
    endif
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of transferred concentration and mass into original bins
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_transbin_vec(gr%token &
                         ,gr%L,gr%N_masscom &
                         ,gr%N_bin,gs%N_bin &
                         ,real(gr%binb,PS_KIND) &
                         ,error_number &
                         ,a2d,binb3d,mtend &
                         ,new_N,new_M,new_Q &
                         ,new_mtend &
                         ,ratio_Mp,den_ip_p,axr_p,spx_p &
                         ,habit_p,den_ic_p &
                         ,rag_p,rcg_p,n_exice_p &
                         ,actINF_p &
                         ,iaer_src,ap_dN,ap_dM,ap_dMS,ap_dNI,ap_dMV,inevp)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Update the ice spectrum
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin

      if(icond3(i,n)==1) then
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! set con and mass to 0
        gs%MS(i,n)%con=0.0_PS
        gs%MS(i,n)%mass=0.0_PS
        gs%IS(i,n)%V_cs=0.0_PS
        gs%MS(i,n)%a_len=0.0_PS
        gs%MS(i,n)%c_len=0.0_PS
        gs%IS(i,n)%d=0.0_PS
        gs%IS(i,n)%ag=0.0_PS
        gs%IS(i,n)%cg=0.0_PS
        gs%IS(i,n)%n_exice=0.0_PS

        gs%MS(i,n)%coef=0.0_PS
        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      end if
    end do
    end do



    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! update the liquid spectrum
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! change mark_cm to indicate there are liquid hydrometeors.
!CDIR NODEP
    do n=1,gr%L
      if(melt(1,n)>0) then
        gr%mark_cm(n)=0
      endif
    enddo

!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(melt(1,n)>0) then
        gr%MS(i,n)%con=gr%MS(i,n)%con+new_N(i,n)
      endif
    end do
    end do

!    do j=1,gr%N_masscom
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
       if(melt(1,n)>0) then
          do j=1,gr%N_masscom
             gr%MS(i,n)%mass(j)=gr%MS(i,n)%mass(j)+new_M(i,n,j)
          enddo
       endif
    end do
    end do

!    do j=1,gr%N_nonmass
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
       if(melt(1,n)>0) then
          ! right now, only activated IN concentration
          do j=1,gr%N_nonmass
             gr%MS(i,n)%vol(j)=gr%MS(i,n)%vol(j)+new_Q(i,n,j)
          end do
       endif
    enddo
    enddo

!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
!      ierror(in)=0
      if(melt(1,n)>0.and.gr%MS(i,n)%con>1.0e-30_PS) then
        if(gr%MS(i,n)%mass(rmt)/gr%MS(i,n)%con<gr%binb(i)) then
           if(debug) write(fid_alog,'("mvice2liq>out of mass bound 1:",2I5,10ES15.6)') i,n,&
                             gr%MS(i,n)%mass(rmt),gr%MS(i,n)%con,&
                             gr%MS(i,n)%mass(rmt)/gr%MS(i,n)%con,gr%binb(i)
          gr%MS(i,n)%con=gr%MS(i,n)%mass(rmt)/(gr%binb(i)*1.1_PS)
        elseif(gr%MS(i,n)%mass(rmt)/gr%MS(i,n)%con>gr%binb(i+1)) then
           if(debug) write(fid_alog,'("mvice2liq>out of mass bound 2:",2I5,10ES15.6)') i,n,&
                           gr%MS(i,n)%mass(rmt),gr%MS(i,n)%con,&
                           gr%MS(i,n)%mass(rmt)/gr%MS(i,n)%con,gr%binb(i+1)
          gr%MS(i,n)%con=gr%MS(i,n)%mass(rmt)/(gr%binb(i+1)*0.9_PS)
        endif
      endif
    enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Update the aerosol spectrum
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if(iaer_src==1) then

!      do in=1,ga(1)%L*2
!        icat=(in-1)/ga(1)%L+1
!        n=in-(icat-1)*ga(1)%L
       do icat = 1, 2
       do n = 1, ga(1)%L

        if(melt(1,n)>0) then
           if(debug) write(fid_alog,'("ck apmass mvice2liq",2I5,10ES15.6)') icat,n,&
                      ap_dm(n,icat),ap_dn(n,icat),ap_dm(n,icat),ap_dm(n,icat)-ap_dms(n,icat),&
                      ap_dni(n,icat)

          ga(icat)%MS(1,n)%mass(amt)=ga(icat)%MS(1,n)%mass(amt)+ &
                                     ap_dM(n,icat)

          ga(icat)%MS(1,n)%con=ga(icat)%MS(1,n)%con+&
                                     ap_dN(n,icat)

          ga(icat)%MS(1,n)%mass(ams)=ga(icat)%MS(1,n)%mass(ams)+ &
                                     ap_dMS(n,icat)

          ga(icat)%MS(1,n)%mass(ami)=ga(icat)%MS(1,n)%mass(ami)+ &
                                     max(0.0d+0,ap_dM(n,icat)-ap_dMS(n,icat))

        endif
      enddo
      enddo

    endif
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!tmp    write(*,*) "bf deallo mvice2liq"
!tmp    call deallocate_mvice2liq
!tmp    write(*,*) "af deallo mvice2liq"
!tmp  contains
!tmp    subroutine allocate_mvice2liq
!tmp      integer :: item(8)
!tmp      item=0
!tmp      allocate( new_N(gr%N_BIN), stat = item(1))
!tmp      allocate( new_M(1+gr%N_masscom,gr%N_BIN), stat = item(2))
!tmp      allocate( new_Q(gr%N_nonmass,gr%N_BIN), stat = item(3))
!tmp      allocate( ratio_Mp(gr%N_masscom), stat = item(4))
!tmp      allocate( ratio_Vp(gr%N_vol), stat = item(5))
!tmp      allocate( par(3), stat = item(6))
!tmp      allocate( new_mtend(gr%N_BIN), stat = item(7))
!tmp      allocate( shifted_bound(2), stat = item(8))
!tmp      if(any(item/=0) ) Stop 'Allocatation failed at immersion'
!tmp    end subroutine allocate_mvice2liq
!tmp    subroutine deallocate_mvice2liq
!tmp      integer :: item(8)
!tmp      item=0
!tmp      deallocate( shifted_bound, stat = item(8))
!tmp      nullify(shifted_bound)
!tmp      deallocate( new_mtend, stat = item(7))
!tmp      nullify(new_mtend)
!tmp      deallocate( par, stat = item(6))
!tmp      nullify(par)
!tmp      deallocate( ratio_Vp, stat = item(5))
!tmp      nullify(ratio_Vp)
!tmp      deallocate( ratio_Mp, stat = item(4))
!tmp      nullify(ratio_Mp)
!tmp      deallocate( new_Q, stat = item(3))
!tmp      nullify(new_Q)
!tmp      deallocate( new_M, stat = item(2))
!tmp      nullify(new_M)
!tmp      deallocate( new_N, stat = item(1))
!tmp      nullify(new_N)
!tmp      if(any(item/=0)) Stop 'Deallocatation failed at mvice2liq'
!tmp    end subroutine deallocate_mvice2liq
  end subroutine mv_ice2liq

  subroutine hydrodyn_breakup(g, N_method, mes_rc)
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the mass and concentration change by hydrodynamic fragmentation.
    ! Use the method proposed by Srivastava (1971) for liquid.
    !
    ! For ice particles there are two methods to break up ice particles
    !
    !   method 2: utilize empirical formula to get density of minimum fragment particle
    !             and then uniform distribution is assumed for the fragment distribution.
    !
    !   method 3: assume one parent particle break into particles with half the size.
    !
    ! assumption :
    !    1. if it is the graupel, it does not break up.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)   :: g
    !integer,  intent(in)                       :: level
    ! number of method that you are using for hydrodynamic breakup
    ! No. 1 The particle that became larger than maximum size shed the extra
    !       mass into the same bin.
    ! No. 2 Use distribution of fragments and probability of breakup.
    ! No. 3 Break a particle into two pieces.
    integer,  intent(in)                       :: N_method
    ! message from reality_check
!tmp    integer,pointer,dimension(:)   :: mes_rc
    integer,dimension(*)   :: mes_rc

    ! maximum dimension, (radius), of aggregate (cm)
    real(PS)                        :: max_rad

    ! number of drops that are breaking up
!tmp    real(PS), pointer, dimension(:)    :: used_N
    real(PS), dimension(mxnbin)    :: used_N
    ! number of drops gained by breakup
!tmp    real(PS), pointer, dimension(:)    :: gain_N
    real(PS), dimension(mxnbin)    :: gain_N
    ! number of drops gained by breakup
!tmp    real(PS), pointer, dimension(:,:)    :: gain_M
    real(PS), dimension(1+mxnmasscomp,mxnbin)    :: gain_M
    ! modified size distribution by breakup
!tmp    real(PS), pointer, dimension(:)    :: MQ
    real(PS), dimension(mxnbin)    :: MQ
    ! concentration increased in the jth bin by breakup of ith bin
!tmp    real(PS), pointer, dimension(:,:)    :: d_con
    real(PS), dimension(mxnbin,mxnbin)    :: d_con

    ! middle mass = (right bin limit + left bin limit )/2
!tmp    real(PS), pointer, dimension(:)            :: mid_mass
    real(PS), dimension(mxnbin)            :: mid_mass

    ! marker of consumption
!tmp    integer, pointer, dimension(:)            :: marker
    integer, dimension(mxnbin)            :: marker

    ! total gain in circumscribing volume by fragmentation
!tmp    real(PS), pointer, dimension(:,:)    :: gain_V
    real(PS), dimension(mxnnonmc,mxnbin)    :: gain_V


    ! ratio of mass components
!tmp    real(PS),pointer,dimension(:,:) :: ratio_M
    real(PS),dimension(mxnbin,1+mxnmasscomp) :: ratio_M
    ! mass and volume component of fragment ice particles
!tmp    real(PS),pointer,dimension(:,:) :: uM,uV
    real(PS),dimension(1+mxnmasscomp,mxnbin) :: uM
    real(PS),dimension(mxnnonmc,mxnbin) :: uV

    ! volume variables
!tmp    real(PS),pointer,dimension(:) :: v_var
    real(PS),dimension(mxnnonmc) :: v_var


    ! length of flagment
    !real(PS)                    :: len_min
    ! maximum length along a-axis or c-axis of the parent hydrometeor
    real(PS)                    :: max_ac
    ! maximum mass that the paricle can have with the maximum dimension
    !real(PS)                    :: max_mass

    ! equivalent radius for parent and fragment hydrometeors
    real(PS)                    :: eq_r_par!, eq_r_frag
    real(PS)                    :: sum, mod_ratio
    ! ratio of volume components to the total circumscribing volume.
    !real(PS)                    :: v_ratio
    !real(PS)                    :: mean_mass
    integer                     :: i, j,k, jmax,n!,jmin
    ! density limit that breakups
!!c    real(PS),parameter :: den_bk=0.8
    real(PS),parameter :: den_bk=0.1
    ! minimum mass for fragments to be aggregates or rimed aggrates
    real(PS) :: min_mass
    ! difference of diameter of fragments at bin boundaries
!tmp    real(PS),pointer,dimension(:) :: delta_D
    real(PS),dimension(mxnbin) :: delta_D
    ! coefficients of power law of  den=a*D**b
    real(PS)    :: aa,bb
    ! minimum diameter for fragments to be aggregates or rimed aggrates
    !real(PS) :: min_dia
    real(PS) :: nbar,dia_par
    ! diameter, density, and mass of aggregate fragments
    real(PS) :: dia_frg,den_frg,mass_frg
    integer :: j_frg

!!c    real(PS)           :: den_a,den_max

    real(PS) :: dia_ice,mass_ice,mass_ice_org,mass_par,den_ice,D1,D2!,den_par,spx_p,v_ice
    integer :: j_par,j_ice

    ! parameters defining a fragment distribution
    real(PS) :: AAf
    real(PS), parameter     :: BBf = 7.0

    !real(PS) :: m0,m1
    real(PS) :: a1,a2

    real(PS) :: ak3

    real(PS) :: mass_stot,mass_left,rat

    real(PS),parameter :: dia_agg=0.2,vol_agg=coefpi6*dia_agg**3

    ! smallest and largest bin numbers for fragment distribution
    integer :: ibinr_frg0,ibinr_frg1
    common/IFRGDIS/ibinr_frg0,ibinr_frg1
    real(PS) :: r_frg0,r_frg1
    common/RFRGDIS/r_frg0,r_frg1


    integer :: ibreak
    ! optional status check
    !integer  :: var_Status
    ! process type
    integer  :: pro_type


!tmp    write(*,*) "test of size", r_frg0,r_frg1,ibinr_frg0,ibinr_frg1

!tmp    call allocate_hydrobkup

    pro_type = 6
    if( g%token ==1 ) then
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! set the maximum radius (cm)
       max_rad = r_frg1
    else if( g%token == 2 ) then
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! set the maximum radius (cm)
       max_rad = 1.0_PS
!!c       max_rad=2.5_PS
    end if

    ! +++ calculate the mid mass +++
    do i = 1, g%N_BIN
       mid_mass(i) = (g%binb(i+1)+g%binb(i))/2.0_PS
    end do

    if(g%token==1) then
       do n=1,g%L
          ! +++ loop over grids +++
          if( mes_rc(n) == 0 ) cycle

          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! if there is no parent hydrometeor, exit.
          if( g%mark_cm(n) == 3 ) cycle
          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! initialization
          used_N = 0.0_PS
          gain_N = 0.0_PS
          gain_M = 0.0_PS
          d_con = 0.0_PS
          marker = 0
          ibreak=0
          ratio_M=0.0_PS

          call cal_massratio( g, n, ratio_M )


          do i=ibinr_frg1, g%N_BIN
             ! NOTE: i is the parent drop.
             if( g%MS(i,n)%con <= 1.0e-30_PS .OR. &
                  g%MS(i,n)%mass(1) <= 1.0e-30_PS .OR. &
                  g%MS(i,n)%mean_mass <= 1.0e-15_PS ) cycle


             max_ac   = g%MS(i,n)%len/2.0_PS
             eq_r_par = g%MS(i,n)%len/2.0_PS

             ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the sink term
             if(max_ac<max_rad) then
                cycle
             else
                used_N(i)=g%MS(i,n)%con
                ibreak=1
             end if

             ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate parameter a of fragment distribution
             AAf=BBf**3.0/(fnc1(-BBf*min(max_rad,eq_r_par)/eq_r_par)-fnc1(-BBf*r_frg0/eq_r_par))

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! normalize the number of breakup drops to conserve the mass
             sum = 0.0_PS
             MQ=0.0_PS
             do j = ibinr_frg0, ibinr_frg1
                ! NOTE: middle mass is used instead of mean mass because
                !       case of no concentration or mass in the bin mean mass cannot be
                !       obtained.
                a1=(g%binb(j)/coef4pi3)**(1.0_PS/3.0_PS)
                a2=(g%binb(j+1)/coef4pi3)**(1.0_PS/3.0_PS)

                d_con(i,j)=Q_breakup2( g%token, eq_r_par, max(r_frg0,a1), min(r_frg1,a2), AAf, BBf, 2)

                MQ(j)=Q_breakup2( g%token, eq_r_par, max(r_frg0,a1), min(r_frg1,a2), AAf, BBf, 3)
                sum = sum + MQ(j)

             end do

             if(sum<=1.0e-30) then
                mod_ratio=0.0_PS
             else
                mod_ratio=g%MS(i,n)%mean_mass/sum
             end if

             do j = ibinr_frg0, ibinr_frg1
                MQ(j)=MQ(j)*mod_ratio
                d_con(i,j)=d_con(i,j)*mod_ratio
             end do
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

             do j = ibinr_frg0, ibinr_frg1
                d_con(i,j)=d_con(i,j)*used_N(i)
                MQ(j)=MQ(j)*used_N(i)

                gain_N(j)=gain_N(j)+d_con(i,j)
                gain_M(1,j)=gain_M(1,j)+MQ(j)
                do k=1,g%N_masscom
                   gain_M(1+k,j)=gain_M(1+k,j)+MQ(j)*ratio_M(j,k)
                end do
             end do
          end do

          if(ibreak==1) then
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate concentration and mass tendency
             call cal_tendency

             call check_tendency
          end if
       end do
    elseif( g%token == 2 ) then
     if(N_method.eq.2) then
       do n=1,g%L
          ! +++ loop over grids +++
          if( mes_rc(n) == 0 ) cycle

          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! if there is no parent hydrometeor, exit.
          if( g%mark_cm(n) == 3 ) cycle
          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! initialization
          used_N = 0.0_PS
          gain_N = 0.0_PS
          gain_M = 0.0_PS
          gain_V = 0.0_PS
          d_con = 0.0_PS
          marker = 0
          ibreak=0
          min_mass=0.0_PS
          ratio_M=0.0_PS

          call cal_massratio( g, n, ratio_M )

          do i=2, g%N_BIN
             ! NOTE: i is the parent drop.
             if( g%MS(i,n)%con <= 1.0e-30_PS .OR. &
                  g%MS(i,n)%mass(1) <= 1.0e-30_PS .OR. &
                  g%MS(i,n)%mean_mass <= 1.0e-15_PS ) cycle

             ! if the hydrometeor is unrimed or rimed ice crystals, it won't break.
             if(g%IS(i,n)%sh_type<=2) then
                cycle
             elseif(g%IS(i,n)%sh_type<=4) then
                if(g%MS(i,n)%den>=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_bk) then
!!c                   g%MS(i,n)%den>=den_bk) then
!!c                if(g%IS(i,n)%den_ip>=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_bk) then
                   cycle
                end if
             else
                if(g%MS(i,n)%den>=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2.0))*den_bk) then
!!c                   g%MS(i,n)%den>=den_bk) then
!!c                if(g%MS(i,n)%den_ip>=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2.0))*den_bk) then
                   cycle
                end if
             end if

!!c             if(g%IS(i,n)%sh_type<=2.or.g%IS(i,n)%sh_type>=4) cycle
!!c             if(g%IS(i,n)%sh_type<=2.or.g%IS(i,n)%sh_type>=5) cycle


             max_ac=0.5_PS*(g%IS(i,n)%V_csw/coefpi6)**(1.0/3.0)
!!c             max_ac=0.5_PS*(g%IS(i,n)%V_cs/coefpi6)**(1.0/3.0)

!!c             eq_r_par = (3.0_PS*g%MS(i,n)%mean_mass/(4.0_PS*PI))**(1.0/3.0)


             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! assume the largest fragment at most has the maximum radius
             dia_par=2.0_PS*min(max_ac,max_rad)
             if(dia_par<=dia_agg) cycle

             ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the sink term
             used_N(i) = min( g%MS(i,n)%con, &
                  P_breakup(g%token, max_ac, max_rad) * g%MS(i,n)%con * g%dt )
             if(used_N(i)>1.0e-25_PS) then
                ibreak=1
             else
                used_N(i)=0.0_PS
                cycle
             end if

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the production term
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! exclude the parent bin itself
!             jmax = i - 1
             jmax=i

             delta_D=0.0_PS
             uM=0.0_PS
             uV=0.0_PS

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate length and volume variables
             v_var(2)=g%MS(i,n)%a_len**3.0
             v_var(3)=g%MS(i,n)%c_len**3.0
             v_var(4)=g%IS(i,n)%d**3.0
             v_var(5)=g%IS(i,n)%ag**3.0
             v_var(6)=g%IS(i,n)%cg**3.0
             v_var(7)=g%IS(i,n)%n_exice


             ! calculate diameter and mass of average crystal component
             dia_ice=(g%IS(i,n)%V_ic/coefpi6)**(1.0/3.0)
             mass_ice_org=g%MS(i,n)%mass(imc)/g%MS(i,n)%con

             ! calculate mass of the smallest fragment by assuming 0.2 cm diameter and
             !       using empirical formula.
             mass_ice=get_massagg(g%IS(i,n)%habit,dia_agg)

             if(dia_ice<dia_agg.and.mass_ice_org<mass_ice) then
              ! if diameter and mass of the smallest fragment is larger than ice crystal components,
              !    then we use that particle to get density-diameter relationship.
                den_ice=mass_ice/vol_agg
!!c                write(*,'("case 1",2I5,8ES15.6)') i,n,mass_ice_org,mass_ice,dia_ice,dia_agg,dia_par,den_ice,g%MS(i,n)%den
                dia_ice=dia_agg
             else
              ! Otherwise, bulk sphere density of ice crystal is used by assuming the smallest fragment
              !     is the crystal component.
                den_ice=mass_ice/g%IS(i,n)%V_ic
!!c                write(*,'("case 2",2I5,8ES15.6)') i,n,mass_ice_org,mass_ice,dia_ice,dia_agg,dia_par,den_ice,g%MS(i,n)%den
                mass_ice=mass_ice_org
             end if

!!c             if(g%IS(i,n)%habit<=3) then
!!c                den_max=1.5_PS*g%IS(i,n)%phi_ic/(1.0_PS+g%IS(i,n)%phi_ic**2)**1.5*den_i
!!c             elseif(g%IS(i,n)%is_mod(1)==2) then
!!c                den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_i
!!c             end if
!!c             den_max=den_i
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the coefficient of density-max dimension relationship
             call cal_dendim_coef2(aa,bb,&
                                   den_ice,dia_ice,mass_ice,g%MS(i,n)%den,2.0*max_ac,mass_par)
!!c             call cal_dendim_coef2(aa,bb,g%IS(i,n)%habit,&
!!c                                   den_ice,dia_ice,mass_ice,g%IS(i,n)%den_ip,2.0*max_ac,mass_par)

             if(mass_par<mass_ice) then
              ! just change the volume to satisfy empirical relation and put it in the same mass bin.
                j=i
                j_par=i
                j_ice=i

                d_con(i,j)=used_N(i)
                uM(1,j)=used_N(i)*g%MS(i,n)%mean_mass
                do k=1,g%N_masscom
                   uM(1+k,j)=uM(1,j)*ratio_M(i,k)
                end do
                ! ice crystal mass
                uM(4,j)=mass_ice_org*d_con(i,j)
                mass_stot=uM(2,j)+uM(3,j)+uM(8,j)
                mass_left=max(0.0_PS,uM(1,j)-uM(4,j))
                if(mass_stot>=1.0e-25_PS) then
                   rat=mass_left/mass_stot
                   uM(2,j)=uM(2,j)*rat
                   uM(3,j)=uM(3,j)*rat
                   uM(8,j)=uM(8,j)*rat
                else
                   uM(4,j)=uM(1,j)
                   uM(2,j)=0.0_PS
                   uM(3,j)=0.0_PS
                   uM(8,j)=0.0_PS
                end if

                uV(1,j)=get_volagg(g%IS(i,n)%habit,&
                   (g%MS(i,n)%mass(imr)+g%MS(i,n)%mass(ima)+g%MS(i,n)%mass(imc))/g%MS(i,n)%con)&
                    *d_con(i,j)

                do k=2,g%N_nonmass
                   uV(k,j)=v_var(k)*d_con(i,j)
                end do


!!c                write(*,'("mass of parent is smaller than ice: ibin,con,u_con,mp,mi,al,cl,sal,scl",I5,9ES15.6)') i,g%MS(i,n)%con,used_N(i),dia_par,dia_ice,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%MS(i,n)%semi_a,g%MS(i,n)%semi_c
!!c                write(*,'("aa,bb,dcon,uv",5ES15.6)') aa,bb,d_con(i,j),uV(1,j)

             else
                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                ! assume the uniform distribution for fragments
                if(dia_par<dia_ice) then
!!c                   write(*,'("diameter of parent is smaller than ice: ibin,con,u_con,mp,mi,al,cl,sal,scl",I5,9ES15.6)') i,g%MS(i,n)%con,used_N(i),dia_par,dia_ice,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%MS(i,n)%semi_a,g%MS(i,n)%semi_c
!!c                   write(*,'("aa,bb",2ES15.6)') aa,bb
!!c                   stop

                   used_N(i)=0.0_PS
                   cycle
                end if
                nbar=used_N(i)*g%MS(i,n)%mean_mass/&
                     (aa/(4.0+bb)*coefpi6*(dia_par**(bb+4.0)-dia_ice**(bb+4.0)))
!!c                nbar=used_N(i)*(g%MS(i,n)%mean_mass-g%MS(i,n)%mass(imw)/g%MS(i,n)%con)/&
!!c                     (aa/(4.0+bb)*coefpi6*(dia_par**(bb+4.0)-dia_ice**(bb+4.0)))

                if(nbar>1.0e+30.or.nbar<-1.0e+30) then
!!c                   write(*,'("nbar is out;grid,bin,nbar,dp,di,mp,mi",2I5,8ES15.6)') n,i,nbar,dia_par,dia_ice,mass_par,mass_ice
!!c                   write(*,*) "aa,bb,den,max_ac",aa,bb,g%MS(i,n)%den,max_ac
!!c                   write(*,'("habit,den,a,c,d,r,e",I5,10ES15.6)') g%IS(i,n)%habit,g%MS(i,n)%den,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d,g%IS(i,n)%r,g%IS(i,n)%e
                   used_N(i)=0.0_PS
                   cycle
                end if

!!c                write(*,'("nbar ck;grid,bin,nbar,dp,di,mp,mi",2I5,8ES15.6)') n,i,nbar,dia_par,dia_ice,mass_par,mass_ice
!!c                write(*,*) "   aa,bb,den,max_ac",aa,bb,g%MS(i,n)%den,max_ac
!!c                write(*,'("   habit,type,den,a,c,d,r,e",2I5,10ES15.6)') g%IS(i,n)%habit,g%IS(i,n)%sh_type,g%MS(i,n)%den,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d,g%IS(i,n)%r,g%IS(i,n)%e


                ! locate the max and min bin the fragments will be transfered into.
                j_ice=1
                do j=jmax,1,-1
                   if(mass_par>g%binb(j)) then
                      j_par=j
                      exit
                   end if
                end do
                do j=j_par,1,-1
                   if(mass_ice>g%binb(j)) then
                      j_ice=j
                      exit
                   end if
                end do
                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                ak3=g%IS(i,n)%V_cs/g%IS(i,n)%V_csw
                do j=j_par,j_ice,-1

                   D2=(min(g%binb(j+1),mass_par)/(coefpi6*aa))**(1.0/(3.0+bb))
                   D1=(max(g%binb(j),mass_ice)/(coefpi6*aa))**(1.0/(3.0+bb))

                   delta_D(j)=D2-D1
                   d_con(i,j)=nbar*delta_D(j)

                   uM(1,j)=(aa/(4.0+bb)*coefpi6*(D2**(bb+4.0)-D1**(bb+4.0)))*nbar
                   do k=1,g%N_masscom
                      uM(1+k,j)=uM(1,j)*ratio_M(i,k)
                   end do
                   ! ice crystal mass
                   uM(4,j)=mass_ice_org*d_con(i,j)

                   mass_stot=uM(2,j)+uM(3,j)+uM(8,j)
                   mass_left=max(0.0_PS,uM(1,j)-uM(4,j))
                   if(mass_stot>=1.0e-25_PS) then
                      rat=mass_left/mass_stot
                      uM(2,j)=uM(2,j)*rat
                      uM(3,j)=uM(3,j)*rat
                      uM(8,j)=uM(8,j)*rat
                   else
                      uM(4,j)=uM(1,j)
                      uM(2,j)=0.0_PS
                      uM(3,j)=0.0_PS
                      uM(8,j)=0.0_PS
                   end if
!!c                   uM(2,j)=max(min(uM(1,j)-uM(4,j),uM(2,j)),0.0_PS)
!!c                   uM(8,j)=max(min(uM(1,j)-uM(4,j)-uM(2,j),uM(8,j)),0.0_PS)
!!c                   uM(3,j)=max(uM(1,j)-uM(2,j)-uM(4,j)-uM(8,j),0.0_PS)

                   ! freezing nucleation mass
                   uM(9,j)=min(uM(4,j),uM(9,j))


                   uV(1,j)=coefpi6*0.25_PS*(D2**4.0-D1**4.0)*nbar*ak3
!!c                uV(1,j)=coefpi6*0.25_PS*(D2**4.0-D1**4.0)*nbar
                   do k=2,g%N_nonmass
                      uV(k,j)=v_var(k)*nbar*(D2-D1)
                   end do


                end do

                ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                ! check the mass conservation
                ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                sum = 0.0_PS
                do j=j_par,j_ice,-1
                   sum=sum+uM(1,j)
                end do

                if(sum<=1.0e-30) then
                   mod_ratio=0.0_PS
                   do j =j_par,j_ice,-1
                      uM(:,j) = 0.0_PS
                      uV(:,j) = 0.0_PS
                      d_con(i,j) = 0.0_PS
                   end do
                   used_N(i)=0.0_PS
                else
                   mod_ratio=used_N(i)*g%MS(i,n)%mean_mass/sum
                   if(abs(mod_ratio-1.0_PS)>1.0e-2) then
!!c                   write(*,'("modrat is big",3I5,ES15.6)') i,j_par,j_ice,mod_ratio
                      do j =j_par,j_ice,-1
                         uM(:,j)=uM(:,j)*mod_ratio
                         uV(:,j)=uV(:,j)*mod_ratio
                      end do
                   end if
                end if
             end if

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the gain
             do j =j_par,j_ice,-1
                gain_N(j)=gain_N(j)+d_con(i,j)

                do k=1,1+g%N_masscom
                   gain_M(k,j)=gain_M(k,j)+uM(k,j)
                   if( debug &
                        .and. ( uM(k,j)>1.0e+3_PS.or.uM(k,j)<-1.0e+3_PS ) ) then
                      write(*,'("hydrody_br>something wrong;grid,parent,gained,masscon",5I5)') n,i,j,k
                      write(*,'("          > dcon,uM",4ES15.6)') d_con(i,j),uM(k,j)
                      write(*,'("delta_D,nbar",5ES15.6)') delta_D(j),nbar
                      write(*,'("aa,bb,dp,di,mp,mi",8ES15.6)') aa,bb,dia_par,dia_ice,mass_par,mass_ice
                      write(*,'("habit,den,a,c,d,r,e",I5,10ES15.6)') &
                        g%IS(i,n)%habit,g%MS(i,n)%den,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d,g%IS(i,n)%r,g%IS(i,n)%e
                   end if
                end do

                do k=1,g%N_nonmass
                   gain_V(k,j)=gain_V(k,j)+uV(k,j)
                end do
             end do
          end do
          if(ibreak==1) then
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate concentration and mass tendency
             call cal_tendency

             call check_tendency
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          end if
       end do
     elseif(N_method.eq.3) then
!!c       write(*,*) "N_method==3 for hydrodyn_breakup"
       do n=1,g%L
          ! +++ loop over grids +++
          if( mes_rc(n) == 0 ) cycle

          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! if there is no parent hydrometeor, exit.
          if( g%mark_cm(n) == 3 ) cycle
          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! initialization
          used_N = 0.0_PS
          gain_N = 0.0_PS
          gain_M = 0.0_PS
          gain_V = 0.0_PS
          d_con = 0.0_PS
          marker = 0
          ibreak=0
          min_mass=0.0_PS
          ratio_M=0.0_PS

          call cal_massratio( g, n, ratio_M )

          do i=2, g%N_BIN
             ! NOTE: i is the parent drop.
             if( g%MS(i,n)%con <= 1.0e-30_PS .OR. &
                  g%MS(i,n)%mass(1) <= 1.0e-30_PS .OR. &
                  g%MS(i,n)%mean_mass <= 1.0e-15_PS ) cycle

             ! if the hydrometeor is unrimed or rimed ice crystals, it won't break.
             if(g%IS(i,n)%sh_type<=2) then
                cycle
             elseif(g%IS(i,n)%sh_type<=4) then
                if(g%MS(i,n)%den>=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_bk) then
!!c                   g%MS(i,n)%den>=den_bk) then
!!c                if(g%IS(i,n)%den_ip>=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_bk) then
                   cycle
                end if
             else
                if(g%MS(i,n)%den>=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2.0))*den_bk) then
!!c                   g%MS(i,n)%den>=den_bk) then
!!c                if(g%MS(i,n)%den_ip>=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2.0))*den_bk) then
                   cycle
                end if
             end if

!!c             if(g%IS(i,n)%sh_type<=2.or.g%IS(i,n)%sh_type>=4) cycle
!!c             if(g%IS(i,n)%sh_type<=2.or.g%IS(i,n)%sh_type>=5) cycle


             max_ac=0.5_PS*(g%IS(i,n)%V_csw/coefpi6)**(1.0/3.0)
!!c             max_ac=0.5_PS*(g%IS(i,n)%V_cs/coefpi6)**(1.0/3.0)

!!c             eq_r_par = (3.0_PS*g%MS(i,n)%mean_mass/(4.0_PS*PI))**(1.0/3.0)

             ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the sink term
             used_N(i) = min( g%MS(i,n)%con, &
                  P_breakup(g%token, max_ac, max_rad) * g%MS(i,n)%con * g%dt )
             if(used_N(i)>1.0e-25_PS) then
                ibreak=1
             else
                used_N(i)=0.0_PS
                cycle
             end if

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the production term
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! exclude the parent bin itself
!             jmax = i - 1
             jmax=i

             delta_D=0.0_PS
             uM=0.0_PS
             uV=0.0_PS

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate length and volume variables
             v_var(2)=g%MS(i,n)%a_len**3.0
             v_var(3)=g%MS(i,n)%c_len**3.0
             v_var(4)=g%IS(i,n)%d**3.0
             v_var(5)=g%IS(i,n)%ag**3.0
             v_var(6)=g%IS(i,n)%cg**3.0
             v_var(7)=g%IS(i,n)%n_exice


             dia_ice=(g%IS(i,n)%V_ic/coefpi6)**(1.0/3.0)
             mass_ice=g%MS(i,n)%mass(imc)/g%MS(i,n)%con
             den_ice=mass_ice/g%IS(i,n)%V_ic
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the coefficient of density-max dimension relationship
             call cal_dendim_coef2(aa,bb,den_ice,dia_ice,mass_ice,&
                  g%MS(i,n)%den,2.0*max_ac,mass_par)
!!c             call cal_dendim_coef2(aa,bb,g%IS(i,n)%habit,den_ice,dia_ice,mass_ice,g%IS(i,n)%den_ip,2.0*max_ac,mass_par)


             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! assume that the parent ice particles break into particles with 1/2 D.
             dia_frg=min(max_ac,max_rad*2.0_PS)
             if(dia_frg<dia_ice) then
!!c                write(*,'("frag is smaller than core",I5,2ES15.6)') i,dia_frg,dia_ice
                cycle
             end if
             den_frg=aa*dia_frg**bb
             mass_frg=coefpi6*aa*dia_frg**(3.0+bb)

             ! locate the max and min bin the fragments will be transfered into.
             j_frg=1
             do j=jmax,1,-1
                if(mass_frg>g%binb(j)) then
                   j_frg=j
                   exit
                end if
             end do
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c             ak3=g%IS(i,n)%V_cs/g%IS(i,n)%V_csw

             j=j_frg

             d_con(i,j)=used_N(i)*(g%MS(i,n)%mean_mass/mass_frg)

             uM(1,j)=d_con(i,j)*mass_frg
             do k=1,g%N_masscom
                uM(1+k,j)=uM(1,j)*ratio_M(i,k)
             end do
             ! ice crystal mass
             uM(4,j)=mass_ice*d_con(i,j)

!!c             mass_stot=uM(2,j)+uM(3,j)+uM(8,j)
!!c             mass_left=max(0.0_PS,uM(1,j)-uM(4,j))
!!c             if(mass_stot>=1.0e-25_PS) then
!!c                rat=mass_left/mass_stot
!!c                uM(2,j)=uM(2,j)*rat
!!c                uM(3,j)=uM(3,j)*rat
!!c                uM(8,j)=uM(8,j)*rat
!!c             else
!!c                uM(4,j)=uM(1,j)
!!c                uM(2,j)=0.0_PS
!!c                uM(3,j)=0.0_PS
!!c                uM(8,j)=0.0_PS
!!c             end if

             uM(2,j)=max(min(uM(1,j)-uM(4,j),uM(2,j)),0.0_PS)
             uM(8,j)=max(min(uM(1,j)-uM(4,j)-uM(2,j),uM(8,j)),0.0_PS)
             uM(3,j)=max(uM(1,j)-uM(2,j)-uM(4,j)-uM(8,j),0.0_PS)

             ! freezing nucleation mass
             uM(9,j)=min(uM(4,j),uM(9,j))



             uV(1,j)=coefpi6*dia_frg**3*d_con(i,j)
             do k=2,g%N_nonmass
                uV(k,j)=v_var(k)*d_con(i,j)
             end do

             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate the gain
             gain_N(j)=gain_N(j)+d_con(i,j)

             do k=1,1+g%N_masscom
                gain_M(k,j)=gain_M(k,j)+uM(k,j)
                if( debug &
                     .and. ( uM(k,j)>1.0e+3_PS.or.uM(k,j)<-1.0e+3_PS ) ) then
                   write(*,'("hydrody_br>something wrong;grid,parent,gained,masscon",5I5)') n,i,j,k
                   write(*,'("          > dcon,uM",4ES15.6)') d_con(i,j),uM(k,j)
                   write(*,'("delta_D,nbar",5ES15.6)') delta_D(j),nbar
                   write(*,'("aa,bb,dp,di,mp,mi",8ES15.6)') aa,bb,dia_par,dia_ice,mass_par,mass_ice
                   write(*,'("habit,den,a,c,d,r,e",I5,10ES15.6)') &
                      g%IS(i,n)%habit,g%MS(i,n)%den,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d,g%IS(i,n)%r,g%IS(i,n)%e
                end if
             end do

             do k=1,g%N_nonmass
                gain_V(k,j)=gain_V(k,j)+uV(k,j)
             end do

          end do
          if(ibreak==1) then
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             ! calculate concentration and mass tendency
             call cal_tendency

             call check_tendency
             ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          end if
       end do
     endif
    end if
!tmp    call deallocate_hydrobkup


  contains
!tmp    subroutine allocate_hydrobkup
!tmp      integer :: item(13)
!tmp      item=0
!tmp      allocate( used_N(g%N_BIN), stat = item(1))
!tmp      allocate( gain_N(g%N_BIN), stat = item(2))
!tmp      allocate( gain_M(1+g%N_masscom,g%N_BIN), stat = item(3))
!tmp      allocate( gain_V(g%N_nonmass,g%N_BIN), stat = item(4))
!tmp      allocate( MQ(g%N_BIN), stat = item(5))
!tmp      allocate( d_con(g%N_BIN,g%N_BIN), stat = item(6))
!tmp      allocate( mid_mass(g%N_BIN), stat = item(7))
!tmp      allocate( marker(g%N_BIN), stat = item(8))
!tmp      allocate( ratio_M(g%N_BIN,g%N_masscom ), stat = item(9))
!tmp      allocate( uM(1+g%N_masscom,g%N_BIN), stat = item(10))
!tmp      allocate( uV(g%N_nonmass,g%N_BIN), stat = item(11))
!tmp      allocate( delta_D(g%N_BIN), stat = item(12))
!tmp      allocate( v_var(g%N_nonmass), stat = item(13))
!tmp      if(any(item/=0) )Stop 'Allocatation failed at hydrobkup'
!tmp
!tmp    end subroutine allocate_hydrobkup
!tmp    subroutine deallocate_hydrobkup
!tmp      integer :: item(13)
!tmp      item=0
!tmp      deallocate(v_var, stat = item(13))
!tmp      nullify(v_var)
!tmp      deallocate(delta_D, stat = item(12))
!tmp      nullify(delta_D)
!tmp      deallocate( uV, stat = item(11))
!tmp      nullify(uV)
!tmp      deallocate( uM, stat = item(10))
!tmp      nullify(uM)
!tmp      deallocate( ratio_M, stat = item(9))
!tmp      nullify(ratio_M)
!tmp      deallocate( marker, stat = item(8))
!tmp      nullify(marker)
!tmp      deallocate( mid_mass, stat = item(7))
!tmp      nullify(mid_mass)
!tmp      deallocate( d_con, stat = item(6))
!tmp      nullify(d_con)
!tmp      deallocate( MQ, stat = item(5))
!tmp      nullify(MQ)
!tmp      deallocate( gain_V, stat = item(4))
!tmp      nullify(gain_V)
!tmp      deallocate( gain_M, stat = item(3))
!tmp      nullify(gain_M)
!tmp      deallocate( gain_N, stat = item(2))
!tmp      nullify(gain_N)
!tmp      deallocate( used_N, stat = item(1))
!tmp      nullify(used_N)
!tmp      if(any(item/=0) ) Stop 'Deallocatation failed at hydrobkup'
!tmp
!tmp    end subroutine deallocate_hydrobkup

    subroutine cal_tendency
      integer :: ka,kb
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate the tendency
      do i=1, g%N_BIN
         g%MS(i,n)%dcondt(pro_type) = (gain_N(i) - used_N(i))/g%dt
         g%MS(i,n)%dmassdt(1,pro_type) = &
              (gain_M(1,i)-used_N(i)*g%MS(i,n)%mean_mass)/g%dt
!!c         write(*,'(4ES15.6)') g%MS(i,n)%dmassdt(1,pro_type),gain_M(1,i),used_N(i),g%MS(i,n)%mean_mass
         do j=1,g%N_masscom
            g%MS(i,n)%dmassdt(1+j,pro_type) = &
                 (gain_M(1+j,i)-used_N(i)*g%MS(i,n)%mean_mass*ratio_M(i,j))/g%dt
            if( debug &
                 .and. ( g%MS(i,n)%dmassdt(1+j,pro_type)>1.0e+3_PS.or.g%MS(i,n)%dmassdt(1+j,pro_type)<-1.0e+3_PS ) ) then
               write(*,'("hydrody_break>grid,bin,masscom,dmdt",3I5,ES15.6)') n,i,j,g%MS(i,n)%dmassdt(1+j,pro_type)
               write(*,*) "gainM,usedN,meanmass",gain_M(1+j,i),used_N(i),g%MS(i,n)%mean_mass
               do ka=1,g%N_BIN
                  write(*,'("bin,ratio_M",I5,20ES15.6)') ka,(ratio_M(ka,kb),kb=1,g%N_masscom)
               end do
            end if
         end do
      end do
      if( g%token == 2 ) then
         do i=1, g%N_BIN

            g%MS(i,n)%dvoldt(ivcs,pro_type)=(gain_V(1,i)-used_N(i)*g%IS(i,n)%V_cs)/g%dt
            g%MS(i,n)%dvoldt(iacr,pro_type)=(gain_V(2,i)-used_N(i)*g%MS(i,n)%a_len**3.0)/g%dt
            g%MS(i,n)%dvoldt(iccr,pro_type)=(gain_V(3,i)-used_N(i)*g%MS(i,n)%c_len**3.0)/g%dt
            g%MS(i,n)%dvoldt(idcr,pro_type)=(gain_V(4,i)-used_N(i)*g%IS(i,n)%d**3.0)/g%dt
            g%MS(i,n)%dvoldt(iag,pro_type)=(gain_V(5,i)-used_N(i)*g%IS(i,n)%ag**3.0)/g%dt
            g%MS(i,n)%dvoldt(icg,pro_type)=(gain_V(6,i)-used_N(i)*g%IS(i,n)%cg**3.0)/g%dt
            g%MS(i,n)%dvoldt(inex,pro_type)=(gain_V(7,i)-used_N(i)*g%IS(i,n)%n_exice)/g%dt
         end do
      end if
    end subroutine cal_tendency
    subroutine check_tendency
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! double check the tendency
      real(PS) :: sum_dmdt_used,sum_dmdt_gain
      sum_dmdt_used=0.0_PS
      sum_dmdt_gain=0.0_PS
      do i=1, g%N_BIN
         sum_dmdt_used=sum_dmdt_used+max(0.0_DS,-g%MS(i,n)%dmassdt(1,pro_type))
         sum_dmdt_gain=sum_dmdt_gain+max(0.0_DS,g%MS(i,n)%dmassdt(1,pro_type))
      end do
      if(sum_dmdt_gain>=1.0e-20_PS) then
!!c         mod_ratio=sum_dmdt_gain/sum_dmdt_used
         mod_ratio=sum_dmdt_used/sum_dmdt_gain
         if(abs(mod_ratio-1.0_RP)>1.0e-5_RP) then
!!c            write(*,*) "hydrodyn_break fixed: modrat,sumused,sumgain",mod_ratio,sum_dmdt_used,sum_dmdt_gain
!!c         if(abs(mod_ratio-1.0)>1.0e-5.and.sum_dmdt_used>=1.0e-20_PS) then
            do i=1, g%N_BIN
               if(g%MS(i,n)%dmassdt(1,pro_type)>0.0_PS) then
                  g%MS(i,n)%dcondt(pro_type)=g%MS(i,n)%dcondt(pro_type)*mod_ratio
                  do j=1,1+g%N_masscom
                     g%MS(i,n)%dmassdt(j,pro_type)=g%MS(i,n)%dmassdt(j,pro_type)*mod_ratio
                  end do
                  do j=1,g%N_nonmass
                     g%MS(i,n)%dvoldt(j,pro_type)=g%MS(i,n)%dvoldt(j,pro_type)*mod_ratio
                  end do
               end if
            end do
!!c         else
!!c            do i=1, g%N_BIN
!!c               g%MS(i,n)%dcondt(pro_type)=0.0_PS
!!c               do j=1,1+g%N_masscom
!!c                  g%MS(i,n)%dmassdt(j,pro_type)=0.0_PS
!!c               end do
!!c               do j=1,g%N_nonmass
!!c                  g%MS(i,n)%dvoldt(j,pro_type)=0.0_PS
!!c               end do
!!c            end do
!!c
         end if
      else
         do i=1, g%N_BIN
            g%MS(i,n)%dcondt(pro_type)=0.0_PS
            do j=1,1+g%N_masscom
               g%MS(i,n)%dmassdt(j,pro_type)=0.0_PS
            end do
            do j=1,g%N_nonmass
               g%MS(i,n)%dvoldt(j,pro_type)=0.0_PS
            end do
         end do
      end if
    end subroutine check_tendency
  end subroutine hydrodyn_breakup

  subroutine melting_shedding(gs, ag, level, gr, mes_rc)
    use class_Thermo_Var, only: &
       get_sat_vapor_pres_lk
    use class_Ice_Shape, only: &
       get_vip, &
       cal_semiac_ip
    ! **********************************************************************
    ! Calculate the tendency by melting and shedding of solid hydrometeors
    ! based on Chen and Lamb (1994).
    !
    !
    ! Assumption
    ! - ice core has the same axis ratio as original ice.
    !
    ! NOTE
    ! - if total heat is not a prognostic variable, the melt water on
    !   ice core turns into ice at the beginning of next time step.
    !
    ! **********************************************************************
    ! mass (ice) group
    type (Group), intent(inout)   :: gs
    ! mass (liquid) group
    ! case of bin model, this is liquid group.
    ! case of bulk water parameterization, this should be cloud droplets cat
    type (Group), intent(inout)   :: gr

    ! thermo variable object
    type (AirGroup) :: ag
    ! level of degeneration
    integer, intent(in)           :: level
    ! sign of melting solid hydrometeor
    ! 0: no melting
    ! 1: one of solid hydrometeors changing size
    ! 2: The cloud category and solid hydrometeors changing size
    ! 3: The cloud, rain and solid hydrometeors changing size
    integer        :: melt_sign
    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc
    !integer :: ID(*),JD(*),KD(*)
    !
    ! total energy gain by latent heat release for a hydrometeor
    ! estimated by mass tendencies
    real (PS)                     :: E_L
    ! total energy gain by latent heat release for a hydrometeor
    ! that conduction term requires to keep the temp to 0 C in
    ! thermerl equilibrium.
    real (PS)                     :: E_L0
    ! mass of water on a solid hydrometeor, and critical value
    real (PS)                     :: m_w, m_w_c
    ! volume of melt water
    real (PS)                     :: V_w
    ! porus volume of solid hydrometeor
    real (PS)                     :: V_space
    ! mass,volume, and density of ice core
    real (PS)                     :: m_icore, V_ip
    ! a-axis length, c-axis length, and diameter of ice core
    real (PS)                     :: semi_aip_p, semi_cip_p, dia_icore
    ! new a-axis length, c-axis length, dendritic arms, rosetta, and irregular.
    !real (PS)                     :: n_alen, n_clen, n_dlen, n_rlen, n_elen, n_ag, n_cg
    !real (PS), dimension(2) :: d_axis_len

    ! mean mass
    real (PS)                     :: m_t
    ! shedding mass
    real (PS)                     :: m_shed
    ! axis ratio
    !real (PS)                     :: phi, phi_new
    ! volume of new dry ice particle
    real (PS)                     :: V_cs_p
    real (PS)                     :: v_ratio
    real (PS)                     :: q
    ! diameter of shedded water drop
    !real (PS)                     :: dia_shed
    integer             :: i, j, n!, var_Status, IER
    ! process number for tendency matrix
    integer, parameter                       :: pro_type = 10
    real (PS) :: sum_dmdt_r,sum_dmdt_s,modc!,sum_dmdt_c
    ! mass of dry aerosols
    real (PS) :: mass_ap
    ! left mass
    real(PS),dimension(mxnmasscomp) :: left_mass
    !real(PS) :: coef
    real(PS),parameter :: mlmt=1.0e-30
    real(PS),parameter :: fmliq_lmt=5.0e-2

    ! amount melt during the time step
    real(PS) :: dm_w

    ! smallest and largest bin numbers for fragment distribution
    integer :: ibinr_frg0,ibinr_frg1
    common/IFRGDIS/ibinr_frg0,ibinr_frg1
    real(PS) :: r_frg0,r_frg1
    common/RFRGDIS/r_frg0,r_frg1

    ! mass of maximum stable liquid
    real(PS) :: rm_frg1

    ! heat content of water
    real(PS),parameter :: c_w=4.187e+5
    !real(PS) :: a_ice,a_tot,dum1
    !real(PS) :: T_s
    ! maximum realisitc super saturation
    real(PS),parameter :: max_Sw=0.001
    integer :: icount,ierr!,ick,phase2



    rm_frg1=coef4pi3*r_frg1**3.0

    do n=1,gs%L
       ! +++ loop over grids +++
       if( mes_rc(n) == 0 ) cycle

       melt_sign = 0
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! if there is no parent hydrometeor, exit.
       if( gs%mark_cm(n) == 3 ) cycle
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       if( gs%token == 1 ) then
          ! --- case of water drops ---
          ! freezing process
          ! under construction
       else if( gs%token == 2 ) then
          icount=0
          do i = 1, gs%N_BIN
             if( gs%MS(i,n)%con <= 1.0e-30_PS .OR. &
                  gs%MS(i,n)%mass(1) <= 1.0e-30_PS .OR. &
                  gs%MS(i,n)%mean_mass <= 1.0e-15_PS ) cycle
             ! initialize the marker indicating production of cloud droplets or rain.
             ! 0 : no production, 1 : yes.
             gs%MS(i,n)%mark = 0

             if(T_0>ag%TV(n)%T.and.gs%MS(i,n)%inmlt==0) then
                ! ---  case of subfreezing temperature ---
                !
                ! assume that the solid hydrometeor's temp is below 0 and all dry.
                ! then, the amount of heat excess go to latent heat by
                ! melting ice.
                !
                ! assume that the heat produced by freezing of accreted particles,
                ! conduction of accreted particles to the surface temperature,
                ! vapor deposition processes are balanced.
                ! If the surface temperature becomes warmer than the freezing,
                ! then the melting occurs.
                !
                ! This has to be consistent with surface temperature estimation.
                !
                !
                E_L0 = 4.0_PS*PI*gs%MS(i,n)%CAP*ag%TV(n)%k_a*gs%MS(i,n)%fh*&
                     ( gs%MS(i,n)%tmp - ag%TV(n)%T_n )

                !if (ag%TV(n)%T_n < 1.e-25) then
                !  write(fid_alog,*) "BUG1", ag%TV(n)%T_n ! CHIARUI
                !endif
                !if (gs%MS(i,n)%tmp < 1.e-25) then
                !  write(fid_alog,*) "BUG2", gs%MS(i,n)%tmp ! CHIARUI
                !endif
                E_L=L_s*(gs%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(gs%token)/ag%TV(n)%T_n*&
                     (ag%TV(n)%s_v_n(gs%token)+1.0_PS)+&
                     gs%MS(i,n)%coef(2)*&
                     get_sat_vapor_pres_lk(gs%token,gs%MS(i,n)%tmp,ag%estbar,ag%esitbar)&
                     /gs%MS(i,n)%tmp)+&
                     (L_f+C_w*(ag%TV(n)%T_n-gs%MS(i,n)%tmp))*gs%MS(i,n)%Ldmassdt(2)

                !if (L_f < 1.e-25) then
                !  write(fid_alog,*) "BUG3", L_f ! CHIARUI
                !endif
                if(gs%MS(i,n)%tmp==T_0) then
                   m_w = (E_L - E_L0)*gs%dt/L_f

                   if(debug .and. m_w<0.0_PS) then
                      write(*,*) "something not right in melting 1:",m_w,E_L,E_L0
                   end if
                else
                   m_w=0.0_PS
                end if
!!c                m_w = L_f*gs%MS(i,n)%Ldmassdt(2)*gs%dt/L_f

!tmp                if(m_w>1.0e-20.and.ag%TV(n)%T_n<273.16-20.0) then
!tmp                   write(*,'("melting i,n,mw,T,Ts,E0,E,sv2,dsv2,ldmdt2,cap,ka,fh,fkn,fv,gtp2",2I5,20ES15.6)') i,n,m_w,&
!tmp                        ag%TV(n)%T_n-273.16,gs%MS(i,n)%tmp-273.16,&
!tmp                        E_L0,E_L,&
!tmp                        ag%TV(n)%s_v(2),ag%TV(n)%s_v_n(2), gs%MS(i,n)%Ldmassdt(2),&
!tmp                        gs%MS(i,n)%CAP,ag%TV(n)%k_a,gs%MS(i,n)%fh,gs%MS(i,n)%fkn,gs%MS(i,n)%fv,ag%TV(n)%GTP(2)
!tmp                end if

             else
                ! ---  case of above freezing temperature ---
                !
                ! assume that the solid hydrometeor has a thin film of water.
                ! Then, the heat balance among conduction,
                ! deposition/evaporation for liquid-vapor.
                ! Riming process is first assumed to produce ice phase.
                ! Heat release by riming process has to be considered.
                !
                ! This assumption is equivalent to that the internal circulation
                ! in the melt water is turbulent, which is known to be valid
                ! for diameter less than 5mm.
                ! But here it is assumed to be valid for all the range of diameter.
                if( gs%IS(i,n)%sh_type<=4) then
                   E_L0=4.0_PS*PI*gs%MS(i,n)%CAP*ag%TV(n)%k_a*gs%MS(i,n)%fh*&
                        (gs%MS(i,n)%tmp-ag%TV(n)%T_n)
                   if( T_0 <= ag%TV(n)%T ) then

                      E_L=L_e*(gs%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(1)/ag%TV(n)%T_n*&
                           (ag%TV(n)%s_v_n(1)+1.0_PS)+&
                           gs%MS(i,n)%coef(2)*&
                           get_sat_vapor_pres_lk(1,gs%MS(i,n)%tmp,ag%estbar,ag%esitbar)/&
                           gs%MS(i,n)%tmp)+&
                           c_w*(ag%TV(n)%T_n-gs%MS(i,n)%tmp)*gs%MS(i,n)%Ldmassdt(2)

                      m_w = max((E_L - E_L0)*gs%dt/L_f,0.0_PS)

!!c                      if( gs%IS(i,n)%sh_type==1) then
!!c                         write(*,'("T,mw,meanmass,cap,fh",F6.1,10ES15.6)') ag%TV(n)%T_n-273.16,m_w+gs%MS(i,n)%mass(imw)/gs%MS(i,n)%con,gs%MS(i,n)%mean_mass,&
!!c                                 gs%MS(i,n)%CAP,gs%MS(i,n)%fh
!!c                      end if
                   else
!!c                      E_L=(L_f+c_w*(ag%TV(n)%T_n-T_0))*gs%MS(i,n)%Ldmassdt(2)
!!c                      E_L=4.0_PS*PI*gs%MS(i,n)%CAP*&
!!c                           L_e*ag%TV(n)%GTP(1)*gs%MS(i,n)%fv*gs%MS(i,n)%fkn*min(max_Sw,ag%TV(n)%s_v_n(1))+&
                      E_L=L_e*(gs%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(1)/ag%TV(n)%T_n*&
                           (ag%TV(n)%s_v_n(1)+1.0_PS)+&
                           gs%MS(i,n)%coef(2)*&
                           get_sat_vapor_pres_lk(1,gs%MS(i,n)%tmp,ag%estbar,ag%esitbar)/&
                           gs%MS(i,n)%tmp)+&
                           (L_f+c_w*(ag%TV(n)%T_n-gs%MS(i,n)%tmp))*gs%MS(i,n)%Ldmassdt(2)
                      m_w = (E_L - E_L0)*gs%dt/L_f


                      if(gs%MS(i,n)%tmp==T_0) then
                         m_w = (E_L - E_L0)*gs%dt/L_f

                         if(debug .and. m_w<0.0_PS) then
                            write(*,*) "something not right in melting 2:",m_w,E_L,E_L0
                         end if
                      else
                         m_w=0.0_PS
                      end if

                   end if
                else
                   ! for graupels
!!c                   if(gs%MS(i,n)%den<=0.7_PS.or.a_max<0.25_PS) then
                   E_L0=4.0_PS*PI*gs%MS(i,n)%CAP*ag%TV(n)%k_a*gs%MS(i,n)%fh*&
                        (gs%MS(i,n)%tmp-ag%TV(n)%T_n)
                   if( T_0 <= ag%TV(n)%T ) then
!!c                      E_L=c_w*(ag%TV(n)%T_n-T_0)*gs%MS(i,n)%Ldmassdt(2)
!!c                      E_L=4.0_PS*PI*gs%MS(i,n)%CAP*&
!!c                          L_e*ag%TV(n)%GTP(1)*gs%MS(i,n)%fv*gs%MS(i,n)%fkn*min(max_Sw,ag%TV(n)%s_v_n(1))+&
                      E_L=L_e*(gs%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(1)/ag%TV(n)%T_n*&
                           (ag%TV(n)%s_v_n(1)+1.0_PS)+&
                           gs%MS(i,n)%coef(2)*&
                           get_sat_vapor_pres_lk(1,gs%MS(i,n)%tmp,ag%estbar,ag%esitbar)/&
                           gs%MS(i,n)%tmp)+&
                           c_w*(ag%TV(n)%T_n-gs%MS(i,n)%tmp)*gs%MS(i,n)%Ldmassdt(2)

                      m_w = max((E_L - E_L0)*gs%dt/L_f,0.0_PS)

!!c                      a_tot=(gs%IS(i,n)%V_csw/coef4pi3)**(1.0/3.0)
!!c                      a_ice=(gs%IS(i,n)%V_cs/coef4pi3)**(1.0/3.0)
!!c                      if(a_tot*0.99>a_ice.and.gs%MS(i,n)%mass(imw)>gs%MS(i,n)%mass(1)*0.5_PS)then
!!c                         call cal_cond_mlt_grap(gs%MS(i,n),ag%TV(n),a_tot,a_ice,T_s,dum1,ick)
!!c                         if(ick==0.and.m_w<dum1*gs%dt) then
!!c                            m_w=dum1*gs%dt
!!c                            gs%MS(i,n)%tmp=T_s
!!c                         elseif(ick>0) then
!!c                            ! case of whole ice melt.
!!c                            m_w=gs%MS(i,n)%mean_mass
!!c                         end if
!!c                      end if

                   else
!!c                      E_L=4.0_PS*PI*gs%MS(i,n)%CAP*&
!!c                           L_e*ag%TV(n)%GTP(1)*gs%MS(i,n)%fv*gs%MS(i,n)%fkn*min(max_Sw,ag%TV(n)%s_v_n(1))+&
                      E_L=L_e*(gs%MS(i,n)%coef(1)*ag%TV(n)%e_sat_n(1)/ag%TV(n)%T_n*&
                           (ag%TV(n)%s_v_n(1)+1.0_PS)+&
                           gs%MS(i,n)%coef(2)*&
                           get_sat_vapor_pres_lk(1,gs%MS(i,n)%tmp,ag%estbar,ag%esitbar)/&
                           gs%MS(i,n)%tmp)+&
                           (L_f+c_w*(ag%TV(n)%T_n-gs%MS(i,n)%tmp))*gs%MS(i,n)%Ldmassdt(2)
                      m_w = (E_L - E_L0)*gs%dt/L_f

                      if(gs%MS(i,n)%tmp==T_0) then
                         m_w = (E_L - E_L0)*gs%dt/L_f

                         if( debug .and. m_w<0.0_PS ) then
                            write(*,*) "something not right in melting 3:",m_w,E_L,E_L0
                         end if
                      else
                         m_w=0.0_PS
                      end if
                   end if
!!c                   elseif(a_max<=0.45_PS) then
!!c                      ! inner circulation is not turbulent.

!!c                a_core=((gs%MS(i,n)%mass(1)-gs%MS(i,n)%mass(imw))/gs%MS(i,n)%con/coef4pi3/gs%MS(i,n)%den )**(1.0/3.0)
                endif


             end if



             if(level<=3) then
                mass_ap=0.0_PS
             elseif(level>=4) then
                mass_ap=gs%MS(i,n)%mass(imat)/gs%MS(i,n)%con
             end if

             ! calculate melt water on a hydrometeor
             dm_w=m_w
             m_w=gs%MS(i,n)%mass(imw)/gs%MS(i,n)%con+m_w


!!c             if( m_w > 0.0_PS.or.ag%TV(n)%T_n>=T_0+5.0_PS ) then
             if((level<=5.and.m_w>=0.0_PS).or.&
                  (level>=6.and.(gs%MS(i,n)%mass(imw)/gs%MS(i,n)%con>1.0e-12_PS.or.&
                  dm_w/=0.0_PS))) then

!!c                 write(*,'("I am in melting cal",2I5,4ES15.6)') i,n,m_w,dm_w,ag%TV(n)%T_n,gs%MS(i,n)%tmp
                ! --- case where melt water exists ---
!!c                if(gs%MS(i,n)%mean_mass<=m_w) then
!!c                if(gs%MS(i,n)%mean_mass-mass_ap<=m_w.or.ag%TV(n)%T_n>=T_0+5.0_PS) then
                if(gs%MS(i,n)%mean_mass-mass_ap<=m_w) then
                   ! --- case of whole the ice melted ---
                   call melt_all
                   cycle
                else

                   ! initialize left_mass
                   left_mass(1:gs%N_masscom)=gs%MS(i,n)%mass(2:gs%N_masscom+1)
                   if(level>=6) then
!!c                      dm_w=m_w*gs%MS(i,n)%con-gs%MS(i,n)%mass(imw)
                      dm_w=dm_w*gs%MS(i,n)%con

                      if(dm_w>0.0_PS) then
                         ! case of melting
                         ! assume that hydrometeor evaporate by keeping the ratio between
                         ! graupel and (aggregate+crystal mass) the same, and the ratio
                         ! between aggregate and crystal mass the same.

!!c                         call dep_mass2(-dm_w,gs%MS(i,n)%mass,&
!!c                                       left_mass,ierr,'melting_shedding_1')
                         call dep_mass3(-dm_w,gs%MS(i,n)%con,gs%MS(i,n)%mass,&
                                       left_mass,ierr,'melting_shedding_1')
                         left_mass(imw_m)=m_w*gs%MS(i,n)%con

                         ! freezing nucleation mass
                         left_mass(imf_m)=min(left_mass(imc_m),left_mass(imf_m))

                         if(ierr.ne.0) then
                           ! --- case of whole the ice melted ---
                           call melt_all
                           cycle
                         endif

                      else
                         ! case of freezing
                         !
                         ! The freezing water is added to riming mass since those
                         ! may have similar effect on surface structure and optical property
                         ! of ice.
                         m_w=max(0.0_PS,m_w)
                         dm_w=max(-gs%MS(i,n)%mass(imw),dm_w)
                         left_mass(imr_m)=left_mass(imr_m)-dm_w
                         left_mass(imw_m)=max(0.0_PS,left_mass(imw_m)+dm_w)
                      end if
                   end if

                   m_t=gs%MS(i,n)%mean_mass

                   m_icore = m_t - m_w

                   m_w_c = 0.268_PS + 0.1389_PS * m_icore

                   ! +++ change the tendency so that the sfc temperature becomes
                   !     0 C. +++
!!c                   gs%MS(i,n)%Ldmassdt(1)= gs%MS(i,n)%Ldmassdt(1)*E_L0/E_L
!!c                   gs%MS(i,n)%Ldmassdt(2)= gs%MS(i,n)%Ldmassdt(2)*E_L0/E_L

                   if( gs%IS(i,n)%sh_type <= 2 ) then
                      ! --- case of ice crystals ---
                      V_cs_p=m_icore/gs%IS(i,n)%den_ip

                      ! assume the cylinder volume
!!c                      semi_aip_p=(V_cs_p/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+gs%IS(i,n)%phi_cs**2.0)
!!c                      semi_cip_p=semi_aip_p*gs%IS(i,n)%phi_cs
                      call cal_semiac_ip(gs%IS(i,n)%is_mod(2),gs%IS(i,n)%phi_cs,V_cs_p,semi_aip_p,semi_cip_p)

!!c                      n_alen=semi_aip_p
!!c                      n_clen=semi_cip_p
!!c                      n_dlen=semi_aip_p*gs%IS(i,n)%phi_cs
                      dia_icore=2.0_PS*max(semi_aip_p,semi_cip_p)

                      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ! calculate the porus volume and check if the water comes out to
                      ! the surface of solid hydrometeor
                      V_w = m_w/den_w

                      V_ip=get_vip(gs%IS(i,n)%is_mod(2),gs%IS(i,n)%phi_cs,semi_aip_p)
!!c                      ! assume the cylinder volume
!!c                      V_ip=coef2p*gs%IS(i,n)%phi_cs*semi_aip_p**3.0

                      V_space=max(0.0_PS,V_ip-m_icore/den_i)
                      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                      if(V_space>=V_w) then
                         ! --- case where  the meltwater stay inside of hydrometeor ---
                         ! no shedding occurs
                         ! 1. assume the axis ratio of circumscribing spheroid does not change,
                         !    but surface temperature changes.
                         ! 2. assume that ice crystals inside won't change any size.
                         !
                         if(level>=6) then
                            do j=1,gs%N_masscom
                               gs%MS(i,n)%dmassdt(1+j,pro_type)=(left_mass(j)-gs%MS(i,n)%mass(1+j))/gs%dt
                            end do
                         end if

                         gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                         call cal_tendency_vol2


                         gs%MS(i,n)%mark = 11
                         melt_sign = 1

                      else
                         ! --- case where the meltwater stay outside of hydrometeor ---
                         m_shed = 0.0_PS
                         melt_sign = 1
                         gs%MS(i,n)%mark = 2

                         if( dia_icore >= 0.9_PS ) then
                            ! --- case of forming torus near the equator ---
                            ! assume the ice crystals change the size, but keep the ratio
                            ! and phi=c/a psi=d/a the same.
                            gs%MS(i,n)%mark = 3

                            if( m_w >= m_w_c ) then
                               ! --- case of shedding ---
                               q = 1.0_PS+10.67_PS*(dia_icore-0.9_PS)-&
                                    10.81_PS*(dia_icore-0.9_PS)**2.0+&
                                    10.26_PS*(dia_icore-0.9_PS)**3.0
                               m_shed = max(0.0_PS,m_w - m_t/q)

                               gs%MS(i,n)%mark = 4
                               call add_breakup2(m_shed, m_shed*gs%MS(i,n)%con,&
                                 m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(1),melt_sign)
                            end if

                            call cal_tendency_mass

                            gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                            call cal_tendency_vol2

                         elseif( m_w>rm_frg1 ) then
                            ! --- case of unstable melt water ---
                            gs%MS(i,n)%mark = 14

                            m_shed=rm_frg1

                            call add_breakup2(m_shed, m_shed*gs%MS(i,n)%con, &
                                 m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(1),melt_sign)

                            call cal_tendency_mass

                            gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                            call cal_tendency_vol2
                         else
                            ! --- case of forming a layer of water film over the sfcs ---
                            ! no shedding occurs
                            ! 1. assume the axis ratio does not change
                            ! 2. assume the ice crystals inside do not change the shape.


                            if(level>=6) then
                               do j=1,gs%N_masscom
                                  gs%MS(i,n)%dmassdt(1+j,pro_type)=(left_mass(j)-gs%MS(i,n)%mass(1+j))/gs%dt
                               end do
                            end if

                            gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                            call cal_tendency_vol2
                         end if
                      end if


                   else
!!c                   write(*,*) "here three"
                      ! --- case of aggregates and graupels ---
                      !
                      ! calculate new bulk sphere density of dry particle.
                      !    assume
                      !        - the dry density is kept in the melting process
                      !        - aspect ratio is kept constant
                      !
                      V_cs_p=m_icore/gs%IS(i,n)%den_ip
!!c                      if(gs%IS(i,n)%is_mod(2)==1) then
!!c                         ! assume the cylinder volume
!!c                         semi_aip_p=(V_cs_p/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+gs%IS(i,n)%phi_cs**2.0)
!!c                         semi_cip_p=semi_aip_p*gs%IS(i,n)%phi_cs
!!c                      elseif(gs%IS(i,n)%is_mod(2)==2) then
!!c                         ! assume the spheroidal volume
!!c                         if(gs%IS(i,n)%phi_cs<1.0) then
!!c                            semi_aip_p=(V_cs_p/coef4pi3)**(1.0/3.0)
!!c                            semi_cip_p=semi_aip_p*gs%IS(i,n)%phi_cs
!!c                         else
!!c                            semi_cip_p=(V_cs_p/coef4pi3)**(1.0/3.0)
!!c                            semi_aip_p=semi_cip_p/gs%IS(i,n)%phi_cs
!!c                         end if
!!c                      end if
                      call cal_semiac_ip(gs%IS(i,n)%is_mod(2),gs%IS(i,n)%phi_cs,V_cs_p,semi_aip_p,semi_cip_p)


!!c                      if(gs%IS(i,n)%sh_type<=4) then
!!c                         coef=coef2p
!!c                      else
!!c                         coef=coef4pi3
!!c                      end if
                      dia_icore=2.0_PS*max(semi_aip_p,semi_cip_p)


                      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ! calculate the porus volume and check if the water comes out to
                      ! the surface of solid hydrometeor
                      V_w = m_w/den_w
                      V_ip=get_vip(gs%IS(i,n)%is_mod(2),gs%IS(i,n)%phi_cs,semi_aip_p)

!!c                      if(gs%IS(i,n)%is_mod(2)==1) then
!!c                         ! assume the cylinder volume
!!c                         V_ip=coef2p*gs%IS(i,n)%phi_cs*semi_aip_p**3.0
!!c                      elseif(gs%IS(i,n)%is_mod(2)==2) then
!!c                         ! assume the spheroidal volume
!!c                         V_ip=coef4pi3*gs%IS(i,n)%phi_cs*semi_aip_p**3.0
!!c                      end if

                      V_space = max(0.0_PS,V_ip - m_icore/den_i)
                      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                      if(V_space>=V_w) then
                         ! --- case where  the meltwater stay inside of hydrometeor ---
                         ! no shedding occurs
                         ! 1. assume the axis ratio of circumscribing spheroid does not change,
                         !    but surface temperature changes.
                         ! 2. assume that ice crystals inside won't change any size.
                         !
                         if(level>=6) then
                            do j=1,gs%N_masscom
                               gs%MS(i,n)%dmassdt(1+j,pro_type)=(left_mass(j)-gs%MS(i,n)%mass(1+j))/gs%dt
                            end do
                         end if
                         gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                         call cal_tendency_vol2


                         gs%MS(i,n)%mark = 11
                         melt_sign = 1

                      else
                         ! --- case where the meltwater stay outside of hydrometeor ---
                         m_shed = 0.0_PS
                         melt_sign = 1
                         gs%MS(i,n)%mark = 12
                         if( dia_icore >= 0.9_PS ) then
                            ! --- case of forming torus near the equator ---
                            ! assume the ice crystals inside do not change the shape.
                            if( m_w >= m_w_c ) then
                               ! --- case of shedding ---
                               q = 1.0_PS+10.67_PS*(dia_icore-0.9_PS)-&
                                    10.81_PS*(dia_icore-0.9_PS)**2.0+&
                                    10.26_PS*(dia_icore-0.9_PS)**3.0

                               m_shed = min(m_w - m_t/q,gs%MS(i,n)%mean_mass)

                               gs%MS(i,n)%mark = 13
                               call add_breakup2(m_shed, m_shed*gs%MS(i,n)%con, &
                                       m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(1),melt_sign)
                            end if

                            call cal_tendency_mass
                            gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                            call cal_tendency_vol2

                         elseif( m_w>rm_frg1 ) then
                            ! --- case of unstable melt water ---
                            gs%MS(i,n)%mark = 14

                            m_shed=rm_frg1

                            call add_breakup2(m_shed, m_shed*gs%MS(i,n)%con, &
                                 m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(1),melt_sign)

                            call cal_tendency_mass
                            gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                            call cal_tendency_vol2

                         else
                            ! --- case of forming a layer of water film over the sfcs ---
                            ! no shedding occurs
                            ! 1. assume the axis ratio does not change
                            ! 2. assume the ice crystals inside do not change the shape.


                            if(level>=6) then
                               do j=1,gs%N_masscom
                                  gs%MS(i,n)%dmassdt(1+j,pro_type)=(left_mass(j)-gs%MS(i,n)%mass(1+j))/gs%dt
                               end do
                            end if
                            gs%MS(i,n)%dvoldt(ivcs,pro_type)=(V_cs_p-gs%IS(i,n)%V_cs)*gs%MS(i,n)%con/gs%dt
                            call cal_tendency_vol2

                         end if
                      end if
!!c                      end if
                   end if
                end if
             else
                   ! --- case of nothing going on ---
                   gs%MS(i,n)%mark = 0
             end if
          end do
          ! ---- normalize the tendency ----

          sum_dmdt_r=0.0_PS
          do j = 1, gr%N_BIN
             sum_dmdt_r=sum_dmdt_r+gr%MS(j,n)%dmassdt(rmt,pro_type)
          end do
          sum_dmdt_s=0.0_PS
          do j = 1, gs%N_BIN
             sum_dmdt_s=sum_dmdt_s+gs%MS(j,n)%dmassdt(imt,pro_type)
          end do


          if(sum_dmdt_s==0.0_PS.and.sum_dmdt_r==0.0_PS) cycle

!!c          write(*,'("shedding normilized",3I5,10ES15.6)') KD(n),ID(n),JD(n),sum_dmdt_r*gs%dt,sum_dmdt_s*gs%dt
          if(-sum_dmdt_s>mlmt.and.sum_dmdt_r>0.0_PS) then
!!c                   if(sum_dmdt_r/=-sum_dmdt_s) then
             if(abs(1.0_PS-abs(sum_dmdt_r/sum_dmdt_s))>1.0e-5_PS) then
!!c                      modc=-sum_dmdt_r/sum_dmdt_s
                modc=-sum_dmdt_s/sum_dmdt_r
                if(debug) write(*,*) "I am fixing melt tend",modc
                do j = 1, gr%N_BIN
                   gr%MS(j,n)%dcondt(pro_type)=gr%MS(j,n)%dcondt(pro_type)*modc
                   gr%MS(j,n)%dmassdt(1:1+gr%N_masscom,pro_type)=&
                        gr%MS(j,n)%dmassdt(1:1+gr%N_masscom,pro_type)*modc
                end do
             end if
          elseif(-sum_dmdt_s<mlmt.and.sum_dmdt_s<0.0_PS) then
             do j = 1, gr%N_BIN
                gr%MS(j,n)%dcondt(pro_type)=0.0_PS
                gr%MS(j,n)%dmassdt(1:1+gr%N_masscom,pro_type)=0.0_PS
             end do
             do j = 1, gs%N_BIN
                gs%MS(j,n)%dcondt(pro_type)=0.0_PS
                gs%MS(j,n)%dmassdt(1:1+gs%N_masscom,pro_type)=0.0_PS
                gs%MS(j,n)%dvoldt(1:gs%N_nonmass,pro_type)=0.0_PS
             end do
          else
             if ( debug ) then
                write(*,*) "something is wrong in melting and shedding"
                write(*,*) "sum_dmdt_r,sum_dmdt_s:",sum_dmdt_r,sum_dmdt_s
                do j=1,gr%N_BIN
                   write(*,'("gr bin#, con, mass1, dmdt",I5,3ES15.6)') &
                        j,gr%MS(j,n)%con,gr%MS(j,n)%mass(1),gr%MS(j,n)%dmassdt(rmt,pro_type)
                end do
                do j=1,gs%N_BIN
                   write(*,'("gs bin#, shtype, con,mass1, dmdt",2I5,3ES15.6)') &
                        j,gs%IS(j,n)%sh_type,gs%MS(j,n)%con,gs%MS(j,n)%mass(1),gs%MS(j,n)%dmassdt(imt,pro_type)
                end do
             end if
             do j=1,gr%N_BIN
                gr%MS(j,n)%dcondt(pro_type)=0.0_PS
                gr%MS(j,n)%dmassdt(1:1+gr%N_masscom,pro_type)=0.0_PS
             end do
             do j=1,gs%N_BIN
                gs%MS(j,n)%dcondt(pro_type)=0.0_PS
                gs%MS(j,n)%dmassdt(1:1+gs%N_masscom,pro_type)=0.0_PS
             end do
          end if
       end if

!!c       if(ag%TV(n)%T_n>=T_0) then
!!c          write(*,'("T,Whole mlt,mark ",2F6.1,100I3)') ag%TV(n)%T-273.16,real(icount)/real(g%N_BIN )*100.0_RP,(gs%MS(i,n)%mark,i=1,g%N_BIN)
!!c       end if


    end do

  CONTAINS

    subroutine add_breakup2(m_shed, mcon_shed, mconap_shed, melt_sign)
      ! mass of shedded water drop, and mass concentration
      real (PS), intent(in)         :: m_shed, mcon_shed,mconap_shed
      ! sign of melting
      integer, intent(inout)        :: melt_sign
      ! radius of shedded water drop
      real (PS)                     :: rad_shed
      real (PS)                     :: con2, mass2!, con1, mass1
      ! a-axis length at bin limits
      real (PS)                     :: a1, a2
      integer                       :: j,k

      real(PS) :: dcdt(gr%N_BIN),dmdt(gr%N_BIN,gr%N_masscom+1)

      real(PS) :: ratio_M(gr%N_masscom)

      real(PS) :: map_tot,mw_tot

      ! parameters defining a fragment distribution
      real(PS) :: AAf
      real(PS), parameter     :: BBf = 7.0


      if(m_shed<=0.0_PS) return
!tmp      if(mcon_shed<=1.0e-25_PS) then
!tmp         write(*,*) "here"
!tmp      end if

      rad_shed = (3.0_PS*m_shed/(4.0_PS*PI*1.0_PS))&
           **(1.0/3.0)

      ! --- add the mass tendency to liquid category ---
      ! NOTE
      !
      ! the number of breakup drops are obtained from
      ! Srivastava (1971):
      melt_sign = 3

      ! calculate mass ratio of aerosols
      ratio_M(rmat_m)=gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(1)
      ratio_M(rmas_m)=gs%MS(i,n)%mass(imas)/gs%MS(i,n)%mass(1)
      ratio_M(rmai_m)=max(0.0_PS,ratio_M(rmat_m)-ratio_M(rmas_m))

      if(rad_shed>=r_frg1) then

         map_tot=0.0_PS
         mw_tot=0.0_PS

         dcdt=0.0_PS
         dmdt=0.0_PS
         ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! calculate parameter a of fragment distribution
         AAf=BBf**3.0/(fnc1(-BBf*min(r_frg1,rad_shed)/rad_shed)-fnc1(-BBf*r_frg0/rad_shed))

         ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! normalize the number of breakup drops to conserve the mass
         do j = ibinr_frg0, ibinr_frg1
            ! NOTE: middle mass is used instead of mean mass because
            !       case of no concentration or mass in the bin mean mass cannot be
            !       obtained.
            a1=(gr%binb(j)/coef4pi3)**(1.0_PS/3.0_PS)
            a2=(gr%binb(j+1)/coef4pi3)**(1.0_PS/3.0_PS)

            con2=Q_breakup2( 1, rad_shed, max(r_frg0,a1), min(r_frg1,a2), AAf, BBf, 2)

            mass2=Q_breakup2( 1, rad_shed, max(r_frg0,a1), min(r_frg1,a2), AAf, BBf, 3)

            dcdt(j)=con2*gs%MS(i,n)%con/gr%dt

            dmdt(j,1)=mass2*gs%MS(i,n)%con/gr%dt
!!c                     write(*,*) pro_type, gr%MS(j)%dmassdt(rmt,pro_type)
            ! for aerosol masses
            do k=1,gr%N_masscom
               dmdt(j,1+k)=dmdt(j,1)*ratio_M(k)
            end do

            map_tot=map_tot+dmdt(j,2)*gr%dt
            mw_tot=mw_tot+dmdt(j,1)*gr%dt
         end do

!!c      write(*,'("m_shed,water, mapt, mapt_l, mw_tot",7ES15.6)') &
!!c           m_shed*gs%MS(i,n)%con,gs%MS(i,n)%mass(1)-gs%MS(i,n)%mass(imat),&
!!c           gs%MS(i,n)%mass(imat),map_tot,mw_tot

         do j = ibinr_frg0, ibinr_frg1
            gr%MS(j,n)%dcondt(pro_type)=gr%MS(j,n)%dcondt(pro_type)&
                 +dcdt(j)*(mcon_shed/mw_tot)
            gr%MS(j,n)%dmassdt(rmt,pro_type)=gr%MS(j,n)%dmassdt(rmt,pro_type)&
                 +dmdt(j,1)*(mcon_shed/mw_tot)
            do k=1,gr%N_masscom
               gr%MS(j,n)%dmassdt(1+k,pro_type)=gr%MS(j,n)%dmassdt(1+k,pro_type)&
                    +dmdt(j,1+k)*(mconap_shed/map_tot)
            end do
         end do
      else
         ! case of no breakup
         do j = 1, gr%N_BIN
            if(gr%binb(j+1)>m_shed) then

               gr%MS(j,n)%dcondt(pro_type)=gr%MS(j,n)%dcondt(pro_type)+gs%MS(i,n)%con/gr%dt

               gr%MS(j,n)%dmassdt(rmt,pro_type)=gr%MS(j,n)%dmassdt(rmt,pro_type)+mcon_shed/gr%dt

               do k=1,gr%N_masscom
                  gr%MS(j,n)%dmassdt(1+k,pro_type)=gr%MS(j,n)%dmassdt(1+k,pro_type)&
                       +ratio_M(k)*mcon_shed/gr%dt
               end do
               exit
            end if

         end do
         j=gr%N_BIN
         if(gr%binb(j+1)<=m_shed) then
            gr%MS(j,n)%dcondt(pro_type)=gr%MS(j,n)%dcondt(pro_type)+gs%MS(i,n)%con/gr%dt
            gr%MS(j,n)%dmassdt(rmt,pro_type)=gr%MS(j,n)%dmassdt(rmt,pro_type)+mcon_shed/gr%dt
            do k=1,gr%N_masscom
               gr%MS(j,n)%dmassdt(1+k,pro_type)=gr%MS(j,n)%dmassdt(1+k,pro_type)&
                    +ratio_M(k)*mcon_shed/gr%dt
            end do
         end if
      end if

    end subroutine add_breakup2


    subroutine cal_tendency_mass

      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! change the shape of the dry ice particle with torus
      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c      V_w = (m_w - m_shed)/den_w
!!c      V_cs_p = max((V_w - V_space),0.0_PS) + V_ip
!!c      if(  gs%IS(i,n)%phi_cs < 1.0_PS ) then
!!c         n_clen = semi_cip_p
!!c         phi_new = sqrt( coef*(semi_cip_p**3.0)/V_cs_p)
!!c         n_alen = n_clen/phi_new
!!c
!!c      else if(  gs%IS(i,n)%phi_cs > 1.0_PS ) then
!!c         n_alen = semi_aip_p
!!c         phi_new = V_cs_p/coef/semi_aip_p**3.0
!!c         n_clen = n_alen*phi_new
!!c      else
!!c         n_alen = (V_cs_p/coef4pi3)**(1.0_PS/3.0_PS)
!!c         n_clen = n_alen
!!c         phi_new=1.0_PS
!!c      end if

      if( m_shed>0.0_PS ) then
         if(level<=5) then
            ! assume that hydrometeor melt by keeping the ratio between
            ! graupel and (aggregate+crystal mass) the same, and the ratio
            ! between aggregate and crystal mass the same.

            gs%MS(i,n)%dmassdt(imt,pro_type) = - m_shed * gs%MS(i,n)%con/gs%dt
!!c            call dep_mass2(-m_shed*gs%MS(i,n)%con,gs%MS(i,n)%mass,&
!!c                           left_mass,ierr,'cal_tendency_mass')
            call dep_mass3(-m_shed*gs%MS(i,n)%con,gs%MS(i,n)%con,gs%MS(i,n)%mass,&
                           left_mass,ierr,'cal_tendency_mass')
         else
            ! assume that hydrometeor shed
            !    1. already melt water
            !    2. aggregation mass com,or rime mass (larger one is the fist)
            !    3. crystal mass com.
            !
            gs%MS(i,n)%dmassdt(imt,pro_type)=-m_shed * gs%MS(i,n)%con/gs%dt

            left_mass(imw_m)=max(0.0_DS,left_mass(imw_m)+gs%MS(i,n)%dmassdt(imt,pro_type)*gs%dt)

         end if



         ! assume the shed water has the same aerosol composition of the parent hydrometeor
         left_mass(imat_m)=gs%MS(i,n)%mass(imat)-&
              m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(imt)
         left_mass(imas_m)=gs%MS(i,n)%mass(imas)-&
              m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imas)/gs%MS(i,n)%mass(imt)
         left_mass(imai_m)=gs%MS(i,n)%mass(imai)-&
              m_shed*gs%MS(i,n)%con*gs%MS(i,n)%mass(imai)/gs%MS(i,n)%mass(imt)

!!c      write(*,'("2,i,n,m_shed*con,leftm,massc",2I8,8ES15.6)') i,n,m_shed*gs%MS(i,n)%con,(left_mass(j),gs%MS(i,n)%mass(j+1),j=1,g%N_masscom)

         do j=1,gs%N_masscom
            gs%MS(i,n)%dmassdt(1+j, pro_type) = (left_mass(j)-gs%MS(i,n)%mass(1+j))/gs%dt
         end do
      else
         ! no shedding
         if(level>=6) then
            do j=1,gs%N_masscom
               gs%MS(i,n)%dmassdt(1+j,pro_type)=(left_mass(j)-gs%MS(i,n)%mass(1+j))/gs%dt
            end do
         end if
      end if

      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    end subroutine cal_tendency_mass

!!$    subroutine cal_tendency_vol
!!$      v_ratio=gs%MS(i,n)%a_len**3.0/gs%IS(i,n)%V_cs
!!$      gs%MS(i,n)%dvoldt(iacr,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)
!!$      if(gs%MS(i,n)%dvoldt(iacr,pro_type)>1.0e+20.or.&
!!$         gs%MS(i,n)%dvoldt(iacr,pro_type)<-1.0e+20) then
!!$         write(*,*) "Here the dvoldt(2,10) is wrong 1 at",i,n
!!$         write(*,'("v_ratio,alen,v_cs",3ES15.6)') v_ratio,gs%MS(i,n)%a_len,gs%IS(i,n)%V_cs
!!$         write(*,'("phi_cs,den",2ES15.6)') gs%IS(i,n)%phi_cs,gs%MS(i,n)%den
!!$         write(*,'("psi_ic,phi_ic,alen",3ES15.6)') gs%IS(i,n)%psi_ic,gs%IS(i,n)%phi_ic,gs%MS(i,n)%a_len
!!$         stop
!!$      end if
!!$      ! c axis
!!$      v_ratio=gs%MS(i,n)%c_len**3.0/gs%IS(i,n)%V_cs
!!$      gs%MS(i,n)%dvoldt(iccr,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)
!!$      ! d axis
!!$      v_ratio=gs%IS(i,n)%d**3.0/gs%IS(i,n)%V_cs
!!$      gs%MS(i,n)%dvoldt(idcr,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)
!!$      ! ag axis
!!$      v_ratio=gs%IS(i,n)%ag**3.0/gs%IS(i,n)%V_cs
!!$      gs%MS(i,n)%dvoldt(iag,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)
!!$      ! cg axis
!!$      v_ratio=gs%IS(i,n)%cg**3.0/gs%IS(i,n)%V_cs
!!$      gs%MS(i,n)%dvoldt(icg,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)
!!$
!!$      ! number of extra ice crystals
!!$!!c    v_ratio=gs%IS(i,n)%n_exice/gs%IS(i,n)%V_cs
!!$!!c    gs%MS(i,n)%dvoldt(inex,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)
!!$    end subroutine cal_tendency_vol
    subroutine cal_tendency_vol2
      use scale_prc, only: &
         PRC_abort
      ! calculate volume change that corresponds to the crytal mass change assuming
      ! bulk crystal density does not change
      v_ratio=left_mass(imc_m)/&
          (gs%IS(i,n)%den_ic*coef4pi3*(1.0_PS+gs%IS(i,n)%phi_ic**2)**1.5)

      gs%MS(i,n)%dvoldt(iacr,pro_type)=(v_ratio-gs%MS(i,n)%con*gs%MS(i,n)%a_len**3)/gs%dt

!!c      gs%MS(i,n)%dvoldt(iacr,pro_type)=gs%MS(i,n)%dmassdt(imc,pro_type)/gs%IS(i,n)%den_ic/&
!!c            (coef4pi3*(1.0_PS+gs%IS(i,n)%phi_ic**2)**1.5)

      if(gs%MS(i,n)%dvoldt(iacr,pro_type)>1.0e+20.or.&
         gs%MS(i,n)%dvoldt(iacr,pro_type)<-1.0e+20) then
         LOG_ERROR("cal_tendency_vol2",*) "Here the dvoldt(2,10) is wrong 1 at",i,n
         LOG_ERROR_CONT('("v_ratio,alen,v_cs",3ES15.6)') v_ratio,gs%MS(i,n)%a_len,gs%IS(i,n)%V_cs
         LOG_ERROR_CONT('("phi_cs,den",2ES15.6)') gs%IS(i,n)%phi_cs,gs%MS(i,n)%den
         LOG_ERROR_CONT('("psi_ic,phi_ic,alen",3ES15.6)') gs%IS(i,n)%psi_ic,gs%IS(i,n)%phi_ic,gs%MS(i,n)%a_len
         call PRC_abort
      end if
      ! c axis
      gs%MS(i,n)%dvoldt(iccr,pro_type)=gs%MS(i,n)%dvoldt(iacr,pro_type)*gs%IS(i,n)%phi_ic**3

      ! d axis
      gs%MS(i,n)%dvoldt(idcr,pro_type)=gs%MS(i,n)%dvoldt(iacr,pro_type)*gs%IS(i,n)%psi_ic**3

      ! ag axis
      v_ratio=gs%IS(i,n)%ag/gs%MS(i,n)%a_len
      gs%MS(i,n)%dvoldt(iag,pro_type)=gs%MS(i,n)%dvoldt(iacr,pro_type)*v_ratio**3
      ! cg axis
      v_ratio=gs%IS(i,n)%cg/gs%MS(i,n)%a_len
      gs%MS(i,n)%dvoldt(icg,pro_type)=gs%MS(i,n)%dvoldt(iacr,pro_type)*v_ratio**3

      ! number of extra ice crystals
!!c    v_ratio=gs%IS(i,n)%n_exice/gs%IS(i,n)%V_cs
!!c    gs%MS(i,n)%dvoldt(inex,pro_type)=v_ratio*gs%MS(i,n)%dvoldt(ivcs,pro_type)

      ! activated IN concentration

    end subroutine cal_tendency_vol2

    subroutine melt_all
      use scale_prc, only: &
         PRC_abort
      icount=icount+1
      gs%MS(i,n)%mark = 1

      call add_breakup2(gs%MS(i,n)%mean_mass,gs%MS(i,n)%mass(1),gs%MS(i,n)%mass(imat),melt_sign)
      gs%MS(i,n)%dcondt(pro_type) = - gs%MS(i,n)%con/gs%dt
      do j=1,1+gs%N_masscom
         gs%MS(i,n)%dmassdt(j, pro_type) =  - gs%MS(i,n)%mass(j)/gs%dt
      end do

      gs%MS(i,n)%dvoldt(ivcs, pro_type)=-gs%MS(i,n)%con*gs%IS(i,n)%V_cs/gs%dt

      gs%MS(i,n)%dvoldt(iacr,pro_type)=-gs%MS(i,n)%a_len**3.0*gs%MS(i,n)%con/gs%dt

      if(gs%MS(i,n)%dvoldt(iacr,pro_type)>1.0e+20.or.&
           gs%MS(i,n)%dvoldt(iacr,pro_type)<-1.0e+20) then
         LOG_ERROR("melt_all",*) "Here the dvoldt(2,10) is wrong 1 at",i,n
         LOG_ERROR_CONT('("v_ratio,alen,v_cs",3ES15.6)') v_ratio,gs%MS(i,n)%a_len,gs%IS(i,n)%V_cs
         LOG_ERROR_CONT('("phi_cs,den",2ES15.6)') gs%IS(i,n)%phi_cs,gs%MS(i,n)%den
         LOG_ERROR_CONT('("psi_ic,phi_ic,alen",3ES15.6)') gs%IS(i,n)%psi_ic,gs%IS(i,n)%phi_ic,gs%MS(i,n)%a_len
         call PRC_abort
      end if
      ! c axis
      gs%MS(i,n)%dvoldt(iccr,pro_type)=-gs%MS(i,n)%c_len**3.0*gs%MS(i,n)%con/gs%dt
      ! d axis
      gs%MS(i,n)%dvoldt(idcr,pro_type)=-gs%IS(i,n)%d**3.0*gs%MS(i,n)%con/gs%dt
      ! ag axis
      gs%MS(i,n)%dvoldt(iag,pro_type)=-gs%IS(i,n)%ag**3.0*gs%MS(i,n)%con/gs%dt
      ! cg axis
      gs%MS(i,n)%dvoldt(icg,pro_type)=-gs%IS(i,n)%cg**3.0*gs%MS(i,n)%con/gs%dt
      ! number of extra ice crystals
      gs%MS(i,n)%dvoldt(inex,pro_type)=-gs%IS(i,n)%n_exice*gs%MS(i,n)%con/gs%dt

    end subroutine melt_all

  end subroutine melting_shedding

!!c  function auto_conversion(g,n) result( mtend)
!!c    ! This routine calculates the mixing ratio tendency of rain due
!!c    ! to autoconversion from cloud water. The proceedure follows Manton
!!c    ! and Cotton (1977).
!!c    !
!!c    ! This process implicitely includes vapor depositional growth
!!c    ! to rain, too.
!!c    !
!!c    type (Group), intent(in)        :: g
!!c    integer,intent(in)  :: n
!!c    ! collision efficiency for droplets
!!c    real(PS), parameter    :: Ec = 0.55
!!c    ! maximum possible diameter of cloud droplets
!!c    real(PS), parameter    :: Dcm = 2.0e-3
!!c    ! mean collision frequency
!!c    real(PS)               :: fc
!!c    ! tendency of a mass per a volume of cloud droplets
!!c    real(PS)               :: mtend
!!c
!!c    if( g%MS(1,n)%len > Dcm) then
!!c       fc = 0.5_PS*PI*(g%MS(1,n)%len**2.0)*Ec*g%MS(1,n)%vtm*g%MS(1,n)%con
!!c       mtend = fc * g%MS(1,n)%mass(1)
!!c    else
!!c       mtend = 0.0_PS
!!c    end if
!!c  end function auto_conversion

  subroutine cal_Coalescence_Efficiency(g_1,i,g_2,j,n,th_var,E_coal,&
       D_L,D_S,S_T,S_C,DS_S,CKE)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the coalescence efficiency.
    !
    ! Assumptions
    ! For liquid hydros: formula by Low and List (1982)
    ! For liquid and solid: 1.0
    ! For solids: 1.0 ( need to incorporate "sticking mechanism")
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(in)               :: g_1, g_2
    integer, intent(in)                    :: i, j,n
    type (Thermo_Var) :: th_var
    ! total coalescence efficiency
    real(PS)                    :: E_coal
    ! interlocking coalscence efficiency and sticking coalescence efficiency
    real(PS)                    :: E_int,E_stick
    ! diameter and velocity of large and small drops in SI units
    real(PS)                    :: D_L, D_S, V_L, V_S
    ! total energy of coalescence and collision kinetic energy in SI units
    real(PS)                    :: E_T, CKE
    real(PS)                    :: S_T, S_C, dS_S
    ! density of water (kg/m^3)
    real(PS), parameter         :: den_w = 1000.0D0
    real(PS), parameter         :: a = 0.778D0
    real(PS), parameter         :: b = 2.61d+6
    ! bulk density of hexagonal ice crystal calculated with circumscribing sphere
    !real(PS)        :: den_hex1,den_hex2
    ! low-diameter cut off related to the resolution of the experiments (cm)
    real(PS),parameter :: D_0=0.01D0
    ! mass limits for interlocking and stickiness efficiencies.
    ! This practically shut down aggregation process for massive particles.
!!c    real(PS),parameter :: mlimit_int=1.0,mlimit_stick=1.0
!!c    real(PS),parameter :: mlimit_int=1.0e-2,mlimit_stick=1.0
!!c    real(PS),parameter :: mlimit_int=1.0e-2,mlimit_stick=1.0e-2
    real(PS),parameter :: mlimit_int=1.0d-3,mlimit_stick=1.0d-2

    real (PS), parameter          :: stick_lmt = 0.5_PS

    ! equivalent lengths
    !real (PS) :: d1,d2

    ! reference density for polycrystals assuming phi=0.25
    real(PS),parameter :: den_hex_pol=0.259572D0


    if( g_1%token == 1 .and. g_2%token == 1 ) then
       ! define large diameter and small diameter (m)
       D_L = max( g_1%MS(i,n)%len, g_2%MS(j,n)%len ) * 1.0e-2
       D_S = min( g_1%MS(i,n)%len, g_2%MS(j,n)%len ) * 1.0e-2

       if(min(D_L,D_S)*100.0<D_0) then
         E_coal=1.0_PS

       else

         ! define large and small terminal velocity (m/s)
         V_L = max( g_1%MS(i,n)%vtm, g_2%MS(j,n)%vtm ) * 1.0e-2
         V_S = min( g_1%MS(i,n)%vtm, g_2%MS(j,n)%vtm ) * 1.0e-2

         ! calculate the total surface energy of incident drops
         S_T = PI*th_var%sig_wa*1.0e-3_DS*( D_L**2.0 + D_S**2.0)

         ! calculate the surface energy of the spherical equivalent of
         ! the united drop mass
         S_C = PI*th_var%sig_wa*1.0e-3_DS*( D_L**3.0 + D_S**3.0)**(2.0/3.0)

         ! decrease in surface energy
         dS_S = S_T - S_C

         ! calculate collision kinetic energy
         CKE = (den_w*PI/12.0_PS)*((V_L-V_S)**2.0)*&
              ((D_L*D_S)**3.0)/(D_L**3.0+D_S**3.0)

         ! calculate the total energy of coalescence
         E_T = CKE + dS_S

         if( E_T < 5.0e-6_PS ) then
            E_coal = a * ((1.0_PS + D_S/D_L)**(-2.0)) * &
               exp( - b*th_var%sig_wa*1.0e-3_DS*(E_T**2.0)/S_c)
         else
            E_coal = 0.0_PS
         end if

       end if

    else if(( g_1%token == 1 .and.  g_2%token == 2 ) .or. &
         ( g_1%token == 2 .and.  g_2%token == 1 ) .or. &
         ( g_1%token == 11 .and.  g_2%token == 2 ) .or. &
         ( g_1%token == 2 .and.  g_2%token == 11 ) ) then

!!c       if( g_1%MS(i,n)%mass(imw)/g_1%MS(i,n)%mass(1) >stick_lmt ) then

       if( T_0 <= th_var%T .and. &
           g_1%MS(i,n)%mass(imw)/g_1%MS(i,n)%mass(1)>stick_lmt .and. &
            (g_1%MS(i,n)%mass(imw)/g_1%MS(i,n)%con+g_2%MS(j,n)%mean_mass)/&
            (g_1%MS(i,n)%mean_mass+g_2%MS(j,n)%mean_mass)>stick_lmt ) then
!!c             T_0+5.0_PS <= th_var%T ) then
!!c
          E_coal = 0.0_PS
       else
          E_coal = 1.0_PS
       end if

    else if( g_1%token == 2 .and.  g_2%token == 2 ) then

       if( T_0 <= th_var%T .and. &
         (g_1%MS(i,n)%mass(imw)/g_1%MS(i,n)%mass(1)>stick_lmt.or.&
                 g_2%MS(j,n)%mass(imw)/g_2%MS(j,n)%mass(1)>stick_lmt).and.&
         (g_1%MS(i,n)%mass(imw)/g_1%MS(i,n)%con+g_2%MS(j,n)%mass(imw)/g_2%MS(j,n)%con)/&
                (g_1%MS(i,n)%mean_mass+g_2%MS(j,n)%mean_mass)>stick_lmt ) then

!!c       if( ( T_0 <= th_var%T .and. &
!!c         (g_1%MS(i,n)%mass(imw)+g_2%MS(j,n)%mass(imw))/(g_1%MS(i,n)%mass(1)+g_2%MS(j,n)%mass(1))>stick_lmt)) then
!!c                T_0+5.0_PS <= th_var%T ) then

!!c          ! define large diameter and small diameter (m)
!!c          d1=(g_1%MS(i,n)%mean_mass/coefpi6)**(1.0/3.0)
!!c          d2=(g_2%MS(j,n)%mean_mass/coefpi6)**(1.0/3.0)
!!c          D_L = max(d1,d2) * 1.0e-2
!!c          D_S = min(d1,d2) * 1.0e-2
!!c
!!c          ! define large and small terminal velocity (m/s)
!!c          V_L = max( g_1%MS(i,n)%vtm, g_2%MS(j,n)%vtm ) * 1.0e-2
!!c          V_S = min( g_1%MS(i,n)%vtm, g_2%MS(j,n)%vtm ) * 1.0e-2
!!c
!!c          ! calculate the total surface energy of incident drops
!!c          S_T = PI*th_var%sig_wa*1.0e-3_DS*( D_L**2.0 + D_S**2.0)
!!c
!!c          ! calculate the surface energy of the spherical equivalent of
!!c          ! the united drop mass
!!c          S_C = PI*th_var%sig_wa*1.0e-3_DS*( D_L**3.0 + D_S**3.0)**(2.0/3.0)
!!c
!!c          ! decrease in surface energy
!!c          dS_S = S_T - S_C
!!c
!!c          ! calculate collision kinetic energy
!!c          CKE = (den_w*PI/12.0_PS)*((V_L-V_S)**2.0)*&
!!c               ((D_L*D_S)**3.0)/(D_L**3.0+D_S**3.0)
!!c
!!c          ! calculate the total energy of coalescence
!!c          E_T = CKE + dS_S
!!c
!!c          if( E_T < 5.0e-6_PS ) then
!!c             E_coal = a * ((1.0_PS + D_S/D_L)**(-2.0)) * &
!!c                  exp( - b*th_var%sig_wa*1.0e-3_DS*(E_T**2.0)/S_c)
!!c          else
!!c             E_coal = 0.0_PS
!!c          end if
!!c
!!c          if(min(D_L,D_S)*100.0<D_0) then
!!c             E_coal=1.0_PS
!!c          end if
          E_coal = 0.0_PS

       elseif( th_var%s_v(2)<0.0_PS.and.th_var%T<269.15_PS) then
          ! This is based on Hosler et al. (1957), JAS
          E_coal = 0.0_PS
       elseif((g_1%IS(i,n)%sh_type<=2.and.g_1%IS(i,n)%is_mod(2)==2).or.&
              (g_2%IS(j,n)%sh_type<=2.and.g_2%IS(j,n)%is_mod(2)==2)) then
          ! assume that either particle is a ice sphere, no aggregation.
          E_coal = 0.0_PS
!sheba       elseif((g_1%IS(i,n)%sh_type<=2.and.&
!sheba               g_1%IS(i,n)%phi_cs<5.0.and.g_1%IS(i,n)%phi_cs>0.1).or.&
!sheba              (g_2%IS(j,n)%sh_type<=2.and.&
!sheba               g_2%IS(j,n)%phi_cs<5.0.and.g_2%IS(j,n)%phi_cs>0.1)) then
!sheba          ! assume that either particle is a fat crystal, no aggregation.
!sheba          !   This was added for SHEBA simulation
!sheba          !   because aggregation produces low density.
!sheba          E_coal = 0.0_PS
       else
          ! assumptions
          ! 1. interlocking efficiency has a mass limit.
          !    Sensitivity of this assumption is high!
          !    The repulsive force by collision should be large enough for large
          !    massive hydrometeors, so interlocking may not work anymore, no matter
          !    how less dense it is.
          !
          !    This should be formulated in terms of densities, and collision kinetic
          !    energy as done for drops
          !
          E_int=0.0_PS
          E_stick=0.0_PS
          E_coal=0.0_PS
          if(g_1%IS(i,n)%sh_type<=4.and.g_2%IS(j,n)%sh_type<=4) then ! this is the best.

             if(g_1%IS(i,n)%habit<=2.and.g_2%IS(j,n)%habit<=2) then
                E_int=(g_1%IS(i,n)%psi_ic/0.9*g_1%IS(i,n)%V_cs+g_2%IS(j,n)%psi_ic/0.9*g_2%IS(j,n)%V_cs)/&
                        (g_1%IS(i,n)%V_cs+g_2%IS(j,n)%V_cs)
             endif
!                E_int=1.0
!!tmp             if(g_1%IS(i,n)%habit==4.or.g_2%IS(j,n)%habit==4 ) then
!!tmp                E_int=max(0.7,E_int)
!!tmp             end if

             ! assumptions
             ! 1. sticking efficiency has also mass limit.
             !    it makes graupels too large.
             !    The physical reason is that the stickness produced by
             !    thin layer of water may not be strong enough for large repulsive forces by
             !    collision between massive hydrometeors.
             !    The mass limit may be somewhat smaller than interlocking one.
             !
             !    This should be formulated in terms of temperature, and collision kinetic
             !    energy as done for drops
             !
             ! the formula is from Hallgren and Hosler (1960)
             !    85 um radius ice spheres colliding
             E_stick=10.0**(0.05*(min(273.15_PS,max(g_1%MS(i,n)%tmp,g_2%MS(j,n)%tmp))-273.15_PS)-0.5457)

!!c          E_stick=min(1.0_PS,exp(0.38_PS*(max(g_1%MS(i,n)%tmp,g_2%MS(j,n)%tmp)-273.15_PS)))
!!c           E_stick=min(1.0_PS,exp(0.38_PS*(th_var%T-273.15_PS)))

!!c             E_coal=1.0_PS
!!c             E_stick=0.4_PS
             E_coal=max(0.1_PS,min(1.0_PS,E_int+E_stick))
          end if

       end if

    end if
  end subroutine cal_Coalescence_Efficiency

  subroutine cal_breakup_dis_LL(g_1,i,j,imin_bk,jmin_bk,bu_tmass,bu_fd,&
                                xD_L,xD_S,xS_T,xS_C,xCKE)
    use mod_amps_utility, only: &
       getznorm2
    ! ************************************************************************************
    ! This formulation is the original version by Low and List (1982), JAS.
    ! ************************************************************************************
!!c    use com_amps
    ! number of bins for the liquid spectrum
    type (Group), intent(in)               :: g_1
    ! catching drop and catched one.
    integer,intent(in)   :: i,j
    integer,intent(in) :: imin_bk,jmin_bk!,imax_bk,jmax_bk
    real(PS),intent(inout) :: bu_fd(2,*),bu_tmass(*)  ! 2014/10 T. Hashino modify for KID
    ! number of breakup drops
    !real(PS), intent(in)                    :: N_break
    ! diameter of large and small drops in m
    real(PS)                    :: xD_L,xD_S
    ! total energy of coalescence and collision kinetic energy (J)
    real(PS),intent(in)                    :: xCKE
    ! total surface energy (J)
    real(PS),intent(in)         :: xS_T,xS_C
    ! decrease in the surface energy (J)
    !real(PS)                    :: xdS_S
    ! diameter of large and small drops in m
    real(DS)                    :: D_L,D_S
    ! decrease in the surface energy (J)
    !real(DS)                    :: dS_S
    ! calculate the surface energy of the spherical equivalent of
    ! the united drop mass
    real(PS) :: S_C
    ! Weber number
    real(DS)                    :: W1,W2
    ! total energy of coalescence and collision kinetic energy (J)
    real(DS)                   :: CKE
    ! total surface energy (J)
    real(DS)         :: S_T
!!c    ! breakup distribution
!!c    real(PS) :: BD(81,2,81,81)

    real(DS),parameter          :: CKE0=8.93d-7
    real(DS),parameter          :: W0=0.86D0
    ! fraction of breakup
    real(DS)                    :: R_f,R_s,R_d


    ! fit parameters
    real(DS) :: mu_lnf,sig_lnf,mu_sf,H_sf,mu_lns,sig_lns,&
         mu_lnd,sig_lnd,sig_ld,mu_ls,sig_ls,mu_ld,&
         H_lf,mu_lf,sig_lf,lin_mu_lnf,lin_mu_lnd,lin_mu_lns

    real(DS) :: H_lnf,H_lns,H_lnd,sig_sf,H_ls,H_ld,P_MODE



    ! average number of fragments
    real(DS) :: F_f,F_s,F_d

    real(DS) :: D_1,D_2,D_log1,D_log2!,dir_del,D_S0
    real(DS),parameter :: app=1.02d+4, bpp=2.83D0
    ! low-diameter cut off related to the resolution of the experiments (cm)
    real(DS),parameter :: D_0=0.01D0
    ! diameter and mass of a coalescenced drop
    real(DS)  :: D_coal, m_coal
    real(DS)  :: mrat!,m_L

    ! total mass of the fragments of a large drop by sheet and disk breakup
    !real(DS) :: M_ls,M_ld

    real(DS),dimension(g_1%N_BIN) :: dmass,dcon !,dmass_s

    real(DS),dimension(3,g_1%N_BIN) :: m_f,m_s,m_d,n_f,n_s,n_d
    real(DS) :: frag_mass!,m_Lfrag
!!c    real(DS) :: getznorm2

    integer :: ibin,ibin_coal,kk,i1d_pair

    real(DS) :: dum,sq_twod
    real(DS) :: c1,c2,a1,x1,x2




    sq_twod=sqrt(2.0_DS)

    D_L=xD_L
    D_S=xD_S
    S_C=xS_C
    CKE=xCKE
    S_T=xS_T
    S_C=xS_C
    ! convert SI units to CGS except W, dS_S, CKE
    D_L=D_L*100.0_DS
    D_S=D_S*100.0_DS

    D_coal=(D_L**3.0+D_S**3.0)**(1.0/3.0)
    m_coal=coedpi6*D_coal**3.0

!!c    if(min(D_L,D_S)<=D_0) return
    if(D_coal<=D_0) return

    ! calculate variables necessary to calculate the break up probability
    ! Weber number
    W1=CKE/S_C
    W2=CKE/S_T


    ! 1. Determine the fraction of collision-breakup types
    ! fraction of the filament breakup
    if(CKE>=CKE0) then
       R_f=1.11e-4_DS*CKE**(-0.654)
    else
       R_f=1.0_DS
    end if
    ! fraction of sheet breakup
    if(W2>=W0) then
       R_s=0.685_DS*(1.0_DS-dexp(-1.63_DS*(W2-W0)))
    else
       R_s=0.0_DS
    end if
    if(R_s+R_f>1.0_DS) then
       R_s=1.0_DS-R_f
       R_d=0.0_DS
    else
       ! fraction of disk breakup
       R_d=dmax1(1.0_DS-R_f-R_s,0.0_DS)
    end if


    ! 2. calculate average number of fragments per a collision
    ! filament breakup
    F_f=(-2.25e+4_DS*(D_L-0.403_DS)*(D_L-0.403_DS)-37.9_DS)*D_S**2.5+&
         9.67_DS*(D_L+0.170_DS)*(D_L+0.170_DS)+4.95_DS
!tmp    F_f=(-2.25e+4_DS*(D_L-0.403_DS)**2.0-37.9_DS)*D_S**2.5+&
!tmp         9.67_DS*(D_L+0.170_DS)**2.0+4.95_DS
!tmp    write(*,*) "ck break",F_f,D_L,D_S,bpp,app
!tempei 2012/10    D_S0=((F_f-2.0)/bpp)**(1.0/app)
    F_f=dmax1(2.0_DS,dmin1(F_f,app*D_S**bpp+2.0_DS))

    ! sheet breakup
    F_s=dmax1(5.0_DS*&
         ! erf((S_T-2.53e-6_DS)/1.85e-6_DS)
         (2.0_DS*getznorm2(sq_twod*(S_T-2.53e-6_DS)/1.85e-6_DS)-1.0_DS)&
         +6.0_DS,2.0_DS)

    ! disk breakup
    F_d=dmax1(297.5_DS+23.76_DS*dlog(CKE),2.0_DS)


!!c    write(*,120) D_L,D_S,F_f,F_S,F_D,R_f,R_s,R_d
120 format("DL,DS,Ff,Fs,Fd,Rf,Rs,Rd",8ES12.3)



    ! 3. Calculate the parameters for parents distribution
    H_lf=50.8_DS*D_L**(-0.718)
    H_sf=4.18_DS*D_S**(-1.17)
    H_ls=100.0_DS*exp(-3.25_DS*D_S)
    H_ld=1.58e-5_DS*CKE**(-1.22)


    mu_lf=D_L
    mu_sf=D_S
    mu_ls=D_L
    mu_ld=D_L*(1.0_DS-exp(-3.70_DS*(3.10_DS-CKE/S_C)))

    call cal_sig_sf(D_0,R_f,1.0_DS,H_lf,mu_lf,sig_lf)
    call cal_sig_sf(D_0,R_f,1.0_DS,H_sf,mu_sf,sig_sf)
    call cal_sig_sf(D_0,R_s,1.0_DS,H_ls,mu_ls,sig_ls)
    call cal_sig_sf(D_0,R_d,1.0_DS,H_ld,mu_ld,sig_ld)

    ! 4. calculate the parameters for fragment distribution
    lin_mu_lnf=0.241_DS*D_S+0.0129_DS
    if(D_S<=D_0) then
       P_mode=1.68e+5_DS*D_S**2.33
    elseif(D_S>=1.2_DS*D_0) then
!tmp       P_mode=(43.4_DS*(D_L+1.81_DS)**2.0-159.0_DS)/D_S&
!tmp            -3870.0_DS*(D_L-0.285_DS)**2.0-58.1_DS
       P_mode=(43.4_DS*(D_L+1.81_DS)*(D_L+1.81_DS)-159.0_DS)/D_S&
            -3870.0_DS*(D_L-0.285_DS)*(D_L-0.285_DS)-58.1_DS
    else
       dum=(D_S-D_0)/(0.2_DS*D_0)
       P_mode=dum*(1.68e+5_DS*D_S**2.33)+(1.0_DS-dum)*&
            ((43.4_DS*(D_L+1.81_DS)*(D_L+1.81_DS)-159.0_DS)/D_S&
            -3870.0_DS*(D_L-0.285_DS)*(D_L-0.285_DS)-58.1_DS)
!tmp            ((43.4_DS*(D_L+1.81_DS)**2.0-159.0_DS)/D_S&
!tmp            -3870.0_DS*(D_L-0.285_DS)**2.0-58.1_DS)
    end if
    call cal_Hmusig(D_0,R_f,lin_mu_lnf,P_mode,F_f-2.0_DS,H_lnf,mu_lnf,sig_lnf)


    lin_mu_lns=0.254_DS*D_S**0.413*exp((3.53_DS*D_S-2.51_DS)*(D_L-D_S))
    P_mode=0.23_DS*D_S**(-3.93)*D_L**(14.2_DS*exp(-17.2_DS*D_S))
    call cal_Hmusig(D_0,R_s,lin_mu_lns,P_mode,F_s-1.0_DS,H_lns,mu_lns,sig_lns)

    lin_mu_lnd=exp((-17.4_DS*D_S-0.671_DS)*(D_L-D_S))*D_S
    if(D_L-D_S<0.5.and.0.007*D_S**(-2.54)>100.0) then
      P_mode=0.0_DS
    else
      P_mode=8.84_DS*D_S**(-2.52)*(D_L-D_S)**(0.007*D_S**(-2.54))
    endif

!!c    write(*,*) "check P_mode",P_mode,D_S,D_L
    call cal_Hmusig(D_0,R_d,lin_mu_lnd,P_mode,F_d-1.0_DS,H_lnd,mu_lnd,sig_lnd)


!!c    ! modification of mean to conserve total mass
!!c    call mod_mean_normal(mu_lf,sig_sf)

    ! calculate the fragment number concentration for each bin of liquid spectrum.

    Do ibin=max(i,j)+1,g_1%N_BIN+1
       if(g_1%binb(ibin)>m_coal) then
          ibin_coal=ibin-1
          exit
       end if
    end do

!!c    if(i==32.and.j==22) then
!!c	  write(*,*) "here"
!!c	end if
!!c    write(*,*) "i,j",i,j


    dcon=0.0_DS
    dmass=0.0_DS
!!c    dmass_s=0.0_DS

    m_f=0.0_DS
    m_s=0.0_DS
    m_d=0.0_DS
    n_f=0.0_DS
    n_s=0.0_DS
    n_d=0.0_DS

    frag_mass=0.0_DS
!!c    Do ibin=1,ibin_coal
    Do ibin=1,g_1%N_BIN
!!c       write(*,*) ibin,ibin_coal
       D_log2=dlog( (g_1%binb(ibin+1)/coedpi6)**(1.0/3.0))
       D_log1=dlog( (g_1%binb(ibin)/coedpi6)**(1.0/3.0))
       D_2=(g_1%binb(ibin+1)/coedpi6)**(1.0/3.0)
       D_1=(g_1%binb(ibin)/coedpi6)**(1.0/3.0)


       ! concentration produced by breakup
       ! ------------ filament breakup -------------
       ! lognormal distribution of the fragment drops
       n_f(1,ibin)=dmax1(0.0_DS,H_lnf*sig_lnf*coedsq2p*(&
            getznorm2((dmin1(D_log2,dlog(D_coal))-mu_lnf)/sig_lnf)-&
            getznorm2((dmax1(D_log1,dlog(D_0))-mu_lnf)/sig_lnf)))

       ! normal distribution of the small parent drop
       n_f(2,ibin)=H_sf*sig_sf*coedsq2p*(&
            getznorm2((D_2-mu_sf)/sig_sf)-&
            getznorm2((D_1-mu_sf)/sig_sf))

       ! normal distribution of the large parent drop
       n_f(3,ibin)=H_lf*sig_lf*coedsq2p*(&
            getznorm2((D_2-mu_lf)/sig_lf)-&
            getznorm2((D_1-mu_lf)/sig_lf))


       ! ------------ sheet breakup -----------------
       ! lognormal distribution of the fragment drops
       n_s(1,ibin)=dmax1(0.0_DS,H_lns*sig_lns*coedsq2p*(&
            getznorm2((dmin1(D_log2,dlog(D_coal))-mu_lns)/sig_lns)-&
            getznorm2((dmax1(D_log1,dlog(D_0))-mu_lns)/sig_lns)))

       ! no distribution for the small parent drop
       n_s(2,ibin)=0.0_DS


       ! normal distribution of the large parent drop
       n_s(3,ibin)=H_ls*sig_ls*coedsq2p*(&
            getznorm2((D_2-mu_ls)/sig_ls)-&
            getznorm2((D_1-mu_ls)/sig_ls))
       ! ------------ disc breakup -----------------
       ! lognormal distribution of the fragment drops
       n_d(1,ibin)=dmax1(0.0_DS,H_lnd*sig_lnd*coedsq2p*(&
            getznorm2((dmin1(D_log2,dlog(D_coal))-mu_lnd)/sig_lnd)-&
            getznorm2((dmax1(D_log1,dlog(D_0))-mu_lnd)/sig_lnd)))

       ! no distribution of the small parent drop
       n_d(2,ibin)=0.0_DS

       ! normal distribution of the large parent drop
       n_d(3,ibin)=H_ld*sig_ld*coedsq2p*(&
            getznorm2((D_2-mu_ld)/sig_ld)-&
            getznorm2((D_1-mu_ld)/sig_ld))




       ! ------------ filament breakup -------------
       ! lognormal distribution of the fragment drops
!       m_f(1,ibin)=dmax1(0.0_DS,coedpi6*H_lnf*sig_lnf*coedsq2p*dexp(4.5_DS*sig_lnf**2.0+3.0_DS*mu_lnf)*(&
       m_f(1,ibin)=dmax1(0.0_DS,coedpi6*H_lnf*sig_lnf*coedsq2p*dexp(4.5_DS*sig_lnf*sig_lnf+3.0_DS*mu_lnf)*(&
            getznorm2((dmin1(D_log2,dlog(D_coal))-mu_lnf)/sig_lnf-3.0_DS*sig_lnf)-&
            getznorm2((dmax1(D_log1,dlog(D_0))-mu_lnf)/sig_lnf-3.0_DS*sig_lnf)))

       ! normal distribution of the small parent drop
       x1=(D_1-mu_sf)/sig_sf
       x2=(D_2-mu_sf)/sig_sf
       c1=sig_sf*(sig_sf*sig_sf*(x1*x1+2.0_DS)+3.0_DS*mu_sf*(sig_sf*x1+mu_sf))/coedsq2p
       c2=sig_sf*(sig_sf*sig_sf*(x2*x2+2.0_DS)+3.0_DS*mu_sf*(sig_sf*x2+mu_sf))/coedsq2p
!       c1=sig_sf*(sig_sf**2.0*(x1**2.0+2.0_DS)+3.0_DS*mu_sf*(sig_sf*x1+mu_sf))/coedsq2p
!       c2=sig_sf*(sig_sf**2.0*(x2**2.0+2.0_DS)+3.0_DS*mu_sf*(sig_sf*x2+mu_sf))/coedsq2p

!       a1=mu_sf*(3.0_DS*sig_sf**2.0+mu_sf**2.0)
       a1=mu_sf*(3.0_DS*sig_sf*sig_sf+mu_sf*mu_sf)
!       m_f(2,ibin)=coedpi6*H_sf*sig_sf*coedsq2p*(-c2*dexp(-x2**2.0/2.0_DS)+c1*dexp(-x1**2.0/2.0_DS)+&
!            a1*(getznorm2(x2)-getznorm2(x1)))
       m_f(2,ibin)=coedpi6*H_sf*sig_sf*coedsq2p*(-c2*dexp(-x2*x2/2.0_DS)+c1*dexp(-x1*x1/2.0_DS)+&
            a1*(getznorm2(x2)-getznorm2(x1)))


       ! normal distribution of the large parent drop
       x1=(D_1-mu_lf)/sig_lf
       x2=(D_2-mu_lf)/sig_lf
!       c1=sig_lf*(sig_lf**2.0*(x1**2.0+2.0_DS)+3.0_DS*mu_lf*(sig_lf*x1+mu_lf))/coedsq2p
!       c2=sig_lf*(sig_lf**2.0*(x2**2.0+2.0_DS)+3.0_DS*mu_lf*(sig_lf*x2+mu_lf))/coedsq2p
!       a1=mu_lf*(3.0_DS*sig_lf**2.0+mu_lf**2.0)
!       m_f(3,ibin)=coedpi6*H_lf*sig_lf*coedsq2p*(-c2*dexp(-x2**2.0/2.0_DS)+c1*dexp(-x1**2.0/2.0_DS)+&
!            a1*(getznorm2(x2)-getznorm2(x1)))

       c1=sig_lf*(sig_lf*sig_lf*(x1*x1+2.0_DS)+3.0_DS*mu_lf*(sig_lf*x1+mu_lf))/coedsq2p
       c2=sig_lf*(sig_lf*sig_lf*(x2*x2+2.0_DS)+3.0_DS*mu_lf*(sig_lf*x2+mu_lf))/coedsq2p
       a1=mu_lf*(3.0_DS*sig_lf*sig_lf+mu_lf*mu_lf)
       m_f(3,ibin)=coedpi6*H_lf*sig_lf*coedsq2p*(-c2*dexp(-x2*x2/2.0_DS)+c1*dexp(-x1*x1/2.0_DS)+&
            a1*(getznorm2(x2)-getznorm2(x1)))


       ! ------------ sheet breakup -----------------
       ! lognormal distribution of the fragment drops
!       m_s(1,ibin)=dmax1(0.0_DS,coedpi6*H_lns*sig_lns*coedsq2p*dexp(4.5_DS*sig_lns**2.0+3.0_DS*mu_lns)*(&
       m_s(1,ibin)=dmax1(0.0_DS,coedpi6*H_lns*sig_lns*coedsq2p*dexp(4.5_DS*sig_lns*sig_lns+3.0_DS*mu_lns)*(&
            getznorm2((dmin1(D_log2,dlog(D_coal))-mu_lns)/sig_lns-3.0_DS*sig_lns)-&
            getznorm2((dmax1(D_log1,dlog(D_0))-mu_lns)/sig_lns-3.0_DS*sig_lns)))
       ! for the small parent drop
       m_s(2,ibin)=0.0_DS

       ! normal distribution of the large parent drop
       x1=(D_1-mu_ls)/sig_ls
       x2=(D_2-mu_ls)/sig_ls
!       c1=sig_ls*(sig_ls**2.0*(x1**2.0+2.0_DS)+3.0_DS*mu_ls*(sig_ls*x1+mu_ls))/coedsq2p
!       c2=sig_ls*(sig_ls**2.0*(x2**2.0+2.0_DS)+3.0_DS*mu_ls*(sig_ls*x2+mu_ls))/coedsq2p
!       a1=mu_ls*(3.0_DS*sig_ls**2.0+mu_ls**2.0)
!       m_s(3,ibin)=coedpi6*H_ls*sig_ls*coedsq2p*(-c2*dexp(-x2**2.0/2.0_DS)+c1*dexp(-x1**2.0/2.0_DS)+&
       c1=sig_ls*(sig_ls*sig_ls*(x1*x1+2.0_DS)+3.0_DS*mu_ls*(sig_ls*x1+mu_ls))/coedsq2p
       c2=sig_ls*(sig_ls*sig_ls*(x2*x2+2.0_DS)+3.0_DS*mu_ls*(sig_ls*x2+mu_ls))/coedsq2p
       a1=mu_ls*(3.0_DS*sig_ls*sig_ls+mu_ls*mu_ls)
       m_s(3,ibin)=coedpi6*H_ls*sig_ls*coedsq2p*&
          (-c2*dexp(-x2*x2/2.0_DS)+c1*dexp(-x1*x1/2.0_DS)+&
            a1*(getznorm2(x2)-getznorm2(x1)))

       ! ------------ disc breakup -----------------
       ! lognormal distribution of the fragment drops
!       m_d(1,ibin)=dmax1(0.0_DS,coedpi6*H_lnd*sig_lnd*coedsq2p*dexp(4.5_DS*sig_lnd**2.0+3.0_DS*mu_lnd)*(&
       m_d(1,ibin)=dmax1(0.0_DS,coedpi6*H_lnd*sig_lnd*&
          coedsq2p*dexp(4.5_DS*sig_lnd*sig_lnd+3.0_DS*mu_lnd)*(&
            getznorm2((dmin1(D_log2,dlog(D_coal))-mu_lnd)/sig_lnd-3.0_DS*sig_lnd)-&
            getznorm2((dmax1(D_log1,dlog(D_0))-mu_lnd)/sig_lnd-3.0_DS*sig_lnd)))

       ! for the small drop
       m_d(2,ibin)=0.0

       ! normal distribution of the large parent drop
       x1=(D_1-mu_ld)/sig_ld
       x2=(D_2-mu_ld)/sig_ld
!       c1=sig_ld*(sig_ld**2.0*(x1**2.0+2.0_DS)+3.0_DS*mu_ld*(sig_ld*x1+mu_ld))/coedsq2p
!       c2=sig_ld*(sig_ld**2.0*(x2**2.0+2.0_DS)+3.0_DS*mu_ld*(sig_ld*x2+mu_ld))/coedsq2p
!       a1=mu_ld*(3.0_DS*sig_ld**2.0+mu_ld**2.0)
!       m_d(3,ibin)=coedpi6*H_ld*sig_ld*coedsq2p*(-c2*dexp(-x2**2.0/2.0_DS)+c1*dexp(-x1**2.0/2.0_DS)+&
!            a1*(getznorm2(x2)-getznorm2(x1)))

       c1=sig_ld*(sig_ld*sig_ld*(x1*x1+2.0_DS)+3.0_DS*mu_ld*(sig_ld*x1+mu_ld))/coedsq2p
       c2=sig_ld*(sig_ld*sig_ld*(x2*x2+2.0_DS)+3.0_DS*mu_ld*(sig_ld*x2+mu_ld))/coedsq2p
       a1=mu_ld*(3.0_DS*sig_ld*sig_ld+mu_ld*mu_ld)
       m_d(3,ibin)=coedpi6*H_ld*sig_ld*coedsq2p*&
            (-c2*dexp(-x2*x2/2.0_DS)+c1*dexp(-x1*x1/2.0_DS)+&
            a1*(getznorm2(x2)-getznorm2(x1)))

    end do

    Do ibin=1,g_1%N_BIN
       dmass(ibin)=R_f*(m_f(1,ibin)+m_f(2,ibin)+m_f(3,ibin))+&
            R_s*(m_s(1,ibin)+m_s(2,ibin)+m_s(3,ibin))+&
            R_d*(m_d(1,ibin)+m_d(2,ibin)+m_d(3,ibin))
       dcon(ibin)=R_f*(n_f(1,ibin)+n_f(2,ibin)+n_f(3,ibin))+&
            R_s*(n_s(1,ibin)+n_s(2,ibin)+n_s(3,ibin))+&
            R_d*(n_d(1,ibin)+n_d(2,ibin)+n_d(3,ibin))

!!c       dmass_s(ibin)=R_f*(m_f(1,ibin)*0.5_PS+m_f(2,ibin))+&
!!c            R_s*(m_s(1,ibin)*0.5_PS+m_s(2,ibin))+&
!!c            R_d*(m_d(1,ibin)+m_d(2,ibin)+m_d(3,ibin))


       if(dcon(ibin)<1.0e-100_DS.or.dmass(ibin)<1.0e-100_DS) then
          dcon(ibin)=0.0_DS
          dmass(ibin)=0.0_DS
       else
          if(dmass(ibin)/dcon(ibin)>g_1%binb(ibin+1).or.&
               dmass(ibin)/dcon(ibin)<g_1%binb(ibin))then
!!c             write(*,*) "here the bin shift needed",ibin,D_L*100.0_RP,D_S*100.0_RP
!!c             return
!!c             dcon(ibin)=2.0_DS*dmass(ibin)/(g_1%binb(ibin+1)+g_1%binb(ibin))
             dmass(ibin)=(g_1%binb(ibin+1)+g_1%binb(ibin))*0.5_DS*dcon(ibin)
          end if
       end if
    end do


    i1d_pair=j-jmin_bk+1+(i-imin_bk)*(1+i-imin_bk)/2
    bu_tmass(i1d_pair)=m_coal

    mrat=m_coal/sum(dmass)
    Do ibin=1,g_1%N_BIN
       kk=(i1d_pair-1)*g_1%N_BIN+ibin
       bu_fd(2,kk)=mrat*dcon(ibin)
       bu_fd(1,kk)=mrat*dmass(ibin)
!!c       bu_fd(3,kk)=
!!c       BD(ibin,2,i,j)=mrat*dcon(ibin)
!!c       BD(ibin,1,i,j)=mrat*dmass(ibin)
    end do

!tmp    write(*,*) "i1d_pair,kk",i1d_pair,kk

  end subroutine cal_breakup_dis_LL

  subroutine diag_t(T_a_r,ag,gr,gs,thil,mes_rc,flagp_r,flagp_s)
    use mod_amps_utility, only: cal_growth_mode_inl_vec,random_genvar
    ! **********************************************************************
    ! diagnose temperature from theta il and hydrometeor specific humidity
    ! **********************************************************************
    ! rain group, ice group
    type (Group), intent(inout) :: gr,gs
    ! thermo variable object
    type (AirGroup), intent(inout)  :: ag
    ! message from reality-check
    integer,dimension(*)   :: mes_rc
    ! theta il
    real(MP_KIND),dimension(*)  :: thil
    ! 3D coordinates
    !integer :: ID(*),JD(*),KD(*)
    !
    integer,intent(in)  :: flagp_r,flagp_s
    !
    real(PS),dimension(*),intent(inout) :: T_a_r

    integer :: n,i
    integer,dimension(LMAX) :: ierror1
    real(PS),dimension(LMAX) :: qr_0,qi_0
    real(PS) :: T_a0,til

    do n=1,ag%L
      qr_0(n)=0.0_PS
      qi_0(n)=0.0_PS
    enddo

    if(flagp_s>0) then
      do i=1,gs%N_BIN
        do n=1,ag%L
          if(mes_rc(n)==3.or.mes_rc(n)==4) then
            qi_0(n)=qi_0(n)+&
              max(0.0_PS,gs%MS(i,n)%mass(imt)-gs%MS(i,n)%mass(imat))
          end if
        enddo
      enddo
    endif

    if(flagp_r>0) then
      do i=1,gr%N_BIN
        do n=1,ag%L
          if(mes_rc(n)==2.or.mes_rc(n)==4) then
            qr_0(n)=qr_0(n)+&
              max(0.0_PS,gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))
          endif
        enddo
      enddo
    endif
    do n=1,ag%L

      qr_0(n)=qr_0(n)/ag%TV(n)%den
      qi_0(n)=qi_0(n)/ag%TV(n)%den

      ! +++ calculate T_il from thil +++
      til=thil(n)*(ag%TV(n)%P/p00)**(Racp)

      T_a0=ag%TV(n)%T
      T_a_r(n)=Til*(1.0_PS+(L_e*qr_0(n)+L_s*qi_0(n))/(c_pa*253.0_PS))

      ierror1(n)=0
      if(T_a_r(n)>=253.0_PS) then
        T_a_r(n)=0.5*(Til+sqrt(Til**2+4.0_PS*Til/c_pa*(L_e*qr_0(n)+L_s*qi_0(n))))
        if(T_a_r(n)<253.0_PS) then
          ierror1(n)=1
        end if
      endif
    enddo
!dbg    if(any(ierror1(1:ag%L)>0)) then
!dbg      do n=1,ag%L
!dbg        if(ierror1(n)>0) then
!dbg          write(*,*) "diag_t>something wrong for T_a_r",T_a_r(n),ag%TV(n)%T &
!dbg                   ,thil(n),ag%TV(n)%P,qr_0(n),qi_0(n)
!dbg        endif
!dbg      enddo
!dbg!     stop
!dbg    endif

!tmp       ! re-initialize thermo variables
!tmp       ag%TV(n)=make_thermo_var3(real(ag%TV(n)%rv,MP),real(ag%TV(n)%den*1.0e+3_PS,MP) &
!tmp              ,real(ag%TV(n)%P*1.0e-1_PS,MP),real(T_a_r,MP),real(ag%TV(n)%W*1.0e-2_PS,MP) &
!tmp              ,ag%estbar,ag%esitbar)
!tmp
!tmp       ! re-analyze the field flag
!tmp       if(qr_0>0.0_PS) then
!tmp          if(qi_0>0.0_PS) then
!tmp             mes_rc(n)=4
!tmp          else
!tmp             mes_rc(n)=2
!tmp          endif
!tmp       else
!tmp          if(qi_0>0.0_PS) then
!tmp             mes_rc(n)=3
!tmp          else
!tmp             mes_rc(n)=1
!tmp          endif
!tmp       endif

!!c       write(*,'("diag_T>k,i,j,inmlt_t,T_new,T_old",4I5,10ES15.6)') KD(n),ID(n),JD(n),inmlt_t,T_a_r,T_a0
  end subroutine diag_t

  subroutine diag_pq( g, ag, level, em0, mes_rc,&
       ID,JD,KD,rdsd,ihabit_gm_random, &
       eps_ap0,nu_aps,phi_aps,M_aps,&
       ap_sig_cp,ap_mean_cp,cdf_cp_0,isnrml,&
       icat,flagp,ap_lnsig,ap_mean)
    use scale_prc, only: &
       PRC_abort
    use class_Mass_Bin, only: &
       data1d_lut_big, &
       cal_meanmass_vec, &
       cal_mass_comp_ap, &
       cal_melt_index, &
       fix_mass_comp, &
       diag_sh_type_v6, &
       diag_pardis_ap
    use class_Thermo_Var, only: &
       get_sat_vapor_pres_lk
    use class_Ice_Shape, only: &
       ini_Ice_Shape_v4, &
       cal_Ice_Shape_v4, &
       diag_habit_v4
    use class_Group, only: &
       cal_den_aclen_vec, &
       cal_capacitance_vec, &
       cal_ventilation_coef_vec, &
       cal_growth_mode_vec, &
       cal_terminal_vel_vec, &
       cal_coef_vapdep2_vec, &
       cal_coef_vapdep_ap_vec, &
       cal_surface_temp2_vec
    use mod_amps_utility, only: &
       get_len_s1, &
       get_len_c2a, &
       get_len_s3,&
       random_genvar
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Diagnose physical quantities of each bin
    !
    ! NOTE: exceptional handling in each subroutine may be cut in real simulation
    !       because all the values are defined in construction of objects and
    !       not remembered by program for the next step.
    !
    ! - Generalized Gamma distribution (#/cm^4)
    !
    !      p(1): total concentration, N_t
    !      p(2): scaling parameter, D_n (slope=1/D_n)
    !      n(D) = (p(1)/p(2))*exp(-D/p(2))
    ! - constant-size distribution (#/cm^3)
    !
    !      p(1): total concentration, N_t
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)    :: g
    type (AirGroup),intent(inout)     :: ag

    ! +++ level of complexity
    ! level : 5 = 13 prognostic variables
    !       : 4 = 12 prognostic variables
    !       : 3 = 10 prognostic variables
    !       : 2 =  8 prognostic variables
    !       : 1 =  6 prognostic variables
    integer   :: level

    ! error message
    integer    :: em0
    integer,dimension(g%n_bin,g%L)    :: em,em2
    ! conditional var
    integer,dimension(g%n_bin,g%L)    :: icond1

!    integer,dimension(g%n_bin*g%L)    :: ierror

    ! current time
    !real(PS), intent(in) :: cur_time
    ! message from reality_check
     ! 0. vapor and hydrometeors do not exist.
     ! 1. vapor only. no hydrometeors.
     ! 2. vapor and liquid hydrometeors exist.
     ! 3. vapor and solid hydrometeoors exist.
     ! 4. vapor, liquid and solid hydrometeors exist.
!tmp    integer,pointer,dimension(:)   :: mes_rc
    integer,dimension(*)   :: mes_rc

    integer :: ID(*),JD(*),KD(*)

    ! prescribed mass solubility
    real(PS),intent(in)   :: eps_ap0
    real(PS),dimension(*),intent(in)  :: phi_aps
    real(PS),dimension(*),intent(in) :: nu_aps, m_aps

    ! category
    integer,intent(in),optional :: icat
    ! flag for prediction type
    integer,intent(in),optional :: flagp
    real(PS),optional :: ap_lnsig(*),ap_mean(*)
    real(PS),optional :: ap_sig_cp(*),ap_mean_cp(*)
    real(PS),optional :: cdf_cp_0(*)

    type(data1d_lut_big),intent(in),optional :: isnrml

    type(random_genvar),intent(inout) :: rdsd
    ! random generaion: 1, max frequency: 0
    integer, intent(in)           :: ihabit_gm_random


    real(PS),dimension(1+mxnmasscomp,g%n_bin,g%L) :: dum_mass

    ! semi axis lengths of ice crystal
    real(PS),dimension(g%n_bin,g%L) :: semi_a_i,semi_c_i

    real(PS) :: vice1,vice2!,den_ic

    ! length of s1, c2a, s3
    real(PS) :: xlen_s1,xlen_c2a,xlen_s3
    !
    ! optional status check
    !integer  :: var_Status

    ! phase of hydrometeor
    ! 1: liquid, 2: solid
    integer   :: phase

    ! minimum (maximum) volume of circumscribing sphere corresponds to 1 um (10cm) radius
    real(PS),parameter :: V_csmin=4.18879020478639d-12,V_csmax=4.18879020478639d+3
!!c    real(PS),parameter :: V_csmin=4.18879020478639e-12,V_csmax=4.18879020478639e+12

    ! minimum mass of hexagonal ice crystal with 1 um radius
    real(PS),parameter :: m_icmin=4.763209003d-12

    integer   :: i,j,n

    em0=0


    ! +++ mode of shape to calculate the ventilation coefficient
    !     and terminal velocity +++
    ! 1 : spheroid with a_len and c_len
    ! 2 : ice crystal model
    ! integer   :: mode


    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! determine the phase of hydrometeor
    if( g%token == 1 .or. g%token == 11 .or. g%token == 12) then
       phase = 1
    else if( g%token == 2 ) then
       phase = 2
    else if( g%token == 3 ) then
       phase = 3
    end if
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!tmp    write(*,*) "ck L, nrbin",g%L,g%N_BIN,g%token,phase


    !
    ! Initialization
    !
!    do in=1,g%n_bin*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

      em(i,n)=0
      icond1(i,n)=0

      g%MS(i,n)%den=1.0_PS

      g%MS(i,n)%len=0.0_PS
      g%MS(i,n)%semi_a=0.0_PS
      g%MS(i,n)%semi_c=0.0_PS

      g%MS(i,n)%inmlt=0
      g%MS(i,n)%inevp=0
      g%MS(i,n)%eps_map=eps_ap0

      g%MS(i,n)%vtm=0.0_PS
      g%MS(i,n)%Nre=0.0_PS

      g%MS(i,n)%fv=1.0_PS
      g%MS(i,n)%fh=1.0_PS
      g%MS(i,n)%fkn=1.0_PS
      g%MS(i,n)%fac=1.0_PS

      g%MS(i,n)%CAP=0.0_PS
      g%MS(i,n)%CAP_hex=0.0_PS

      g%MS(i,n)%coef(1)=0.0_PS
      g%MS(i,n)%coef(2)=0.0_PS
      g%MS(i,n)%r_crt=0.0_PS
      g%MS(i,n)%r_act=0.0_PS

      g%MS(i,n)%th00_cp=0.0_PS

      g%MS(i,n)%tmp = ag%TV(n)%T
      g%MS(i,n)%e_sat=get_sat_vapor_pres_lk(phase,g%MS(i,n)%tmp,ag%estbar,ag%esitbar)
    enddo
    enddo

!    do in=1,g%n_bin*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

      if(g%MS(i,n)%con>1.0e-30_PS.and.g%MS(i,n)%mass(1)>1.0e-30_PS) then
        ! +++ calculate mean mass +++
        call cal_meanmass_vec( g%MS(i,n),em(i,n))
        if(em(i,n)>0) then
          icond1(i,n)=1
          g%MS(i,n)%con=0.0_PS
          g%MS(i,n)%mass(1)=0.0_PS
          g%MS(i,n)%mean_mass=0.0_PS
        endif
      else
        icond1(i,n)=1
        g%MS(i,n)%con=0.0_PS
        g%MS(i,n)%mass(1)=0.0_PS
        g%MS(i,n)%mean_mass=0.0_PS
      endif
    enddo
    enddo
!    do j=1,g%N_masscom
!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN
       if(icond1(i,n)/=0) then
          do j=1,g%N_masscom
             g%MS(i,n)%mass(1+j)=0.0_PS
          enddo
       endif
    enddo
    enddo

    if( phase == 1 ) then

!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN

        if(icond1(i,n)==0) then

          ! +++ Diagnose the insoluble mass and soluble mass fraction +++
!!!          call cal_mass_comp_ap(g%token,level,eps_ap0,g%MS(i,n))
          g%MS(i,n)%mass(rmai)=max(g%MS(i,n)%mass(rmat)-g%MS(i,n)%mass(rmas),0.0_PS)
          g%MS(i,n)%eps_map=max(0.0_PS,min(1.0_PS,g%MS(i,n)%mass(rmas)/g%MS(i,n)%mass(rmat)))

          ! +++ Diagnose the bulk density +++
!!!          call cal_bulk_density_liq(level,g%MS(i,n)%mean_mass,g%MS(i,n)%mass(rmat)/g%MS(i,n)%con,&
!!!                                    g%MS(i,n)%den_ai,g%MS(i,n)%den_as,g%MS(i,n)%eps_map,&
!!!                                    g%MS(i,n)%den)

          ! +++ Diagnose the a and c lengths +++
!!!          call cal_aclen_liq( g%MS(i,n))
        endif
      enddo
      enddo


      call cal_den_aclen_vec(g,icond1)


      ! +++ Calculate terminal velocity +++
          ! always mode is 1 (spheroid assumption) for liquid.
          ! mode = 1
      call cal_terminal_vel_vec(phase,g,ag,icond1,1)

      ! +++ Calculate ventilation coefficient +++
      call cal_ventilation_coef_vec(phase,g,ag,icond1)

      ! +++ Calculate capacitance +++
      call cal_capacitance_vec(level,phase,g,ag,icond1)

      ! +++ precalculation for vapor deposition +++
      call cal_coef_vapdep2_vec(phase,g,ag,icond1,nu_aps,phi_aps,m_aps)


      ! +++ Calculate the surface temperature of each hydrometeor +++
      ! NOTE: in case of implementing this before riming process,
      !       temperature of solid hydrometeors will be underestimated.
      call cal_surface_temp2_vec( phase, g,ag,icond1)
!org      call cal_surface_temp_vec( phase, g,ag,icond1)

    else if( phase == 2 ) then
      ! --- diagnose the shape and habit of the solid hydrometeor ---

      ! +++ diagnose the shape of ice crystal +++
!      do j=1,1+g%N_masscom
!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
          if(icond1(i,n)==0) then
             do j=1,1+g%N_masscom
!!!            write(*,*) "ck dum_mass",i,n,g%MS(i,n)%mass(j),g%MS(i,n)%con
                dum_mass(j,i,n)=g%MS(i,n)%mass(j)/g%MS(i,n)%con
             enddo
          endif
       enddo
       enddo

       do n = 1, g%L
       do i = 1, g%N_BIN
          em(i,n)=0
          em2(i,n)=0
       end do
       end do
!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN

!        ierror(in)=0
          if(icond1(i,n)==0) then

             call cal_Ice_Shape_v4( level, ag%TV(n), g%IS(i,n),  &
                                    dum_mass(1,i,n), g%MS(i,n)%a_len, g%MS(i,n)%c_len,  &
                                    vice1,em(i,n))

             ! +++ diagnose the habit and length +++
             xlen_s1=get_len_s1(dum_mass(imc,i,n))
             xlen_c2a=get_len_c2a(dum_mass(imc,i,n))
             xlen_s3=get_len_s3(dum_mass(imc,i,n))

             call diag_habit_v4(level,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d, &
                                g%IS(i,n)%ag,g%IS(i,n)%cg,g%IS(i,n)%n_exice, &
                                xlen_s1,xlen_c2a,xlen_s3,g%IS(i,n)%r,g%IS(i,n)%e, &
                                g%IS(i,n)%gam_ic,g%IS(i,n)%eta_ic,vice2, &
                                semi_a_i(i,n),semi_c_i(i,n),g%IS(i,n)%habit)

             !if (g%IS(i,n)%n_exice>= 0.5_PS) then
             !  write(*,*) n, i, g%IS(i,n)%n_exice, g%IS(i,n)%habit
             !endif
             ! Obtain the volume of ice crystals
             g%IS(i,n)%V_ic=max(vice1,vice2)
             g%IS(i,n)%V_cs=min(V_csmax,max(g%IS(i,n)%V_cs,g%IS(i,n)%V_ic,dum_mass(imt,i,n)/den_i))

          ! +++ validate the geometry of the ice crytal retrived from database +++
!!!          call val_geo( level, g%IS(i,n), g%MS(i,n)%a_len, g%MS(i,n)%c_len, em2(i,n))

!dbg          if(g%MS(i,n)%c_len/g%MS(i,n)%a_len>2.0) then
!dbg            ierror(in)=2
!              write(*,*) "diag_pq 1, phi>2:",i,KD(n),ID(n),JD(n) &
!                ,g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%a_len,g%MS(i,n)%c_len
!dbg          endif

          else
             call ini_Ice_Shape_v4 (g%IS(i,n), g%MS(i,n)%a_len, g%MS(i,n)%c_len, &
                                    semi_a_i(i,n), semi_c_i(i,n))
          endif
       enddo
       enddo

      ! fix the mass and concentration components
!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
          if( em(i,n) == -1 ) then
            g%MS(i,n)%con=g%MS(i,n)%mass(1)/min(0.99*g%binb(i+1),max(dum_mass(1,i,n),1.01*g%binb(i)))
            g%MS(i,n)%mass(1)=dum_mass(1,i,n)*g%MS(i,n)%con
            if(g%MS(i,n)%con<=1.0e-30_PS.or.g%MS(i,n)%mass(1)<=1.0e-30_PS) then
              g%MS(i,n)%con=0.0_PS
              g%MS(i,n)%mass(1)=0.0_PS
              g%MS(i,n)%mean_mass=0.0_PS
              icond1(i,n)=1
            endif
          endif
        enddo
        enddo
!        do j=2,1+g%N_masscom
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
        do n = 1, g%L
        do i = 1, g%N_BIN
           if( em(i,n) == -1 ) then
              do j=2,1+g%N_masscom
                 g%MS(i,n)%mass(j)=dum_mass(j,i,n)*g%MS(i,n)%con
              end do
           endif
        enddo
        enddo
!        do in=1,g%n_bin*g%L
        do n = 1, g%L
        do i = 1, g%N_BIN
          if( em(i,n) == -1 ) then
            em(i,n)=0
          endif
        enddo
        enddo
!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
        do n = 1, g%L
        do i = 1, g%N_BIN

          if(em2(i,n)==1) then
            if(debug) write(*,100) g%IS(i,n)%a,g%IS(i,n)%c,g%MS(i,n)%a_len,g%MS(i,n)%c_len
100         format(" val_geo > the length for the mass components does not exists IS%a,IS%c,alen,clen:",4ES15.6)
         elseif(em2(i,n)==2) then
            if(debug) write(*,'("vice,psi,phi,alen,clen",5ES15.6)') g%IS(i,n)%V_ic,g%IS(i,n)%d/g%MS(i,n)%a_len &
                       ,g%IS(i,n)%c/g%MS(i,n)%a_len,g%MS(i,n)%a_len,g%MS(i,n)%c_len
          endif
          if( em2(i,n) >= 1 ) then
             LOG_ERROR("diag_pq",*) " diag_pq > something wrong in shape at:",i,n
             LOG_ERROR_CONT(*) "con",g%MS(i,n)%con
             LOG_ERROR_CONT(*) "mass comp",g%MS(i,n)%mass(1:1+g%N_masscom)
             call PRC_abort
          end if
        enddo
        enddo

!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
        do n = 1, g%L
        do i = 1, g%N_BIN
           if(icond1(i,n)==0) then
!          if(g%MS(i,n)%mass(1)<1.0e-30) then
!            write(*,*) "mass is 0:",i,n,em(in),em2(in),g%MS(i,n)%con,g%MS(i,n)%mass,&
!               g%IS(i,n)%v_cs,g%MS(i,n)%a_len,g%MS(i,n)%c_len,dum_mass(1:4,in)
!          endif

              ! +++ Diagnose the insoluble mass +++
              call cal_mass_comp_ap(g%token,level,eps_ap0,g%MS(i,n))

              ! +++ diagnose the melt index +++
              call cal_melt_index(level,ag%TV(n),g%MS(i,n),em(i,n))

              ! +++ fix the mass component +++
              call fix_mass_comp(level,g%MS(i,n),em(i,n))

           endif
        enddo
        enddo


      if(debug) then

!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
!          ierror(in)=0
            if(icond1(i,n)==0) then
               if(g%MS(i,n)%c_len/g%MS(i,n)%a_len>2.0) then
                  write(*,*) "diag_pq 2, phi>2:",i,KD(n),ID(n),JD(n), &
                       g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%a_len,g%MS(i,n)%c_len
               endif
            endif
         enddo
         enddo
      endif

!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        if(icond1(i,n)/=0) then
          g%IS(i,n)%sh_type=0
          g%IS(i,n)%is_mod(1)=0
          g%IS(i,n)%is_mod(2)=0

          g%IS(i,n)%semi_aip=0.0_PS
          g%IS(i,n)%semi_cip=0.0_PS
          g%IS(i,n)%phi_cs=0.0_PS
          g%IS(i,n)%V_cs=0.0_PS
          g%MS(i,n)%semi_a=0.0_PS
          g%MS(i,n)%semi_c=0.0_PS
          g%IS(i,n)%V_csw=0.0_PS

          g%MS(i,n)%den=0.0_PS
          g%IS(i,n)%den_ip=0.0_PS
          g%IS(i,n)%den_ic=0.0_PS


          g%IS(i,n)%growth_mode=0
          g%IS(i,n)%init_growth=0
        endif
      enddo
      enddo

!      do j=1,g%N_masscom
!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
         if(icond1(i,n)==0) then
            do j=1,g%N_masscom
               dum_mass(j,i,n)=g%MS(i,n)%mass(1+j)/g%MS(i,n)%mass(1)
            end do
         endif
      enddo
      enddo

!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        if(icond1(i,n)==0) then
          ! +++ Determine the type of solid hydrometeor +++
          call diag_sh_type_v6(level,dum_mass(1,i,n),&
                g%MS(i,n)%mean_mass*dum_mass(imf_m,i,n),&
                g%IS(i,n)%sh_type, g%IS(i,n)%is_mod)
        endif
      enddo
      enddo

      ! +++ calculate the dimension of a spheroid circumscribing
      !     the ice crystals +++
      call cal_cs_spheroid3_vec(g,icond1,semi_a_i,semi_c_i,1)

      if(debug) then
!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
!          ierror(in)=0
          if(icond1(i,n)==0) then
!tmp          if(i.eq.8.and.n.eq.60) then
!tmp            write(*,*) "diag_pq 3, check",i,n,g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%a_len,g%MS(i,n)%c_len &
!tmp              ,g%IS(i,n)%phi_cs,g%IS(i,n)%phi_ic,semi_a_i(i,n),semi_c_i(i,n)
!tmp          endif
            if(g%MS(i,n)%c_len/g%MS(i,n)%a_len>2.0) then
              write(*,*) "diag_pq 3, phi>2:",i,KD(n),ID(n),JD(n), &
                   g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%a_len,g%MS(i,n)%c_len , &
                   g%IS(i,n)%phi_cs,g%IS(i,n)%phi_ic,semi_a_i(i,n),semi_c_i(i,n)
            endif
          endif
        enddo
        enddo
      endif

      ! ++++ calculate bulk ( apparent density ) +++
      call cal_bulk_density3_vec(g,icond1,1,1)

      if(debug) then
!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
!          ierror(in)=0
          if(icond1(i,n)==0) then
!!!            if(g%MS(i,n)%c_len/g%MS(i,n)%a_len>2.0) then
            if(g%MS(i,n)%den<1.0e-2) then
!!!              write(*,*) "diag_pq 4, phi>2:",i,KD(n),ID(n),JD(n) &
              write(*,*) "diag_pq 4, den<1.0e-2:",i,KD(n),ID(n),JD(n),g%IS(i,n)%is_mod(2), &
                   g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%con,g%MS(i,n)%mass,g%MS(i,n)%a_len,g%MS(i,n)%c_len,  &
                   g%IS(i,n)%phi_cs,g%IS(i,n)%phi_ic,semi_a_i(i,n),semi_c_i(i,n), &
                   g%MS(i,n)%den,g%IS(i,n)%V_cs
            endif
          endif
        enddo
        enddo
      endif

      ! +++ Calculate terminal velocity +++
             ! mode is 1 (spheroid assumption) for ventilation calculation
             ! based on Chen and Lamb (1994).
             ! mode is 2 (real geometry) for collection calculation.
             ! mode = 1
      call cal_terminal_vel_vec(phase,g,ag,icond1,1)

      ! +++ Calculate ventilation coefficient +++
      call cal_ventilation_coef_vec(phase,g,ag,icond1)

      ! +++ Calculate capacitance +++
      call cal_capacitance_vec( level,phase,g,ag,icond1)

      ! +++ precalculation for vapor deposition +++
      call cal_coef_vapdep2_vec(phase,g,ag,icond1,nu_aps,phi_aps,m_aps)

      ! +++ Calculate the surface temperature of each hydrometeor +++
      ! NOTE: in case of implementing this before riming process,
      !       temperature of solid hydrometeors will be underestimated.
      call cal_surface_temp2_vec( phase, g,ag,icond1)
!org      call cal_surface_temp_vec( phase, g,ag,icond1)

      ! +++ Calculate terminal velocity +++
      ! mode = 2
      call cal_terminal_vel_vec(phase,g,ag,icond1,2)

      ! +++ determine the growth mode of ice crystals for vapor deposition +++
      call cal_growth_mode_vec(level,mes_rc,g,ag,icond1,rdsd,ihabit_gm_random)


    else if( phase == 3 ) then

!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN

        if(icond1(i,n)==0) then
          ! +++ Diagnose the insoluble mass +++
          call cal_mass_comp_ap(g%token,level,eps_ap0,g%MS(i,n))

          ! ++++ calculate bulk ( apparent density ) +++
          call cal_bulk_density_ap(level,g%token,g%MS(i,n)%den,&
                 g%MS(i,n)%mass(ams)/g%MS(i,n)%mass(amt),g%MS(i,n)%den_ai,g%MS(i,n)%den_as)
!tmp             write(*,*) "ck den",n,i,icat,g%MS(i,n)%den,g%MS(i,n)%mass

          ! +++ calculate mean diameter +++
          call diag_pardis_ap(icat,flagp,ap_lnsig,ap_mean,g%MS(i,n),em(i,n))
!tmp             write(*,'("af diag_p",3I5,10ES15.6)')  KD(n),ID(n),JD(n),g%MS(i,n)%p(1:2)


        endif
      enddo
      enddo

!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN

          if(em(i,n)==1) then
             LOG_ERROR("diag_pq",*) "This flag for aerosols not defined in diag_pardis_ap",flagp
            call PRC_abort
          elseif(em(i,n)==2) then
             LOG_ERROR("diag_pq",*) "This distribution type is not defined in diag_pardis_ap", &
                  g%MS(i,n)%dis_type
             call PRC_abort
          endif
       enddo
       enddo

      ! +++ update the nucleation growth mode +++
      ! +++ and cal coefficients for nucleation process++
      call cal_coef_vapdep_ap_vec(level,icat,mes_rc,g,ag,icond1)

    end if

  end subroutine diag_pq


  ! private procedures

  subroutine immersion_mode(gs,gr,ag,level,mes_rc,APSNAME,nu_aps,m_aps &
                           ,osm_nhs4,osm_sdch)
    use scale_prc, only: &
       PRC_abort
    use class_Mass_Bin, only: &
       data1d_lut
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! the nucleation scheme is a stochastic method based on Bigg(1953) and Orville
    ! and Kopp (1977).
    ! basically same as Reisin et al (1996)
    !
    ! IN budget is not considered here, though cloud droplets and rain contain
    ! IN inside.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! rain group
    type (Group), intent(inout)   :: gr
    ! aerosol group
    !type (Group), dimension(*)  :: ga
    type (AirGroup),intent(inout)  :: ag

    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc

    !integer :: ID(*),JD(*),KD(*)

    type(data1d_lut),intent(in) :: osm_nhs4,osm_sdch

    ! level of complexity
    integer, intent(in)           :: level
    ! chemical notation for aerosols
    character (len=16) :: APSNAME(*)
    real(PS),dimension(*) :: nu_aps,m_aps

    ! error message
    !integer :: em

    ! shifted-bin boundaries
    real(PS), dimension(mxnbin+1,gs%L,2)           :: binb3d
!    real(PS), pointer, dimension(:,:,:)           :: binb3d
    !
    ! change of total mass in the bin before mapping
    !real(PS)                                   :: temp_dM
    ! transferred total concentration and mass from bin to bin
    !real(PS)                                   :: trans_dN, trans_dM
    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
!    real(8), pointer, dimension(:,:)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,gs%L,1+mxnmasscomp)          :: new_M
!    real(8), pointer, dimension(:,:,:)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,gs%L,mxnnonmc)          :: new_Q
!    real(8), pointer, dimension(:,:,:)          :: new_Q

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd
!    real(PS), pointer, dimension(:,:)           :: Np
!    real(8), pointer, dimension(:,:)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd
!    real(PS), pointer, dimension(:,:)           :: Mp
!    real(8), pointer, dimension(:,:)           :: Mpd

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,gs%L,mxnmasscomp)      :: ratio_Mp
!    real(PS), pointer, dimension(:,:,:)      :: ratio_Mp

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
!tmp    real(PS), pointer, dimension(:)                     :: Qp
    real(PS), dimension(mxnbin+1,gs%L,mxnnonmc+2)             :: Qp
!    real(PS), pointer, dimension(:,:,:)             :: Qp

    ! ratio of each volume component mass to total volume in the shifted bin.
    ! argument 1 : volume by riming * concentration
    !          2 : volume by aggregation * concentration
!tmp    real(PS), pointer, dimension(:)        :: ratio_Vp
    real(PS), dimension(mxnvol)        :: ratio_Vp
!    real(PS), pointer, dimension(:)        :: ratio_Vp


    ! axis change of an ice crystal in shifted bins
!    real(PS), dimension(mxnbin+1,gs%L,2)            :: d_axis_len
!    real(PS), pointer, dimension(:,:,:)            :: d_axis_len

    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
!    real(8), pointer, dimension(:,:)                       :: new_mtend
    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend
!    real(PS), pointer, dimension(:,:)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,gs%L,mxnaxis-1) :: axr_p
!    real(PS), pointer, dimension(:,:,:) :: axr_p

    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
!    real(PS), pointer, dimension(:,:)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
!    integer, pointer, dimension(:,:)          :: habit_p
    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
!    real(PS), pointer, dimension(:,:)              :: asr_p
    ! type in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: type_p
!    integer, pointer, dimension(:,:)          :: type_p
    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
!    real(PS), pointer, dimension(:,:)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
!    real(PS), pointer, dimension(:,:)           :: n_exice_p
    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p
!    real(PS), pointer, dimension(:,:)           :: actINF_p

    ! concentration and mass to be moved into aerosol groups
    real(8),dimension(LMAX)            :: ap_dN, ap_dM
!    real(8), pointer, dimension(:)            :: ap_dN, ap_dM

    ! total number of sub-bins in a collector bin
    integer, dimension(LMAX)                   :: n_all

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,gs%L,4)           :: a2d
    real(8) :: a2d_0d(4)

    integer,dimension(mxnbin+1,LMAX)             :: error_number

    integer,dimension(LMAX) :: icycle_n
    integer,dimension(mxnbin+1,LMAX) :: icond3
!    integer,dimension((mxnbin+1),LMAX) :: ierror
    integer,dimension(LMAX,mxnbin) :: icond4

    real(PS),dimension(mxnbin,LMAX) :: mrat

    ! temperature of freezing
    real(PS), parameter           :: TF = 273.16
    ! K^{-1}
    ! Bigg's parameter
!!c    real(PS), parameter           :: A = 0.66
    ! Kaolinite by Diehl and Wurzler (2004)
    real(PS), parameter           :: A = 1.0

    ! cm^{-1}s^{-1}
    ! Bigg's parameter
!!c    real(PS), parameter           :: B = 1.0e-4

    ! Kaolinite by Diehl and Wurzler (2004)
    !real(PS), parameter           :: B = 6.15e-8
    !real(PS), parameter           :: B = 3.075e-6
    !real(PS), parameter           :: B = 6.15e-7
    !real(PS), parameter           :: B = 6.15e-6
    !real(PS), parameter           :: B = 1.6e-7 ! VF14
    !real(PS), parameter           :: B = 6.4e-8 ! VF14
    !real(PS), parameter           :: B = 4.7e-8 ! VF14
    real(PS), parameter           :: B = 3.2e-8 ! VF10
    !real(PS), parameter           :: B = 2.4e-7 ! VF10
    !real(PS), parameter           :: B = 1.6e-8 ! VF05
    !real(PS), parameter           :: B = 3.2e-9 ! VF1
    !real(PS), parameter           :: B = 6.15e-9
    ! Illite by Diehl and Wurzler (2004)
!!c    real(PS), parameter           :: B = 6.19e-5
    ! Montmorillonite by Diehl and Wurzler (2004)
!!c    real(PS), parameter           :: B = 3.23e-5
    ! Soot by Diehl and Wurzler (2004)
!!c    real(PS), parameter           :: B = 2.91e-9
    ! Pollen by Diehl and Wurzler (2004)
!!c    real(PS), parameter           :: B = 1.01e-2
    ! Leaf Litter by Diehl and Wurzler (2004)
!!c    real(PS), parameter           :: B = 4.38e-1
    ! Bacteria by Diehl and Wurzler (2004)
!!c    real(PS), parameter           :: B = 6.19
    ! HYBRID SOOT and KAOLINITE (Gijs de Boer)
!!c    real(PS), parameter           :: B = 3.22e-8
    ! HYBRID2 SOOT and KAOLINITE (T Hashino 0.75xKao+0.25*soot)
!!c    real(PS), parameter           :: B = 4.69e-8


    ! freezing temperature for pure and solution water
    real(PS),dimension(LMAX) :: TF0
    real(PS),dimension(mxnbin,LMAX) :: TF1
    ! liquid drops that don't freeze due to high salt concentration
    integer,dimension(mxnbin,LMAX) :: iufz

    real(PS)  :: dum1!,dum2,phi

    ! bin boundary modification factor.
    real(PS),parameter    :: bbmf=0.2

!!c    real(PS) :: totm_im
!!c    common/check/totm_im
    integer :: i_d_ge_b,i_b_ge_d

    integer  :: i,n,j,k!,var_Status
    ! type of process
    integer                       :: pro_type
    pro_type = 11

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!    ! start initializing pointers
!!    allocate(binb3d(mxnbin+1,gs%L,2))
!!    allocate(new_N(mxnbin,LMAX),new_M(mxnbin,gs%L,1+mxnmasscomp))
!!    allocate(new_Q(mxnbin,gs%L,mxnnonmc))
!!    allocate(Np(mxnbin+1,LMAX),Npd(mxnbin+1,LMAX))
!!    allocate(Mp(mxnbin+1,LMAX),Mpd(mxnbin+1,LMAX))
!!    allocate(ratio_Mp(mxnbin+1,gs%L,mxnmasscomp))
!!    allocate(Qp(mxnbin+1,gs%L,mxnnonmc+2))
!!    allocate(ratio_Vp(mxnvol))
!!    allocate(d_axis_len(mxnbin+1,gs%L,2))
!!    allocate(new_mtend(mxnbin,LMAX),mtend(mxnbin+1,LMAX))
!!    allocate(axr_p(mxnbin+1,gs%L,mxnaxis-1))
!!    allocate(den_ip_p(mxnbin+1,LMAX),den_ic_p(mxnbin+1,LMAX))
!!    allocate(asr_p(mxnbin+1,LMAX))
!!    allocate(type_p(mxnbin+1,LMAX))
!!    allocate(habit_p(mxnbin+1,LMAX))
!!    allocate(rag_p(mxnbin+1,LMAX),rcg_p(mxnbin+1,LMAX))
!!    allocate(n_exice_p(mxnbin+1,LMAX))
!!    allocate(actINF_p(mxnbin+1,LMAX))
!!    allocate(ap_dN(LMAX),ap_dM(LMAX))
!!    ! end of initialization of pointers

    !
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! freezing cloud droplets and rain drops
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!tmp    call allocate_immersion
!!c    write(*,*) "fin allocat"

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization

    new_N(:,:)=0.0_PS
    new_mtend(:,:)=0.0_PS

      ! calculate the shifted bin boundaries
    do n = 1, gr%L
    do i = 1, mxnbin
      binb3d(i,n,1)=gr%binb(i)
      binb3d(i,n,2)=gr%binb(i+1)
    enddo
    enddo

    mrat(:,:)=0.0e+0

    Np(:,:)=0.0_PS
    Mp(:,:)=0.0_PS
    Npd(:,:)=0.0d+0
    Mpd(:,:)=0.0d+0
    mtend(:,:)=0.0d+0

    icond3(:,:)=0
    error_number(:,:)=0

    new_M(:,:,:) = 0.0_PS

    new_Q(:,:,:) = 0.0_PS

    ratio_Mp(:,:,:) = 0.0_PS

!    d_axis_len(:,:,:) = 0.0_PS

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    do n=1,gr%L
      icycle_n(n)=1
      icond4(n,1)=0
      n_all(n)=gr%N_BIN
      ap_dN(n)=0.0d+0
      ap_dM(n)=0.0d+0

      if( mes_rc(n) /= 0.and.gr%mark_cm(n)/= 3 )  then
        ! if the group does not have any hydrometeors, skip.
        if( TF-ag%TV(n)%T >= 5.0_PS) then
          icycle_n(n)=0
          icond4(n,1)=1
       ! if( TF-ag%TV(n)%T_n >= 5.0_PS .and. ag%TV(n)%s_v_n(2)>=0.0_PS) then
! <<< 2015/01 T. Hashino try for Kid
!!!       if( TF-ag%TV(n)%T >= 5.0_PS .and. TF-ag%TV(n)%T <= 40.0_PS) then
! >>> 2015/01 T. Hashino try for Kid
        endif
      endif
    enddo

!!c    write(*,*) 'bf freez_dep2:',osm_nhs4%n,osm_nhs4%dx,osm_nhs4%xs

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate freezing depression
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_freez_dep2_vec(TF0,1,gr%L,ag,mrat,iufz,APSNAME,nu_aps,m_aps &
                           ,icond4,osm_nhs4,osm_sdch)

!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin

      icond3(i,n)=0
      icond4(n,i)=0
      mrat(i,n)=0.0
      if( icycle_n(n)==0.and.&
          gr%MS(i,n)%con > 1.0e-30_PS .and. &
          gr%MS(i,n)%mass(rmt) > 1.0e-30_PS .and. &
          gr%MS(i,n)%mean_mass > 1.0e-15_PS .and. &
          binb3d(i,n,1) > gs%binb(1) ) then    ! 2018/09 T.Hashino added to conserve ap mass
        icond3(i,n)=1
        icond4(n,i)=1

        mrat(i,n)=gr%MS(i,n)%mass(rmas)/(gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))
!!c        write(*,*) "ck mrat",i,n,mrat(in),gr%MS(i,n)%mass(rmt),gr%MS(i,n)%mass(rmat) &
!!c                    ,gr%MS(i,n)%mass(rmas)
      end if
    enddo
    enddo


!!c    write(*,*) 'bf freez_dep2-2:',osm_nhs4%n,osm_nhs4%dx,osm_nhs4%xs
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate freezing depression
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_freez_dep2_vec(TF1,gr%N_bin,gr%L,ag,mrat,iufz,APSNAME,nu_aps,m_aps &
                           ,icond4,osm_nhs4,osm_sdch)
    ! TF0(:) = 0.0d0
    ! TF1(:) = 0.0d0 ! remenber to turn off the T0 and T1 effect
    !do in=1,gr%N_bin*gr%L
    !  n=(in-1)/gr%N_bin+1
    !  i=in-(n-1)*gr%N_bin
    !  if (ag%TV(n)%T_n >= 173.16 .and. ag%TV(n)%T_n <= 273.16) then
    !    iufz(in) = 0
    !  else
    !    iufz(in) = 1
    !  endif
    !enddo

!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin

!      ierror(in)=0
      if(icond3(i,n)==1.and.iufz(i,n)==0) then
        dum1=min(exp(A*(TF-ag%TV(n)%T_n+TF1(i,n)-TF0(n)))*gr%dt,1.0e+20_RP)
        !dum1=min(exp(A*(TF-ag%TV(n)%T_n))*gr%dt,1.0e+20)

        ! the following is the original bigg formulation
!!c                dum2=min(exp(A*(TF-ag%TV(n)%T))*gr%dt,1.0e+20)
!!c                dum2=gr%MS(i,n)%con*(1.0-exp(-B*gr%MS(i,n)%mean_mass*dum2))

        Np(i,n)=gr%MS(i,n)%con*(1.0_RP-exp(-B*gr%MS(i,n)%mean_mass*dum1))
        Mp(i,n)=Np(i,n)*gr%MS(i,n)%mean_mass
        Npd(i,n)=Np(i,n)
        Mpd(i,n)=Mp(i,n)

        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! set up mass ratio
        ! assume that frozen drops are ice crystals.
        if(level<=3) then
          ratio_Mp(i,n,imc_m)=1.0_PS
        else
          ratio_Mp(i,n,imc_m)=1.0_PS
          ratio_Mp(i,n,imat_m)=gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
          ratio_Mp(i,n,imas_m)=gr%MS(i,n)%mass(rmas)/gr%MS(i,n)%mass(rmt)
          ratio_Mp(i,n,imai_m)=max(0.0_PS,ratio_Mp(i,n,imat_m)-ratio_Mp(i,n,imas_m))
          ratio_Mp(i,n,imf_m)=1.0_PS
        end if

        if(Np(i,n)<=1.0e-30.or.Mp(i,n)<=1.0e-30_RP) then
          ! case of un-frozen.
          icond3(i,n)=0
        endif
        if(Np(i,n)>1.0e+20.or.Mp(i,n)>1.0e+20_RP) then
          dum1=min(exp(A*(TF-ag%TV(n)%T_n+TF1(i,n)-TF0(n)))*gr%dt,1.0e+20_RP)
          LOG_ERROR("immersion_mode",*) "error in immersion mode rain",i,n,Np(i,n),Mp(i,n), &
                   gr%MS(i,n)%mean_mass,dum1,TF0(n),TF1(i,n),&
                   gr%MS(i,n)%con
          call PRC_abort
        endif
      elseif(iufz(i,n)==1) then
        ! case of un-frozen.
        icond3(i,n)=0
      endif
    enddo
    enddo

!!c                write(*,'("ibin,iufz,T,TF,TF0,TF1,TF1-TF0,np,np_n,molality",2I3,20ES15.6)') &
!!c                     i,iufz,ag%TV(n)%T,TF,TF0,TF1,TF1-TF0,NP,dum2,&
!!c                     1.0e+3/M_aps(1)*gr%MS(i,n)%mass(rmas)/(gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! set up length in shifted bins
    ! assume the length of rain drops stay the same after freezing.
    call assign_Qp_v3p_vec(Qp,level,gr,ag,icond3)

!    if(any(ierror(1:gr%N_bin*gr%L)>0)) then
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
!        if(ierror(in)>0) then
!          write(*,*) "error in qp",Qp(1:gs%N_nonmass,i,n)
!        endif
!      enddo
!      stop
!    end if
                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                !     5. ratio of each increased volume components to total volume
!!c                ratio_Vp=0.0_PS
!!c               call cal_ratio_vol( gs, level, Qp, ratio_Vp)
!!c                write(*,*) "bf calxxp"

                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                !     6. apparent density and others for the shifted bin
!org                call cal_xxx_p_v5(level, gs, i, n, Mp/Np,d_axis_len, Qp, ratio_Mp,&
!org                     den_ip_p,asr_p,type_p,&
!org                     den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
!org                     'immfrz')
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !     6. apparent density and others for the shifted bin
    call cal_xxx_p_v5_vec(level,gr%L, icond3, n_all, Mp, Np, &
                Qp, ratio_Mp, &
                den_ip_p,asr_p,type_p,&
                den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
                'immfrz')
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of parameters for linear distribution in the shifted bin
    call cal_lincubprms_vec(mxnbin+1,gr%N_BIN,gr%L,Npd,Mpd,binb3d  &
                       ,a2d,error_number,"imm_mod_1")

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! turn on the error_number flag for neglible concentration and mass
    !  since these do not have the properties diagnosed above.
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(icond3(i,n)==0) then
        error_number(i,n)=10
      endif
    enddo
    enddo

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! check of postgrowth method
    ! if post-growth linear method produce an error,
    ! post-growth lienar method with linear growth of bin limits is used.
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then
        dum1 = Mpd(i,n)/Npd(i,n)

        i_d_ge_b=0.5_PS*(1.0_PS+sign(1.0_PS,dum1-binb3d(i,n,2)))
        binb3d(i,n,2)=real(i_d_ge_b,PS_KIND)*dum1*(1.0_PS+bbmf) + &
                           (1.0-real(i_d_ge_b,PS_KIND))*binb3d(i,n,2)

        i_b_ge_d=0.5_PS*(1.0_PS+sign(1.0_PS,binb3d(i,n,1)-dum1))
        binb3d(i,n,1)=real(i_b_ge_d,PS_KIND)*max(gr%binb(1),dum1*(1.0_PS-bbmf)) + &
                           (1.0-real(i_b_ge_d,PS_KIND))*binb3d(i,n,1)

        a2d_0d(1) = a2d(i,n,1)
        a2d_0d(2) = a2d(i,n,2)
        a2d_0d(3) = a2d(i,n,3)
        a2d_0d(4) = a2d(i,n,4)
        call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                   binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                   error_number(i,n))
      endif
    enddo
    enddo

!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then

        Npd(i,n) = Mpd(i,n)/(0.5_PS*(gr%binb(i+1)+gr%binb(i)))
        Np(i,n)=Npd(i,n)

        a2d_0d(1) = a2d(i,n,1)
        a2d_0d(2) = a2d(i,n,2)
        a2d_0d(3) = a2d(i,n,3)
        a2d_0d(4) = a2d(i,n,4)
        call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                    binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                    error_number(i,n))
      endif
    enddo
    enddo

!    ierror(1:gr%N_BIN*gr%L)=0
!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then
         if ( debug ) then
            write(*,*) "Warning: Modified pre-growth linear method also does not work at" &
                 ,i,n
            write(*,*) "       : Ignored con and mass:",Np(i,n),Mp(i,n)
         end if
         error_number(i,n)=10
      endif
    enddo
    enddo
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!!      do n=1,g%L
!!!        if(ap_dN(n)<0.0.or.ap_dM(n)<0.0) then
!!!          write(*,*) "negative ap3:",i,n,ap_dn(n),ap_dm(n)
!!!        endif
!!!      enddo
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the mass tendency of shifted bin
    !   it is all 0.
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of transferred concentration and mass into original bins
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_transbin_vec(gs%token, &
                          gs%L,gs%N_masscom, &
                          gs%N_bin,gr%N_bin, &
                          gs%binb, &
                          error_number, &
                          a2d,binb3d,mtend, &
                          new_N,new_M,new_Q, &
                          new_mtend, &
                          ratio_Mp,den_ip_p,axr_p,spx_p, &
                          habit_p,den_ic_p, &
                          rag_p,rcg_p,n_exice_p, &
                          actINF_p, &
                          0)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!c             write(*,'("af callin",5I5,20ES15.6)') KD(k),ID(k),JD(k),i,em,&
!!c                        Np,Mp,shifted_bound(1:2),par(1:3)

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! add tendencies for aerosols into each categories by evaporation
!!nouse    call add_tendency_ap_vec(level,gr,ga,ag,icond3,3,ap_dN,ap_dM,'im1')
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate tendency for rain
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(icond3(i,n)==1) then

        gr%MS(i,n)%dcondt(pro_type) = -Np(i,n)/gr%dt
        gr%MS(i,n)%dmassdt(rmt,pro_type) = -Mp(i,n)/gr%dt

        if(level>=4) then
          gr%MS(i,n)%dmassdt(rmat,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                        gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
          gr%MS(i,n)%dmassdt(rmas,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                        gr%MS(i,n)%mass(rmas)/gr%MS(i,n)%mass(rmt)
          gr%MS(i,n)%dmassdt(rmai,pro_type)=&
                        gr%MS(i,n)%dmassdt(rmat,pro_type)-gr%MS(i,n)%dmassdt(rmas,pro_type)

        end if
      endif
    enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! assign tendency for ice category
!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin

      gs%MS(i,n)%dcondt(pro_type)=new_N(i,n)/gs%dt

!      ierror(in)=0
      if( new_N(i,n) < -1.0e+10 .or. new_N(i,n) > 1.0e+10) then
         LOG_ERROR("immersion_mode",*) "newN at immersion",n,(new_N(j,n),j=1,gs%N_BIN)
        call PRC_abort
      endif
    enddo
    enddo

!    do j = 1, (1+gs%N_masscom)
!      do in=1,gs%N_bin*gs%L
!        n=(in-1)/gs%N_bin+1
!        i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin
       do j = 1, (1+gs%N_masscom)
          gs%MS(i,n)%dmassdt(j,pro_type)=new_M(i,n,j)/gs%dt

!        ierror(in)=0
          if( new_M(i,n,j) < -1.0e+10_PS .or. new_M(i,n,j) > 1.0e+10_PS) then
             LOG_ERROR("immersion_mode",*) "immersion check 1"
             LOG_ERROR_CONT(*) n,i,(new_M(i,n,k),k=1,1+gs%N_masscom)
             call PRC_abort
          endif
       enddo
       enddo
    enddo

    do j=1,gs%N_nonmass
!      do in=1,gs%N_bin*gs%L
!        n=(in-1)/gs%N_bin+1
!        i=in-(n-1)*gs%N_bin
       do n = 1, gs%L
       do i = 1, gs%N_bin

        gs%MS(i,n)%dvoldt(j,pro_type)=new_Q(i,n,j)/gs%dt

!        ierror(in)=0
        if( new_Q(i,n,j) < -1.0e+10_PS .or. new_Q(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("immersion_mode",*) "immersion check 2"
           LOG_ERROR_CONT(*) n,i,(new_Q(i,n,k),k=1,gs%N_nonmass)
           call PRC_abort
        endif
      enddo
      enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!    ! start deallocating pointers
!!    deallocate(binb3d)
!!    deallocate(new_N,new_M)
!!    deallocate(new_Q)
!!    deallocate(Np,Npd)
!!    deallocate(Mp,Mpd)
!!    deallocate(ratio_Mp)
!!    deallocate(Qp)
!!    deallocate(ratio_Vp)
!!    deallocate(d_axis_len)
!!    deallocate(new_mtend,mtend)
!!    deallocate(axr_p)
!!    deallocate(den_ip_p,den_ic_p)
!!    deallocate(asr_p)
!!    deallocate(type_p)
!!    deallocate(habit_p)
!!    deallocate(rag_p,rcg_p)
!!    deallocate(n_exice_p)
!!    deallocate(actINF_p)
!!    deallocate(ap_dN,ap_dM)
!!    ! end of deallocation of pointers

!tmp    write(*,*) "bf deallo"
!tmp    call deallocate_immersion
!tmp    write(*,*) "af deallo"
!tmp  contains
!tmp    subroutine allocate_immersion
!tmp      integer :: item(11)
!tmp      item=0
!tmp      allocate( new_M(1+gs%N_masscom,gs%N_BIN), stat = item(1))
!tmp      allocate( new_Q(gs%N_nonmass,gs%N_BIN), stat = item(2))
!tmp      allocate( new_N(gs%N_BIN), stat = item(3))
!tmp      allocate( ratio_Mp(gs%N_masscom), stat = item(4))
!tmp      allocate( par(3), stat = item(5))
!tmp      allocate( Qp(gs%N_nonmass+2), stat = item(6))
!tmp      allocate( ratio_Vp(gs%N_vol), stat = item(7))
!tmp      allocate( d_axis_len(2), stat = item(8))
!tmp      allocate( new_mtend(gs%N_BIN), stat = item(9))
!tmp      allocate( shifted_bound(2), stat = item(10))
!tmp      allocate( axr_p(gs%N_axis-1), stat = item(11))
!tmp      if(any(item/=0) ) Stop 'Allocatation failed at immersion'
!tmp    end subroutine allocate_immersion
!tmp    subroutine deallocate_immersion
!tmp      integer :: item(11)
!tmp      item=0
!tmp      deallocate( axr_p, stat = item(11))
!tmp      nullify(axr_p)
!tmp      deallocate( shifted_bound, stat = item(10))
!tmp      nullify(shifted_bound)
!tmp      deallocate( new_mtend, stat = item(9))
!tmp      nullify(new_mtend)
!tmp      deallocate( d_axis_len, stat = item(8))
!tmp      nullify(d_axis_len)
!tmp      deallocate( ratio_Vp, stat = item(7))
!tmp      nullify(ratio_Vp)
!tmp      deallocate( Qp, stat = item(6))
!tmp      nullify(Qp)
!tmp      deallocate( par, stat = item(5))
!tmp      nullify(par)
!tmp      deallocate( ratio_Mp, stat = item(4))
!tmp      nullify(ratio_Mp)
!tmp      deallocate( new_N, stat = item(3))
!tmp      nullify(new_N)
!tmp      deallocate( new_Q, stat = item(2))
!tmp      nullify(new_Q)
!tmp      deallocate( new_M, stat = item(1))
!tmp      nullify(new_M)
!tmp      if(any(item/=0)) Stop 'Deallocatation failed at immersion'
!tmp    end subroutine deallocate_immersion
  end subroutine immersion_mode

  subroutine immersion_mode_KC04(gs,gr,ag,level,mes_rc,m_aps &
                                ,ap_sig_cp,ap_mean_cp,CRIC_RN_IMM,frac_dust &
                                )
    use scale_prc, only: &
       PRC_abort
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! the nucleation scheme is based on extended Classical Nucleation Theory
    ! by Khvorostyanov and Curry (2014)
    !
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! rain group
    type (Group), intent(inout)   :: gr
    ! aerosol group
    !type (Group), dimension(*)  :: ga
    type (AirGroup),intent(inout)  :: ag

    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc

    !integer :: ID(*),JD(*),KD(*)

    ! level of complexity
    integer, intent(in)           :: level
    ! chemical notation for aerosols
    !character (len=16) :: APSNAME(*)
    real(PS),dimension(*),intent(in) :: m_aps!,nu_aps,phi_aps
    real(PS),dimension(*),intent(in) :: ap_sig_cp,ap_mean_cp!,cdf_cp_180m0
    real(PS), intent(in) :: CRIC_RN_IMM, frac_dust

    ! error message
    !integer :: em

    ! shifted-bin boundaries
    real(PS), dimension(mxnbin+1,gs%L,2)           :: binb3d
!    real(PS), pointer, dimension(:,:,:)           :: binb3d
    !
    ! change of total mass in the bin before mapping
    !real(PS)                                   :: temp_dM
    ! transferred total concentration and mass from bin to bin
    !real(PS)                                   :: trans_dN, trans_dM
    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
!    real(8), pointer, dimension(:,:)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,gs%L,1+mxnmasscomp)          :: new_M
!    real(8), pointer, dimension(:,:,:)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,gs%L,mxnnonmc)          :: new_Q
!    real(8), pointer, dimension(:,:,:)          :: new_Q

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd
!    real(PS), pointer, dimension(:,:)           :: Np
!    real(8), pointer, dimension(:,:)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd
!    real(PS), pointer, dimension(:,:)           :: Mp
!    real(8), pointer, dimension(:,:)           :: Mpd

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,gs%L,mxnmasscomp)      :: ratio_Mp
!    real(PS), pointer, dimension(:,:,:)      :: ratio_Mp

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
!tmp    real(PS), pointer, dimension(:)                     :: Qp
    real(PS), dimension(mxnbin+1,gs%L,mxnnonmc+2)             :: Qp
!    real(PS), pointer, dimension(:,:,:)             :: Qp

    ! ratio of each volume component mass to total volume in the shifted bin.
    ! argument 1 : volume by riming * concentration
    !          2 : volume by aggregation * concentration
!tmp    real(PS), pointer, dimension(:)        :: ratio_Vp
    real(PS), dimension(mxnvol)        :: ratio_Vp
!    real(PS), pointer, dimension(:)        :: ratio_Vp


    ! axis change of an ice crystal in shifted bins
!    real(PS), dimension(mxnbin+1,gs%L)            :: d_axis_len
!    real(PS), pointer, dimension(:,:,:)            :: d_axis_len

    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
!    real(8), pointer, dimension(:,:)                       :: new_mtend
    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend
!    real(PS), pointer, dimension(:,:)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,gs%L,mxnaxis-1) :: axr_p
!    real(PS), pointer, dimension(:,:,:) :: axr_p

    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
!    real(PS), pointer, dimension(:,:)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
!    integer, pointer, dimension(:,:)          :: habit_p
    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
!    real(PS), pointer, dimension(:,:)              :: asr_p
    ! type in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: type_p
!    integer, pointer, dimension(:,:)          :: type_p
    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
!    real(PS), pointer, dimension(:,:)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
!    real(PS), pointer, dimension(:,:)           :: n_exice_p
    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p
!    real(PS), pointer, dimension(:,:)           :: actINF_p

    ! concentration and mass to be moved into aerosol groups
    real(8),dimension(LMAX)            :: ap_dN, ap_dM
!    real(8), pointer, dimension(:)           :: ap_dN, ap_dM

    ! total number of sub-bins in a collector bin
    integer, dimension(LMAX)                   :: n_all
!    integer, pointer, dimension(:)           :: n_all

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,gs%L,4)           :: a2d
    real(8) :: a2d_0d(4)

    integer,dimension(mxnbin+1,LMAX)             :: error_number

    integer,dimension(LMAX) :: icycle_n,icond_sum
    integer,dimension(mxnbin+1,LMAX) :: icond3
!    integer,dimension((mxnbin+1)*LMAX) :: ierror

    real(PS) :: mrat

    ! temperature of freezing
    real(PS), parameter           :: T_0 = 273.16

    real(PS) :: mean_mass_ap

    ! supersaturatrion over ice, mass of water, molality
    real(PS) :: molality
    real(PS) :: sigma_sv,sigma_is,sigma_iv,Bsv,Tc
    real(PS) :: Lmef,Gn,Hvfr,r_cr,r_d!,Hfhet
    ! contact parameter between ice and solution
    real(PS),parameter :: mis=0.52
    !
    real(PS),parameter :: Ceps=1.7e11
    ! elastic strain associated with the substrate [-]
    real(PS), parameter :: epsi=0.0
    ! bolzman constant [erg/K]
    real(PS),parameter :: ak=1.38e-16
    real(PS) :: dFact,dFcr1,dFac1,Aimm1,Aimm!,aJfhet,Swcr,dFcr
    real(PS),parameter :: alogcnv=2.30258509299405
    ! coefficient for immersion freezing:
    ! Aimm=coef_imm*T/r^2*sqrt(sig/kT)*sqrt(f)
    ! see equation (10) of Savre & Ekman (2014)
    real(PS),parameter :: coef_imm=1.36208874e+3
!!c    real(PS) :: coef_a,AA,sb,beta,r_n,rd_h
!!c    real(PS) :: den_ap
    !
    ! Gauss-quadrature method weights and nodes
    !
!!!    real(PS),parameter,dimension(5) :: x_gq=(/0.0,0.9061798459,0.5384693101 &
!!!                                             ,-0.9061798459,-0.5384693101 /)
!!!    real(PS),parameter,dimension(5) :: w_gq=(/0.5688888889,0.2369268851,0.4786286705 &
!!!                                             ,0.2369268851,0.4786286705 /)
!    real(PS),parameter,dimension(8) :: x_gq=&
!                (/-0.9602898565,-0.7966664774,-0.5255324099,-0.1834346425,&
!                   0.1834346425, 0.5255324099, 0.7966664774, 0.9602898565/)
!    real(PS),parameter,dimension(8) :: w_gq=&
!                (/ 0.1012285363, 0.2223810345, 0.3137066459, 0.3626837834,&
!                   0.3626837834, 0.3137066459, 0.2223810345, 0.1012285363/)
    real(PS),parameter,dimension(40) :: w_gq = (/0.004817653796123656, 0.011636585223421486, 0.01534368104372197, 0.022860204610427523, 0.028209344252646654, 0.03341413653303035, 0.038795611982134603, 0.04387757550900829, 0.048700736168824386, 0.05322740599328632, 0.05743966083129328, 0.06130624822181248, 0.06480401437895715, 0.06791204580435271, 0.07061164737201063, 0.07288658239595315, 0.07472316905785292, 0.07611036190063131, 0.07703981816424778, 0.07750594797842483, 0.07750594797842483, 0.07703981816424778, 0.07611036190063131, 0.07472316905785292, 0.07288658239595315, 0.07061164737201063, 0.06791204580435271, 0.06480401437895715, 0.06130624822181248, 0.05743966083129328, 0.05322740599328632, 0.048700736168824386, 0.04387757550900829, 0.038795611982134603, 0.03341413653303035, 0.028209344252646654, 0.022860204610427523, 0.01534368104372197, 0.011636585223421486, 0.004817653796123656/)

    real(PS),parameter,dimension(40) :: x_gq = (/-0.998242892194369, -0.9907278892919245, -0.977277059406946, -0.9579161898188518, -0.9328158132815395, -0.902101168229306, -0.8659603056567768, -0.8246110976324008, -0.7783048322990261, -0.7273182247387979, -0.6719566492471739, -0.6125538965992597, -0.5494671240345872, -0.48307580174619236, -0.4137792043667943, -0.3419940908253989, -0.26815218500726834, -0.1926975807013714, -0.11608407067525514, -0.03877241750605083, 0.03877241750605083, 0.11608407067525514, 0.1926975807013714, 0.26815218500726834, 0.3419940908253989, 0.4137792043667943, 0.48307580174619236, 0.5494671240345872, 0.6125538965992597, 0.6719566492471739, 0.7273182247387979, 0.7783048322990261, 0.8246110976324008, 0.8659603056567768, 0.902101168229306, 0.9328158132815395, 0.9579161898188518, 0.977277059406946, 0.9907278892919245, 0.998242892194369/)
    integer :: quadrature_loop

    ! geometrical factor
    real(PS),dimension(40) :: fgeo
    real(PS),dimension(40) :: th_gq,fncr
    real(PS) :: amis,pdf,f_gq,f_gqN,thmid
    !real(PS),parameter :: thmax=100.0_PS
    real(PS),parameter :: thmax=180.0_PS
    !
    real(PS)  :: dum1!,dum2,phi

    ! bin boundary modification factor.
    real(PS),parameter    :: bbmf=0.2

!!c    real(PS) :: totm_im
!!c    common/check/totm_im
    integer :: i_d_ge_b,i_b_ge_d

    integer  :: i,n,j,k,ica!,var_Status
    ! type of process
    integer                       :: pro_type
    pro_type = 11

    !
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!    ! start initializing pointers
!!    allocate(binb3d(mxnbin+1,gs%L,2))
!!    allocate(new_N(mxnbin,LMAX),new_M(mxnbin,gs%L,1+mxnmasscomp))
!!    allocate(new_Q(mxnbin,gs%L,mxnnonmc))
!!    allocate(Np(mxnbin+1,LMAX),Npd(mxnbin+1,LMAX))
!!    allocate(Mp(mxnbin+1,LMAX),Mpd(mxnbin+1,LMAX))
!!    allocate(ratio_Mp(mxnbin+1,gs%L,mxnmasscomp))
!!    allocate(Qp(mxnbin+1,gs%L,mxnnonmc+2))
!!    allocate(ratio_Vp(mxnvol))
!!    allocate(d_axis_len(mxnbin+1,gs%L))
!!    allocate(new_mtend(mxnbin,LMAX),mtend(mxnbin+1,LMAX))
!!    allocate(axr_p(mxnbin+1,gs%L,mxnaxis-1))
!!    allocate(den_ip_p(mxnbin+1,LMAX),den_ic_p(mxnbin+1,LMAX))
!!    allocate(asr_p(mxnbin+1,LMAX))
!!    allocate(type_p(mxnbin+1,LMAX))
!!    allocate(habit_p(mxnbin+1,LMAX))
!!    allocate(rag_p(mxnbin+1,LMAX),rcg_p(mxnbin+1,LMAX))
!!    allocate(n_exice_p(mxnbin+1,LMAX))
!!    allocate(actINF_p(mxnbin+1,LMAX))
!!    allocate(ap_dN(LMAX),ap_dM(LMAX))
!!    allocate(n_all(LMAX))
!!    ! end of initialization of pointers

    !
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! freezing cloud droplets and rain drops
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!tmp    call allocate_immersion
!!c    write(*,*) "fin allocat"

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization

    new_N(:,:)=0.0_PS
    new_mtend(:,:)=0.0_PS

    ! calculate the shifted bin boundaries
    do n = 1, gr%L
    do i = 1, mxnbin
      binb3d(i,n,1)=gr%binb(i)
      binb3d(i,n,2)=gr%binb(i+1)
    enddo
    enddo

    Np(:,:)=0.0_PS
    Mp(:,:)=0.0_PS
    Npd(:,:)=0.0d+0
    Mpd(:,:)=0.0d+0
    mtend(:,:)=0.0d+0

    icond3(:,:)=0
    error_number(:,:)=0

    new_M(:,:,:) = 0.0_PS

    new_Q(:,:,:) = 0.0_PS

    ratio_Mp(:,:,:) = 0.0_PS

!    d_axis_len(:,:,:) = 0.0_PS

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    do n=1,gr%L
      icycle_n(n)=1
      n_all(n)=gr%N_BIN
      ap_dN(n)=0.0d+0
      ap_dM(n)=0.0d+0

      if( mes_rc(n) /= 0.and.gr%mark_cm(n)/= 3 )  then
        ! if the group does not have any hydrometeors, skip.
        if( T_0>=ag%TV(n)%T) then
          icycle_n(n)=0
       ! if( TF-ag%TV(n)%T_n >= 5.0_PS .and. ag%TV(n)%s_v_n(2)>=0.0_PS) then
! <<< 2015/01 T. Hashino try for Kid
!!!       if( TF-ag%TV(n)%T >= 5.0_PS .and. TF-ag%TV(n)%T <= 40.0_PS) then
! >>> 2015/01 T. Hashino try for Kid
        endif
      endif
    enddo


!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin

      icond3(i,n)=0
      if( icycle_n(n)==0.and.&
          gr%MS(i,n)%con > 1.0e-30_PS .and. &
          gr%MS(i,n)%mass(rmt) > 1.0e-30_PS .and. &
          gr%MS(i,n)%mean_mass > 1.0e-15_PS .and. &
          binb3d(i,n,1) > gs%binb(1) ) then    ! 2018/09 T.Hashino added to conserve ap mass
!org          gr%MS(i,n)%r_crt < gr%MS(i,n)%a_len ) then
!try          gr%MS(i,n)%mean_mass > 1.0e-15_PS) then

        icond3(i,n)=1
      end if
!dbg      if( icycle_n(n)==0.and.&
!dbg          gr%MS(i,n)%con > 1.0e-30_PS .and. &
!dbg          gr%MS(i,n)%mass(rmt) > 1.0e-30_PS .and. &
!dbg          gr%MS(i,n)%mean_mass > 1.0e-15_PS ) then
!dbg        write(*,'("ck r_crt",2I5,2ES15.6)') i,n,gr%MS(i,n)%r_crt,gr%MS(i,n)%a_len
!dbg      endif
    enddo
    enddo


!!c    coef_a=2.0_PS/(den_w*R_v)

!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin

!      ierror(in)=0
      if(icond3(i,n)==1) then

        Tc=ag%TV(n)%T-T_0

        ! unit is now in cm
!!c        AA=coef_a*ag%TV(n)%sig_wa

        ! calculate density of mixed aerosols
!!c        den_ap=gr%MS(i,n)%den_ai/(1.0_PS-gr%MS(i,n)%eps_map*(1.0_PS-gr%MS(i,n)%den_ai/gr%MS(i,n)%den_as))

        ! BB defined by Khvorostyanov and Curry (unitless for beta=0.5)
        ica=1   ! assume that the solubility is the same as category 1
!!c        sb=nu_aps(ica)*gr%MS(i,n)%eps_map*M_W*den_ap/(M_aps(ica)*den_w)*phi_aps(ica)
!!c        beta=0.5

        ! dry aerosol radius in cm
        mean_mass_ap=gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%con

!!c        r_n=(mean_mass_ap/den_ap/coef4pi3)**(1.0/3.0)

        ! haze radius for the given S [cm]
!!c        rd_h=get_hazerad_anal(AA/ag%TV(n)%T,sb,beta,1.0+ag%TV(n)%s_v(1),r_n)

        ! molality [mol/kg]
        mrat=gr%MS(i,n)%mass(rmas)/max(1.0e-30_RP,gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))
        Molality=1.0e+3/M_aps(ica)*mrat

        ! surface tension between ice and air
        !   Hoose and Mohler (2012)
        sigma_iv=76.1_RP-0.155_RP*(ag%TV(n)%T-T_0)+28.5_RP+0.25_RP*(ag%TV(n)%T-T_0)
!           if(Tc>-36.0) then
!             sigma_iv=ag%TV(n)%sig_wa+(28.0+0.25*Tc)
!           else
!             sigma_iv=ag%TV(n)%sig_wa+189.081+13.1625*Tc+0.3469*Tc*Tc+3.125e-3*Tc*Tc*Tc
!           endif

        ! surface tension between solution and air
        !  for (NH4)2SO4
!           Bsv=2.353
!           sigma_sv=ag%TV(n)%sig_wa+Bsv*molality
           ! mass concentration by weight, Tabazadeh et al. 1997
!           dum1=mean_mass_ap*ga(ica)%MS(1,n)%eps_map/mw
!           sigma_sv=142.35-0.96525*dum1-ag%TV(n)%T*(0.22954-0.0033948*dum1)
        ! from table A1 of Chen 1994
        Bsv=2.17_RP/(M_w*1.0e-3_RP)
        sigma_sv=ag%TV(n)%sig_wa+Bsv*M_w*1.0e-3_RP*molality/(1.0_RP+M_w*1.0e-3_RP*molality)

        sigma_is=abs(sigma_sv-sigma_iv)

        ! effective latent heat of melting
        ! (8.8.12b)  in [erg/g]
        Lmef=(79.7_RP+0.463_RP*Tc)*4.1868e+7_RP

        ! G parameter
        Gn=R_u*ag%TV(n)%T/(M_w*Lmef)

        ! Hvfr parameter (no pressure term)
!!!        Hvfr=2.0*sigma_sv/(den_i*Lmef*rd_h)+Ceps*epsi*epsi/(den_i*Lmef)
        Hvfr=2.0_RP*sigma_sv/(den_i*Lmef*gr%MS(i,n)%a_len)+Ceps*epsi*epsi/(den_i*Lmef)
!org        Hvfr=0.0_PS  ! for immersion freezing

        ! critical radius of freezing
        r_cr=2.0_RP*sigma_is/(den_i*Lmef*(log(T_0/ag%TV(n)%T)+Gn*log(1.0+ag%TV(n)%s_v(1))-Hvfr))
!!!           write(*,*) "ck1-2:",(log(T_0/ag%TV(n)%T)+Gn*log(1.0+sw(n))-Hvfr)

        ! activation energy
        dFact=0.694e-12_RP*(1.0_RP+0.027_RP*(Tc+30.0_RP))
        if(Tc<=-30.0_RP) then
          dFact=dFact*exp(0.01_RP*(Tc+30.0_RP))
        endif

        ! insoluble aerosol radius [cm]
        r_d=max(1.0e-7_RP,(mean_mass_ap*(1.0_RP-gr%MS(i,n)%eps_map)/&
                      gr%MS(i,n)%den_ai/coef4pi3)**(1.0_RP/3.0_RP))

!org        if(r_cr>1.0e-10.and.gr%MS(i,n)%th00_cp<thmax) then
        if(r_cr>1.0e-10_RP.and.gr%MS(i,n)%th00_cp<thmax.and.&
!           r_d>0.25e-4) then
           r_d>CRIC_RN_IMM) then
          !
          ! The theta-PDF scheme based on Savre and Ekman (2014)
          !
          ! integration is done with Gauss Quadrature method
          ! geometrical factor under large limit of convex aerosol
          !
          thmid=0.5_RP*(gr%MS(i,n)%th00_cp+thmax)
          do quadrature_loop = 1, 40
            th_gq(quadrature_loop)=0.5_RP*(thmax-gr%MS(i,n)%th00_cp)*x_gq(quadrature_loop)+thmid  ! [deg]
          enddo

          f_gq=0.0_PS
          f_gqN=0.0_PS

          dFcr1=coef4pi3*sigma_is*r_cr*r_cr/(ak*ag%TV(n)%T)
          dFac1=dFact/(ak*ag%TV(n)%T)
          Aimm1=coef_imm*ag%TV(n)%T/(r_cr*r_cr)*sqrt(sigma_is/(ak*ag%TV(n)%T))

          do quadrature_loop = 1, 40
            amis=cos(th_gq(quadrature_loop)*coefpi180)
            ! geometrical factor under large limit of convex aerosol
            fgeo(quadrature_loop)=0.25*(2.0+amis)*(1.0-amis)*(1.0-amis)
            pdf=0.5*((th_gq(quadrature_loop)-ap_mean_cp(ica))/ap_sig_cp(ica))*((th_gq(quadrature_loop)-ap_mean_cp(ica))/ap_sig_cp(ica))
            Aimm=Aimm1*sqrt(fgeo(quadrature_loop))
            fncr(quadrature_loop)=(1.0-exp(-pi*r_d*r_d*Aimm*exp(-dFac1-dFcr1*fgeo(quadrature_loop))*gr%dt))*exp(-pdf)
            f_gq=f_gq+w_gq(quadrature_loop)*fncr(quadrature_loop)
            f_gqN=f_gqN+w_gq(quadrature_loop)*exp(-pdf)
          enddo

          !f_gq=f_gq/(coefsq2p*ap_sig_cp(ica)*cdf_cp_180m0(ica))
          f_gq=f_gq/f_gqN


!org           Chet=1.0e+28*r_d*r_d
!org           aJfhet=Chet*exp(-(dFcr+dFact)/(ak*ag%TV(n)%T))
!org           aJfhet=exp(alogcnv*(28.0+2.0*log10(r_d))-(dFcr+dFact)/(ak*ag%TV(n)%T))

!org          aJfhet=exp(alogcnv*(28.0+2.0*log10(r_d))-dFact/(ak*ag%TV(n)%T))*&
!org                 f_gq



!org          Np(i,n)=gr%MS(i,n)%con*min(1.0,aJfhet*gr%dt)
          Np(i,n)=gr%MS(i,n)%con*f_gq*frac_dust
          Mp(i,n)=Np(i,n)*gr%MS(i,n)%mean_mass
          Npd(i,n)=Np(i,n)
          Mpd(i,n)=Mp(i,n)

!          if(Np(i,n)>1.0e-30.and.Mp(i,n)>1.0e-30) then
!dbg            write(*,'("ck1,imm:",2I5,5ES15.6)') i,n,molality,ag%TV(n)%sig_wa,sigma_sv,sigma_iv,sigma_is
!dbg            write(*,'("ck2,imm:",2I5,7ES15.6)') i,n,ag%TV(n)%T,Lmef,Hvfr,Gn,r_cr,dFcr,dFact
!dbg            write(*,'("ck3,imm:",2I5,5ES15.6)') i,n,ag%TV(n)%s_v(1),r_d,aJfhet,Np(i,n),Mp(i,n)
!dbg            write(*,'("ck4,imm:",2I5,5ES15.6)') i,n,f_gq,dFcr1,thmax,thmid,gr%MS(i,n)%th00_cp
!dbg            write(*,'("ck5,imm:",2I5,5ES15.6)') i,n,w_gq(1:5)
!dbg            write(*,'("ck6,imm:",2I5,5ES15.6)') i,n,th_gq(1:5)
!dbg            write(*,'("ck7,imm:",2I5,5ES15.6)') i,n,fgeo(1:5)
!dbg            write(*,'("ck8,imm:",2I5,5ES15.6)') i,n,sqrt(fgeo(1:5))*Aimm1
!dbg            write(*,'("ck9,imm:",2I5,5ES15.6)') i,n,fncr(1:5)
!dbg            write(*,*) " :"
!          endif
        endif

        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! set up mass ratio
        ! assume that frozen drops are ice crystals.
        if(level<=3) then
          ratio_Mp(i,n,imc_m)=1.0_PS
        else
          ratio_Mp(i,n,imc_m)=1.0_PS
          ratio_Mp(i,n,imat_m)=gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
          ratio_Mp(i,n,imas_m)=gr%MS(i,n)%mass(rmas)/gr%MS(i,n)%mass(rmt)
          ratio_Mp(i,n,imai_m)=max(0.0_PS,ratio_Mp(i,n,imat_m)-ratio_Mp(i,n,imas_m))
          ratio_Mp(i,n,imf_m)=1.0_PS
        end if

        if(Np(i,n)<=1.0e-30_PS.or.Mp(i,n)<=1.0e-30_PS) then
          ! case of un-frozen.
          icond3(i,n)=0
        endif
        if( debug &
             .and. ( Np(i,n)>1.0e+20_PS.or.Mp(i,n)>1.0e+20_PS ) ) then
           write(*,*) "error in immersion mode rain",i,n,Np(i,n),Mp(i,n), &
                   gr%MS(i,n)%mean_mass,gr%MS(i,n)%con
        endif
      endif
    enddo
    enddo

    icond_sum(1:gr%L)=0
    do i=1,gr%N_bin
      do n=1,gr%L
        icond_sum(n)=icond_sum(n)+icond3(i,n)
      enddo
    enddo
    if(all(icond_sum(1:gr%L)==0)) then
!!       deallocate(binb3d)
!!       deallocate(new_N,new_M)
!!       deallocate(new_Q)
!!       deallocate(Np,Npd)
!!       deallocate(Mp,Mpd)
!!       deallocate(ratio_Mp)
!!       deallocate(Qp)
!!       deallocate(ratio_Vp)
!!       deallocate(d_axis_len)
!!       deallocate(new_mtend,mtend)
!!       deallocate(axr_p)
!!       deallocate(den_ip_p,den_ic_p)
!!       deallocate(asr_p)
!!       deallocate(type_p)
!!       deallocate(habit_p)
!!       deallocate(rag_p,rcg_p)
!!       deallocate(n_exice_p)
!!       deallocate(actINF_p)
!!       deallocate(ap_dN,ap_dM)
!!       deallocate(n_all)
       return
    endif

!!c                write(*,'("ibin,iufz,T,TF,TF0,TF1,TF1-TF0,np,np_n,molality",2I3,20ES15.6)') &
!!c                     i,iufz,ag%TV(n)%T,TF,TF0,TF1,TF1-TF0,NP,dum2,&
!!c                     1.0e+3/M_aps(1)*gr%MS(i,n)%mass(rmas)/(gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! set up length in shifted bins
    ! assume the length of rain drops stay the same after freezing.
    call assign_Qp_v3p_vec(Qp,level,gr,ag,icond3)

!    if(any(ierror(1:gr%N_bin*gr%L)>0)) then
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
!        if(ierror(in)>0) then
!          write(*,*) "error in qp",Qp(i,n,1:gs%N_nonmass)
!        endif
!      enddo
!      stop
!    end if
                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                !     5. ratio of each increased volume components to total volume
!!c                ratio_Vp=0.0_PS
!!c               call cal_ratio_vol( gs, level, Qp, ratio_Vp)
!!c                write(*,*) "bf calxxp"

                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                !     6. apparent density and others for the shifted bin
!org                call cal_xxx_p_v5(level, gs, i, n, Mp/Np,d_axis_len, Qp, ratio_Mp,&
!org                     den_ip_p,asr_p,type_p,&
!org                     den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
!org                     'immfrz')
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !     6. apparent density and others for the shifted bin
    call cal_xxx_p_v5_vec(level,gr%L, icond3, n_all, Mp, Np, &
                Qp, ratio_Mp, &
                den_ip_p,asr_p,type_p,&
                den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
                'immfrz_KC')
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of parameters for linear distribution in the shifted bin
    call cal_lincubprms_vec(mxnbin+1,gr%N_BIN,gr%L,Npd,Mpd,binb3d  &
                       ,a2d,error_number,"imm_mod_1")

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! turn on the error_number flag for neglible concentration and mass
    !  since these do not have the properties diagnosed above.
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(icond3(i,n)==0) then
        error_number(i,n)=10
      endif
    enddo
    enddo

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! check of postgrowth method
    ! if post-growth linear method produce an error,
    ! post-growth lienar method with linear growth of bin limits is used.
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then
        dum1 = Mpd(i,n)/Npd(i,n)

        i_d_ge_b=0.5_PS*(1.0_PS+sign(1.0_PS,dum1-binb3d(i,n,2)))
        binb3d(i,n,2)=real(i_d_ge_b,PS_KIND)*dum1*(1.0_PS+bbmf) + &
                           (1.0_PS-real(i_d_ge_b,PS_KIND))*binb3d(i,n,2)

        i_b_ge_d=0.5_PS*(1.0_PS+sign(1.0_PS,binb3d(i,n,1)-dum1))
        binb3d(i,n,1)=real(i_b_ge_d,PS_KIND)*max(gr%binb(1),dum1*(1.0_PS-bbmf)) + &
                           (1.0_PS-real(i_b_ge_d,PS_KIND))*binb3d(i,n,1)

        a2d_0d(1) = a2d(i,n,1)
        a2d_0d(2) = a2d(i,n,2)
        a2d_0d(3) = a2d(i,n,3)
        a2d_0d(4) = a2d(i,n,4)
        call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                   binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                   error_number(i,n))
      endif
    enddo
    enddo

!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then

        Npd(i,n) = Mpd(i,n)/(0.5_PS*(gr%binb(i+1)+gr%binb(i)))
        Np(i,n)=Npd(i,n)

        a2d_0d(1) = a2d(i,n,1)
        a2d_0d(2) = a2d(i,n,2)
        a2d_0d(3) = a2d(i,n,3)
        a2d_0d(4) = a2d(i,n,4)
        call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                    binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                    error_number(i,n))
      endif
    enddo
    enddo

!    ierror(1:gr%N_BIN*gr%L)=0
!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then
         if ( debug ) then
            write(*,*) "Warning: Modified pre-growth linear method also does not work at" &
                 ,i,n
            write(*,*) "       : Ignored con and mass:",Np(i,n),Mp(i,n)
         end if
         error_number(i,n)=10
      endif
    enddo
    enddo
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!!      do n=1,g%L
!!!        if(ap_dN(n)<0.0.or.ap_dM(n)<0.0) then
!!!          write(*,*) "negative ap3:",i,n,ap_dn(n),ap_dm(n)
!!!        endif
!!!      enddo
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the mass tendency of shifted bin
    !   it is all 0.
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of transferred concentration and mass into original bins
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_transbin_vec(gs%token &
                         ,gs%L,gs%N_masscom &
                         ,gs%N_bin,gr%N_bin &
                         ,real(gs%binb,PS_KIND) &
                         ,error_number &
                         ,a2d,binb3d,mtend &
                         ,new_N,new_M,new_Q &
                         ,new_mtend &
                         ,ratio_Mp,den_ip_p,axr_p,spx_p &
                         ,habit_p,den_ic_p &
                         ,rag_p,rcg_p,n_exice_p &
                         ,actINF_p &
                         ,0)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!c             write(*,'("af callin",5I5,20ES15.6)') KD(k),ID(k),JD(k),i,em,&
!!c                        Np,Mp,shifted_bound(1:2),par(1:3)

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! add tendencies for aerosols into each categories by evaporation
!!nouse    call add_tendency_ap_vec(level,gr,ga,ag,icond3,3,ap_dN,ap_dM,'im1kc')
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate tendency for rain
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(icond3(i,n)==1) then

        gr%MS(i,n)%dcondt(pro_type) = -Np(i,n)/gr%dt
        gr%MS(i,n)%dmassdt(rmt,pro_type) = -Mp(i,n)/gr%dt

        if(level>=4) then
          gr%MS(i,n)%dmassdt(rmat,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                        gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
          gr%MS(i,n)%dmassdt(rmas,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                        gr%MS(i,n)%mass(rmas)/gr%MS(i,n)%mass(rmt)
          gr%MS(i,n)%dmassdt(rmai,pro_type)=&
                        gr%MS(i,n)%dmassdt(rmat,pro_type)-gr%MS(i,n)%dmassdt(rmas,pro_type)

        end if
      endif
    enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! assign tendency for ice category
!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin

      gs%MS(i,n)%dcondt(pro_type)=new_N(i,n)/gs%dt

!      ierror(in)=0
      if( new_N(i,n) < -1.0e+10 .or. new_N(i,n) > 1.0e+10) then
         LOG_ERROR("immersion_mode_KC04",*) "newN at immersion",n,(new_N(j,n),j=1,gs%N_BIN)
         call PRC_abort
      endif
    enddo
    enddo

!    do j = 1, (1+gs%N_masscom)
!      do in=1,gs%N_bin*gs%L
!        n=(in-1)/gs%N_bin+1
!        i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin

       do j = 1, (1+gs%N_masscom)
        gs%MS(i,n)%dmassdt(j,pro_type)=new_M(i,n,j)/gs%dt

!        ierror(in)=0
        if( new_M(i,n,j) < -1.0e+10_PS .or. new_M(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("immersion_mode_KC04",*) "immersion check 1"
           LOG_ERROR_CONT(*) n,i,(new_M(i,n,k),k=1,1+gs%N_masscom)
           call PRC_abort
        endif
      enddo
      enddo
    enddo

    do j=1,gs%N_nonmass
!      do in=1,gs%N_bin*gs%L
!        n=(in-1)/gs%N_bin+1
!        i=in-(n-1)*gs%N_bin
       do n = 1, gs%L
       do i = 1, gs%N_bin

        gs%MS(i,n)%dvoldt(j,pro_type)=new_Q(i,n,j)/gs%dt

!        ierror(in)=0
        if( new_Q(i,n,j) < -1.0e+10_PS .or. new_Q(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("immersion_mode_KC04",*) "immersion check 2"
           LOG_ERROR_CONT(*) n,i,(new_Q(i,n,k),k=1,gs%N_nonmass)
            call PRC_abort
        endif
      enddo
      enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!!    ! start deallocating pointers
!!    deallocate(binb3d)
!!    deallocate(new_N,new_M)
!!    deallocate(new_Q)
!!    deallocate(Np,Npd)
!!    deallocate(Mp,Mpd)
!!    deallocate(ratio_Mp)
!!    deallocate(Qp)
!!    deallocate(ratio_Vp)
!!    deallocate(d_axis_len)
!!    deallocate(new_mtend,mtend)
!!    deallocate(axr_p)
!!    deallocate(den_ip_p,den_ic_p)
!!    deallocate(asr_p)
!!    deallocate(type_p)
!!    deallocate(habit_p)
!!    deallocate(rag_p,rcg_p)
!!    deallocate(n_exice_p)
!!    deallocate(actINF_p)
!!    deallocate(ap_dN,ap_dM)
!!    deallocate(n_all)
!!    ! end of deallocation of pointers

  end subroutine immersion_mode_KC04

  subroutine homfreez_mode(gs,gr,ag,level,mes_rc,APSNAME,nu_aps,m_aps &
                           ,osm_nhs4,osm_sdch)
    use scale_prc, only: &
       PRC_abort
    use class_Mass_Bin, only: &
       data1d_lut
    use mod_amps_utility, only: &
       cal_lincubprms_vec, &
       cal_linprms_vec_s, &
       cal_transbin_vec
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! Two options
    !   1. the homogeneous freezing of pure water is adopted from
    !      Heymsfield and Milosevich (1993).
    !      This scheme is for pure water, and solution effect is not included yet.
    !
    !   2. Koop (2002) 'water-activity criterion' approach
    !      Solution effects are consdiered.
    !
    ! IN budget is not considered here, though cloud droplets and rain contain
    ! IN inside.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! rain group
    type (Group), intent(inout)   :: gr
    ! aerosol group
    !type (Group), dimension(*)  :: ga
    type (AirGroup),intent(inout)  :: ag

    ! message from reality-check
!tmp    integer,pointer,dimension(:)  :: mes_rc
    integer,dimension(*)   :: mes_rc

    !integer :: ID(*),JD(*),KD(*)

    type(data1d_lut),intent(in) :: osm_nhs4,osm_sdch

    ! level of complexity
    integer, intent(in)           :: level
    ! chemical notation for aerosols
    character (len=16) :: APSNAME(*)
    real(PS),dimension(*) :: nu_aps,m_aps

    ! error message
    !integer :: em

    ! shifted-bin boundaries
    real(PS), dimension(mxnbin+1,gs%L,2)           :: binb3d
!    real(PS), pointer, dimension(:,:,:)           :: binb3d
    !
    ! change of total mass in the bin before mapping
    !real(PS)                                   :: temp_dM
    ! transferred total concentration and mass from bin to bin
    !real(PS)                                   :: trans_dN, trans_dM
    ! new total concentration after the time step in each original bin
    real(8), dimension(mxnbin,LMAX)            :: new_N
!    real(8), pointer, dimension(:,:)            :: new_N
    ! new total mass after the time step in each original bin
    ! argument 1 : total mass
    !          2 : total mass by riming
    !          3 : mass of representative ice crystals
    real(8), dimension(mxnbin,gs%L,1+mxnmasscomp)          :: new_M
!    real(8), pointer, dimension(:,:,:)          :: new_M

    ! new total non-mass variables after the time step in each original bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (r-axis length**3) * concentration
    !          6 : volume by riming * concentration
    !          7 : volume by aggregation * concentration
    real(8), dimension(mxnbin,gs%L,mxnnonmc)          :: new_Q
!    real(8), pointer, dimension(:,:,:)          :: new_Q

    ! new total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Np
    real(8), dimension(mxnbin+1,LMAX)           :: Npd
!    real(PS), pointer, dimension(:,:)           :: Np
!    real(8), pointer, dimension(:,:)           :: Npd

    ! new total mass in the shifted bin
    real(PS), dimension(mxnbin+1,LMAX)           :: Mp
    real(8), dimension(mxnbin+1,LMAX)           :: Mpd
!    real(PS), pointer, dimension(:,:)           :: Mp
!    real(8), pointer, dimension(:,:)           :: Mpd

    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,gr%L,mxnmasscomp)      :: ratio_Mp
!    real(PS), pointer, dimension(:,:,:)      :: ratio_Mp

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
    !          8 : semi major axis length
    !          9 : semi minor axis length
!tmp    real(PS), pointer, dimension(:)                     :: Qp
    real(PS), dimension(mxnbin+1,gr%L,mxnnonmc+2)             :: Qp
!    real(PS), pointer, dimension(:,:,:)             :: Qp

    ! ratio of each volume component mass to total volume in the shifted bin.
    ! argument 1 : volume by riming * concentration
    !          2 : volume by aggregation * concentration
!tmp    real(PS), pointer, dimension(:)        :: ratio_Vp
    real(PS), dimension(mxnvol)        :: ratio_Vp
!    real(PS), pointer, dimension(:)        :: ratio_Vp


    ! axis change of an ice crystal in shifted bins
!    real(PS), dimension(mxnbin+1,gr%L,2)            :: d_axis_len
!    real(PS), pointer, dimension(:,:,:)            :: d_axis_len

    ! averaged mass tendency after the time step
    real(8), dimension(mxnbin,LMAX)                       :: new_mtend
!    real(8), pointer, dimension(:,:)                       :: new_mtend
    ! mass tendency of shifted bin
    real(PS), dimension(mxnbin+1,LMAX)                     :: mtend
!    real(PS), pointer, dimension(:,:)                     :: mtend

    ! axis ratio of an ice crystal in a shifted bin
    ! 1: c/a, 2: d/a, 3: r/a, 4: e/a
    real(PS),dimension(mxnbin+1,gr%L,mxnaxis-1) :: axr_p
!    real(PS), pointer, dimension(:,:,:) :: axr_p

    ! bulk sphere density of dry ice particle, and bulk crystal density in the shifted bin.
    real(PS), dimension(mxnbin+1,LMAX)           :: den_ip_p,den_ic_p
!    real(PS), pointer, dimension(:,:)           :: den_ip_p,den_ic_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: habit_p
!    integer, pointer, dimension(:,:)          :: habit_p
    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,LMAX)              :: asr_p
!    real(PS), pointer, dimension(:,:)              :: asr_p
    ! type in shifted bin
    integer, dimension(mxnbin+1,LMAX)          :: type_p
!    integer, pointer, dimension(:,:)          :: type_p
    ! aspect ratio of circumscribing cylinder
    real(PS)              :: spx_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,LMAX)           :: rag_p,rcg_p
!    real(PS), pointer, dimension(:,:)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,LMAX)           :: n_exice_p
!    real(PS), pointer, dimension(:,:)           :: n_exice_p
    ! activated IN fraction for contact parameter diagnosis
    real(PS), dimension(mxnbin+1,LMAX)           :: actINF_p
!    real(PS), pointer, dimension(:,:)           :: actINF_p

    ! concentration and mass to be moved into aerosol groups
    real(8),dimension(LMAX)            :: ap_dN, ap_dM
!    real(8), pointer, dimension(:)            :: ap_dN, ap_dM

    ! total number of sub-bins in a collector bin
    integer, dimension(LMAX)                   :: n_all
!    integer, pointer, dimension(:)                   :: n_all

    ! parameter of distribution in each bin
    real(8), dimension(mxnbin+1,gr%L,4)           :: a2d
    real(8) :: a2d_0d(4)

    integer,dimension(mxnbin+1,LMAX)             :: error_number

    integer,dimension(LMAX) :: icycle_n
    integer,dimension(mxnbin+1,LMAX) :: icond3
!    integer,dimension((mxnbin+1)*LMAX) :: ierror
    !integer,dimension(LMAX,mxnbin) :: icond4

    real(PS),dimension(mxnbin,LMAX) :: mrat
    ! nucleation rate
    real(PS),dimension(mxnbin,LMAX) :: AJ

    ! temperature of freezing
    real(PS), parameter           :: TF = 273.16


    real(PS)  :: dum1!,dum2,phi

    ! bin boundary modification factor.
    real(PS),parameter    :: bbmf=0.2

!!c    real(PS) :: totm_im
!!c    common/check/totm_im
    integer :: i_d_ge_b,i_b_ge_d

    integer  :: i,n,j,k!,var_Status
    ! type of process
    integer                       :: pro_type
    pro_type = 12

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! freezing cloud droplets and rain drops
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!    ! start initializing pointers
!!    allocate(binb3d(mxnbin+1,gs%L,2))
!!    allocate(new_N(mxnbin,LMAX),new_M(mxnbin,gs%L,1+mxnmasscomp))
!!    allocate(new_Q(mxnbin,gs%L,mxnnonmc))
!!    allocate(Np(mxnbin+1,LMAX),Npd(mxnbin+1,LMAX))
!!    allocate(Mp(mxnbin+1,LMAX),Mpd(mxnbin+1,LMAX))
!!    allocate(ratio_Mp(mxnbin+1,gr%L,mxnmasscomp))
!!    allocate(Qp(mxnbin+1,gr%L,mxnnonmc+2))
!!    allocate(ratio_Vp(mxnvol))
!!    allocate(d_axis_len(mxnbin+1,gr%L,2))
!!    allocate(new_mtend(mxnbin,LMAX),mtend(mxnbin+1,LMAX))
!!    allocate(axr_p(mxnbin+1,gr%L,mxnaxis-1))
!!    allocate(den_ip_p(mxnbin+1,LMAX),den_ic_p(mxnbin+1,LMAX))
!!    allocate(asr_p(mxnbin+1,LMAX))
!!    allocate(type_p(mxnbin+1,LMAX))
!!    allocate(habit_p(mxnbin+1,LMAX))
!!    allocate(rag_p(mxnbin+1,LMAX),rcg_p(mxnbin+1,LMAX))
!!    allocate(n_exice_p(mxnbin+1,LMAX))
!!    allocate(actINF_p(mxnbin+1,LMAX))
!!    allocate(ap_dN(LMAX),ap_dM(LMAX))
!!    allocate(n_all(LMAX))
!!    ! end of initialization of pointers

!tmp    call allocate_immersion
!!c    write(*,*) "fin allocat"

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! initialization

    new_N(:,:)=0.0_PS
    new_mtend(:,:)=0.0_PS

    ! calculate the shifted bin boundaries
    do n = 1, gr%L
    do i = 1, mxnbin
       binb3d(i,n,1)=gr%binb(i)
       binb3d(i,n,2)=gr%binb(i+1)
    end do
    end do

    mrat(:,:)=0.0e+0
    AJ(:,:)=0.0

    Np(:,:)=0.0_PS
    Mp(:,:)=0.0_PS
    Npd(:,:)=0.0d+0
    Mpd(:,:)=0.0d+0
    mtend(:,:)=0.0d+0

    icond3(:,:)=0
    error_number(:,:)=0

    new_M(:,:,:) = 0.0_PS

    new_Q(:,:,:) = 0.0_PS

    ratio_Mp(:,:,:) = 0.0_PS

!    d_axis_len(:,:,:) = 0.0_PS

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    do n=1,gr%L
      icycle_n(n)=1
      n_all(n)=gr%N_BIN
      ap_dN(n)=0.0d+0
      ap_dM(n)=0.0d+0

      if( mes_rc(n) /= 0.and.gr%mark_cm(n)/= 3 )  then
        ! if the group does not have any hydrometeors, skip.
        if( TF-ag%TV(n)%T >= 30.0_PS) then
          icycle_n(n)=0
        endif
      endif
    enddo

!!c    write(*,*) 'bf freez_dep2:',osm_nhs4%n,osm_nhs4%dx,osm_nhs4%xs


!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin

      icond3(i,n)=0
      mrat(i,n)=0.0
      if( icycle_n(n)==0.and.&
          gr%MS(i,n)%con > 1.0e-30_PS .and. &
          gr%MS(i,n)%mass(rmt) > 1.0e-30_PS .and. &
          gr%MS(i,n)%mean_mass > 1.0e-15_PS .and. &
          binb3d(i,n,1) > gs%binb(1) ) then    ! 2018/09 T.Hashino added to conserve ap mass
        icond3(i,n)=1

        mrat(i,n)=gr%MS(i,n)%mass(rmas)/(gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))
!!c        write(*,*) "ck mrat",i,n,mrat(i,n),gr%MS(i,n)%mass(rmt),gr%MS(i,n)%mass(rmat) &
!!c                    ,gr%MS(i,n)%mass(rmas)
      end if
    enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! option 2: homogeneous freezing of solution
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_nucrat_koop_vec(AJ,gr%N_bin,gr%L,ag,mrat,APSNAME,nu_aps,m_aps &
                            ,icycle_n,osm_nhs4,osm_sdch)


!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin

!      ierror(in)=0
      if(icond3(i,n)==1) then


        ! get nucleation rate J (dum1)
        ! option 1: homogeneous freezing of pure water
!        Tc=max(gr%MS(i,n)%tmp-TF,-50.0)
!        dum1=10.0**(-606.3952-52.6611*Tc-1.7439*Tc**2.0-0.0265*Tc**3.0-1.536e-4*Tc**4.0)
!        dum2=gr%MS(i,n)%con*(1.0-exp(-gr%MS(i,n)%mean_mass*gr%dt*dum1))
!        Np(i,n)=gr%MS(i,n)%con*(1.0-exp(-gr%MS(i,n)%mean_mass*gr%dt*dum1))


        ! option 2:
        Np(i,n)=gr%MS(i,n)%con*(1.0-exp(-gr%MS(i,n)%mean_mass*gr%dt*AJ(i,n)))

        Mp(i,n)=Np(i,n)*gr%MS(i,n)%mean_mass
        Npd(i,n)=Np(i,n)
        Mpd(i,n)=Mp(i,n)

        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! set up mass ratio
        ! assume that frozen drops are ice crystals.
        if(level<=3) then
          ratio_Mp(i,n,imc_m)=1.0_PS
        else
          ratio_Mp(i,n,imc_m)=1.0_PS
          ratio_Mp(i,n,imat_m)=gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
          ratio_Mp(i,n,imas_m)=gr%MS(i,n)%mass(rmas)/gr%MS(i,n)%mass(rmt)
          ratio_Mp(i,n,imai_m)=max(0.0_PS,ratio_Mp(i,n,imat_m)-ratio_Mp(i,n,imas_m))
          ratio_Mp(i,n,imf_m)=1.0_PS
        end if

        if(Np(i,n)<=1.0e-30.or.Mp(i,n)<=1.0e-30) then
          ! case of un-frozen.
          icond3(i,n)=0
        endif
        if(Np(i,n)>1.0e+20.or.Mp(i,n)>1.0e+20) then
           LOG_ERROR("homfreez_mode",*) "error in homogeneous mode rain",i,n,Np(i,n),Mp(i,n), &
                   gr%MS(i,n)%mean_mass,AJ(i,n),&
                   gr%MS(i,n)%con
          call PRC_abort
        endif
      endif
    enddo
    enddo

!!c                write(*,'("ibin,iufz,T,TF,TF0,TF1,TF1-TF0,np,np_n,molality",2I3,20ES15.6)') &
!!c                     i,iufz,ag%TV(n)%T,TF,TF0,TF1,TF1-TF0,NP,dum2,&
!!c                     1.0e+3/M_aps(1)*gr%MS(i,n)%mass(rmas)/(gr%MS(i,n)%mass(rmt)-gr%MS(i,n)%mass(rmat))

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! set up length in shifted bins
    ! assume the length of rain drops stay the same after freezing.
    call assign_Qp_v3p_vec(Qp,level,gr,ag,icond3)

!    if(any(ierror(1:gr%N_bin*gr%L)>0)) then
!      do in=1,gr%N_bin*gr%L
!        n=(in-1)/gr%N_bin+1
!        i=in-(n-1)*gr%N_bin
!        if(ierror(in)>0) then
!          write(*,*) "error in qp",Qp(i,n,1:gs%N_nonmass)
!        endif
!      enddo
!      stop
!    end if
                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                !     5. ratio of each increased volume components to total volume
!!c                ratio_Vp=0.0_PS
!!c               call cal_ratio_vol( gs, level, Qp, ratio_Vp)
!!c                write(*,*) "bf calxxp"

                ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                !     6. apparent density and others for the shifted bin
!org                call cal_xxx_p_v5(level, gs, i, n, Mp/Np,d_axis_len, Qp, ratio_Mp,&
!org                     den_ip_p,asr_p,type_p,&
!org                     den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
!org                     'homfrz')
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !     6. apparent density and others for the shifted bin
    call cal_xxx_p_v5_vec(level,gr%L, icond3, n_all, Mp, Np, &
                Qp, ratio_Mp, &
                den_ip_p,asr_p,type_p,&
                den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
                'homfrz')
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of parameters for linear distribution in the shifted bin
    call cal_lincubprms_vec(mxnbin+1,gr%N_BIN,gr%L,Npd,Mpd,binb3d  &
                       ,a2d,error_number,"hom_mod_1")

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! turn on the error_number flag for neglible concentration and mass
    !  since these do not have the properties diagnosed above.
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(icond3(i,n)==0) then
        error_number(i,n)=10
      endif
    enddo
    enddo

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! check of postgrowth method
    ! if post-growth linear method produce an error,
    ! post-growth lienar method with linear growth of bin limits is used.
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then
        dum1 = Mpd(i,n)/Npd(i,n)

        i_d_ge_b=0.5_PS*(1.0_PS+sign(1.0_PS,dum1-binb3d(i,n,2)))
        binb3d(i,n,2)=real(i_d_ge_b,PS_KIND)*dum1*(1.0_PS+bbmf) + &
                           (1.0_PS-real(i_d_ge_b,PS_KIND))*binb3d(i,n,2)

        i_b_ge_d=0.5_PS*(1.0_PS+sign(1.0_PS,binb3d(i,n,1)-dum1))
        binb3d(i,n,1)=real(i_b_ge_d,PS_KIND)*max(gr%binb(1),dum1*(1.0_PS-bbmf)) + &
                           (1.0_PS-real(i_b_ge_d,PS_KIND))*binb3d(i,n,1)

        a2d_0d(1) = a2d(i,n,1)
        a2d_0d(2) = a2d(i,n,2)
        a2d_0d(3) = a2d(i,n,3)
        a2d_0d(4) = a2d(i,n,4)
        call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                   binb3d(i,n,1),binb3d(i,n,1),a2d_0d(:), &
                   error_number(i,n))
      endif
    enddo
    enddo

!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then

        Npd(i,n) = Mpd(i,n)/(0.5_PS*(gr%binb(i+1)+gr%binb(i)))
        Np(i,n)=Npd(i,n)

        a2d_0d(1) = a2d(i,n,1)
        a2d_0d(2) = a2d(i,n,2)
        a2d_0d(3) = a2d(i,n,3)
        a2d_0d(4) = a2d(i,n,4)
        call cal_linprms_vec_s(Npd(i,n),Mpd(i,n), &
                    binb3d(i,n,1),binb3d(i,n,2),a2d_0d(:), &
                    error_number(i,n))
      endif
    enddo
    enddo

!    ierror(1:gr%N_BIN*gr%L)=0
!    do in=1,gr%N_BIN*gr%L
!      n=(in-1)/gr%N_BIN+1
!      i=in-(n-1)*gr%N_BIN
    do n = 1, gr%L
    do i = 1, gr%N_BIN
      if(1<=error_number(i,n).and.error_number(i,n)<=4) then
         if ( debug ) then
            write(*,*) "Warning: Modified pre-growth linear method also does not work at" &
                 ,i,n
            write(*,*) "       : Ignored con and mass:",Np(i,n),Mp(i,n)
         end if
         error_number(i,n)=10
      endif
    enddo
    enddo
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!!      do n=1,g%L
!!!        if(ap_dN(n)<0.0.or.ap_dM(n)<0.0) then
!!!          write(*,*) "negative ap3:",i,n,ap_dn(n),ap_dm(n)
!!!        endif
!!!      enddo
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the mass tendency of shifted bin
    !   it is all 0.
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of transferred concentration and mass into original bins
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    call cal_transbin_vec(gs%token &
                         ,gs%L,gs%N_masscom &
                         ,gs%N_bin,gr%N_bin &
                         ,real(gs%binb,PS_KIND) &
                         ,error_number &
                         ,a2d,binb3d,mtend &
                         ,new_N,new_M,new_Q &
                         ,new_mtend &
                         ,ratio_Mp,den_ip_p,axr_p,spx_p &
                         ,habit_p,den_ic_p &
                         ,rag_p,rcg_p,n_exice_p &
                         ,actINF_p &
                         ,0)
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!c             write(*,'("af callin",5I5,20ES15.6)') KD(k),ID(k),JD(k),i,em,&
!!c                        Np,Mp,shifted_bound(1:2),par(1:3)

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! add tendencies for aerosols into each categories by evaporation
!!nouse    call add_tendency_ap_vec(level,gr,ga,ag,icond3,3,ap_dN,ap_dM,'im1')
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate tendency for rain
!    do in=1,gr%N_bin*gr%L
!      n=(in-1)/gr%N_bin+1
!      i=in-(n-1)*gr%N_bin
    do n = 1, gr%L
    do i = 1, gr%N_bin
      if(icond3(i,n)==1) then

        gr%MS(i,n)%dcondt(pro_type) = -Np(i,n)/gr%dt
        gr%MS(i,n)%dmassdt(rmt,pro_type) = -Mp(i,n)/gr%dt

        if(level>=4) then
          gr%MS(i,n)%dmassdt(rmat,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                        gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
          gr%MS(i,n)%dmassdt(rmas,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                        gr%MS(i,n)%mass(rmas)/gr%MS(i,n)%mass(rmt)
          gr%MS(i,n)%dmassdt(rmai,pro_type)=&
                        gr%MS(i,n)%dmassdt(rmat,pro_type)-gr%MS(i,n)%dmassdt(rmas,pro_type)

        end if
      endif
    enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! assign tendency for ice category
!    do in=1,gs%N_bin*gs%L
!      n=(in-1)/gs%N_bin+1
!      i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin

      gs%MS(i,n)%dcondt(pro_type)=new_N(i,n)/gs%dt

!      ierror(in)=0
      if( new_N(i,n) < -1.0e+10 .or. new_N(i,n) > 1.0e+10) then
         LOG_ERROR("homfreez_mode",*) "newN at homog freez",n,(new_N(j,n),j=1,gs%N_BIN)
         call PRC_abort
      endif
    enddo
    enddo

!    do j = 1, (1+gs%N_masscom)
!      do in=1,gs%N_bin*gs%L
!        n=(in-1)/gs%N_bin+1
!        i=in-(n-1)*gs%N_bin
    do n = 1, gs%L
    do i = 1, gs%N_bin
       do j = 1, (1+gs%N_masscom)

        gs%MS(i,n)%dmassdt(j,pro_type)=new_M(i,n,j)/gs%dt

!        ierror(in)=0
        if( new_M(i,n,j) < -1.0e+10_PS .or. new_M(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("homfreez_mode",*) "homog freez check 1"
           LOG_ERROR_CONT(*) n,i,(new_M(i,n,k),k=1,1+gs%N_masscom)
           call PRC_abort
        endif
      enddo
      enddo
    enddo

    do j=1,gs%N_nonmass
!      do in=1,gs%N_bin*gs%L
!        n=(in-1)/gs%N_bin+1
!        i=in-(n-1)*gs%N_bin
       do n = 1, gs%L
       do i = 1, gs%N_bin

        gs%MS(i,n)%dvoldt(j,pro_type)=new_Q(i,n,j)/gs%dt

!        ierror(in)=0
        if( new_Q(i,n,j) < -1.0e+10_PS .or. new_Q(i,n,j) > 1.0e+10_PS) then
           LOG_ERROR("homfreez_mode",*) "homog freez check 2"
           LOG_ERROR_CONT(*) n,i,(new_Q(i,n,k),k=1,gs%N_nonmass)
           call PRC_abort
        endif
      enddo
      enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!!    ! start deallocating pointers
!!    deallocate(binb3d)
!!    deallocate(new_N,new_M)
!!    deallocate(new_Q)
!!    deallocate(Np,Npd)
!!    deallocate(Mp,Mpd)
!!    deallocate(ratio_Mp)
!!    deallocate(Qp)
!!    deallocate(ratio_Vp)
!!    deallocate(d_axis_len)
!!    deallocate(new_mtend,mtend)
!!    deallocate(axr_p)
!!    deallocate(den_ip_p,den_ic_p)
!!    deallocate(asr_p)
!!    deallocate(type_p)
!!    deallocate(habit_p)
!!    deallocate(rag_p,rcg_p)
!!    deallocate(n_exice_p)
!!    deallocate(actINF_p)
!!    deallocate(ap_dN,ap_dM)
!!    deallocate(n_all)
!!    ! end of deallocation of pointers

!tmp    write(*,*) "bf deallo"
!tmp    call deallocate_immersion
!tmp    write(*,*) "af deallo"
!tmp  contains
!tmp    subroutine allocate_immersion
!tmp      integer :: item(11)
!tmp      item=0
!tmp      allocate( new_M(1+gs%N_masscom,gs%N_BIN), stat = item(1))
!tmp      allocate( new_Q(gs%N_nonmass,gs%N_BIN), stat = item(2))
!tmp      allocate( new_N(gs%N_BIN), stat = item(3))
!tmp      allocate( ratio_Mp(gs%N_masscom), stat = item(4))
!tmp      allocate( par(3), stat = item(5))
!tmp      allocate( Qp(gs%N_nonmass+2), stat = item(6))
!tmp      allocate( ratio_Vp(gs%N_vol), stat = item(7))
!tmp      allocate( d_axis_len(2), stat = item(8))
!tmp      allocate( new_mtend(gs%N_BIN), stat = item(9))
!tmp      allocate( shifted_bound(2), stat = item(10))
!tmp      allocate( axr_p(gs%N_axis-1), stat = item(11))
!tmp      if(any(item/=0) ) Stop 'Allocatation failed at immersion'
!tmp    end subroutine allocate_immersion
!tmp    subroutine deallocate_immersion
!tmp      integer :: item(11)
!tmp      item=0
!tmp      deallocate( axr_p, stat = item(11))
!tmp      nullify(axr_p)
!tmp      deallocate( shifted_bound, stat = item(10))
!tmp      nullify(shifted_bound)
!tmp      deallocate( new_mtend, stat = item(9))
!tmp      nullify(new_mtend)
!tmp      deallocate( d_axis_len, stat = item(8))
!tmp      nullify(d_axis_len)
!tmp      deallocate( ratio_Vp, stat = item(7))
!tmp      nullify(ratio_Vp)
!tmp      deallocate( Qp, stat = item(6))
!tmp      nullify(Qp)
!tmp      deallocate( par, stat = item(5))
!tmp      nullify(par)
!tmp      deallocate( ratio_Mp, stat = item(4))
!tmp      nullify(ratio_Mp)
!tmp      deallocate( new_N, stat = item(3))
!tmp      nullify(new_N)
!tmp      deallocate( new_Q, stat = item(2))
!tmp      nullify(new_Q)
!tmp      deallocate( new_M, stat = item(1))
!tmp      nullify(new_M)
!tmp      if(any(item/=0)) Stop 'Deallocatation failed at immersion'
!tmp    end subroutine deallocate_immersion
  end subroutine homfreez_mode

  subroutine add_simple_vec(nbin,L,icond,g,Np,Mp,ratio_Mp,new_N,new_M,new_Q,Qp)
    use scale_prc, only: &
       PRC_abort
    implicit none
    type (Group), intent(in)   :: g
    integer,intent(in) :: nbin,L
    integer,dimension(mxnbin+1,*),intent(in) :: icond
    real(PS),dimension(mxnbin+1,*),intent(inout) :: Np,Mp
    real(PS), dimension(mxnbin+1,L,mxnmasscomp)  :: ratio_Mp
    real(PS), dimension(mxnbin+1,L,mxnnonmc+2)   :: Qp
    real(8), dimension(mxnbin,*)                 :: new_N
    real(8), dimension(mxnbin,L,1+mxnmasscomp)   :: new_M
    real(8), dimension(mxnbin,L,mxnnonmc)        :: new_Q
    integer,dimension(nbin,L) :: jbin
    integer :: i,n,jj,j

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin
      jbin(i,n)=-1
      if(icond(i,n)==1) then
        if(g%binb(g%N_binb)<Mp(i,n)/Np(i,n)) then
          jbin(i,n)=g%N_BIN
        elseif(g%binb(1)>Mp(i,n)/Np(i,n)) then
          jbin(i,n)=1
        else
          jbin(i,n)=0
        endif
      endif
    enddo
    enddo
    do j=1,g%N_BIN
!      do in=1,nbin*L
!        n=(in-1)/nbin+1
!        i=in-(n-1)*nbin
       do n = 1, L
       do i = 1, nbin
        if(jbin(i,n)==0) then
          if(g%binb(j)<Mp(i,n)/Np(i,n).and.Mp(i,n)/Np(i,n)<=g%binb(j+1)) then
            jbin(i,n)=j
          end if
!!c          write(*,*) "ck addsimp",j,Mp(i,n)/Np(i,n),g%binb(j),g%binb(j+1),jbin(i,n)
        endif
      enddo
      enddo
    enddo

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
!OCL INDEPENDENT
    do n = 1, L
    do i= 1, nbin
      if(icond(i,n)==1) then
        j=jbin(i,n)
        new_M(j,n,1)=new_M(j,n,1)+Mp(i,n)
        Np(i,n)=max(Mp(i,n)/0.99_PS/g%binb(j+1),min(Mp(i,n)/1.01_PS/g%binb(j),Np(i,n)))
        new_N(j,n)=new_N(j,n)+Np(i,n)
      endif
    enddo
    enddo
    do jj=1,g%N_masscom
!      do in=1,nbin*L
!        n=(in-1)/nbin+1
!        i=in-(n-1)*nbin
!OCL INDEPENDENT
       do n = 1, L
       do i = 1, nbin
          if(icond(i,n)==1) then
             j=jbin(i,n)
             new_M(j,n,1+jj)=new_M(j,n,1+jj)+Mp(i,n)*ratio_Mp(i,n,jj)
          endif
       end do
       end do
    end do
    if(g%token==1.or.g%token==3) then
      do jj=1,g%N_nonmass
!        do in=1,nbin*L
!          n=(in-1)/nbin+1
!          i=in-(n-1)*nbin
!OCL INDEPENDENT
         do n = 1, L
         do i = 1, nbin
            if(icond(i,n)==1) then
               j=jbin(i,n)
               ! right now, only activated IN concentration
               new_Q(j,n,jj)=new_Q(j,n,jj)+Qp(i,n,jj)*Np(i,n)
            endif
         end do
         end do
       end do
    elseif(g%token==2) then
       do jj=1,g%N_nonmass
          if(jj.eq.ivcs.or.jj.eq.inex) then
!          do in=1,nbin*L
!            n=(in-1)/nbin+1
!            i=in-(n-1)*nbin
!OCL INDEPENDENT
             do n = 1, L
             do i = 1, nbin
                if(icond(i,n)==1) then
                   j=jbin(i,n)
                   new_Q(j,n,jj)=new_Q(j,n,jj)+Qp(i,n,jj)*Np(i,n)
                end if
             end do
             end do
          elseif(jj.eq.iacr.or.jj.eq.iccr.or.jj.eq.idcr.or.jj.eq.iag &
                     .or.jj.eq.icg) then
!OCL INDEPENDENT
             do n = 1, L
             do i = 1, nbin
                if(icond(i,n)==1) then
                   j=jbin(i,n)
                   new_Q(j,n,jj)=new_Q(j,n,jj)+Np(i,n)*Qp(i,n,jj)**3
                end if
             end do
             end do
          else
             LOG_ERROR("add_simple_vec",*) "add_smple_vec: This parameter is not defined",jj
             call PRC_abort
          endif
       end do
    end if
  end subroutine add_simple_vec

  subroutine add_samebin_vec(new_N,new_M,new_Q,nbin,L,icond,token,&
                    n_masscom,n_nonmass,Np,Mp,ratio_Mp,Qp)
    use scale_prc, only: &
       PRC_abort
    implicit none
    integer,intent(in) :: nbin,L,token,n_masscom,n_nonmass
    integer,dimension(mxnbin+1,*),intent(in) :: icond
    real(8),dimension(mxnbin+1,*),intent(in) :: Np,Mp
    real(PS), dimension(mxnbin+1,L,mxnmasscomp) :: ratio_Mp
    real(PS), dimension(mxnbin+1,L,mxnnonmc+2)  :: Qp
    real(8), dimension(mxnbin,*)                :: new_N
    real(8), dimension(mxnbin,L,1+mxnmasscomp)  :: new_M
    real(8), dimension(mxnbin,L,mxnnonmc)       :: new_Q
    integer :: i,n,jj

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin
      if(icond(i,n)==1) then
        new_M(i,n,1)=new_M(i,n,1)+Mp(i,n)
        new_N(i,n)=new_N(i,n)+Np(i,n)
      endif
    enddo
    enddo
    do jj=1,N_masscom
!      do in=1,nbin*L
!        n=(in-1)/nbin+1
!        i=in-(n-1)*nbin
       do n = 1, L
       do i = 1, nbin
          if(icond(i,n)==1) then
             new_M(i,n,1+jj)=new_M(i,n,1+jj)+Mp(i,n)*ratio_Mp(i,n,jj)
          endif
       end do
       end do
    end do
    if(token==2) then

!dbg      write(*,*) "ck index",N_nonmass,ivcs,inex,iacr,iccr,idcr,iag,icg

      do jj=1,N_nonmass
!        if(jj.eq.ivcs.or.jj.eq.inex) then
!          do in=1,nbin*L
!            n=(in-1)/nbin+1
!            i=in-(n-1)*nbin
         do n = 1, L
         do i = 1, nbin
            if(icond(i,n)==1) then
               if(jj.eq.ivcs.or.jj.eq.inex) then
                  new_Q(i,n,jj)=new_Q(i,n,jj)+Qp(i,n,jj)*Np(i,n)
               elseif(jj.eq.iacr.or.jj.eq.iccr.or.jj.eq.idcr.or.jj.eq.iag &
                    .or.jj.eq.icg) then
                  new_Q(i,n,jj)=new_Q(i,n,jj)+Np(i,n)*Qp(i,n,jj)**3
               else
                  LOG_ERROR("add_samebin_vec",*) "add_samebin: This parameter is not defined",jj
                  call PRC_abort
               endif
            end if
         end do
         end do
      end do
    else
      do jj=1,N_nonmass
!        do in=1,nbin*L
!          n=(in-1)/nbin+1
!          i=in-(n-1)*nbin
         do n = 1, L
         do i = 1, nbin
            if(icond(i,n)==1) then
               new_Q(i,n,jj)=new_Q(i,n,jj)+Qp(i,n,jj)*Np(i,n)
            endif
         end do
         end do
      end do
    end if

  end subroutine add_samebin_vec

  subroutine add_fragments_col_vec(new_N_1,new_M_1, &
                    i,g_1,g_2,icond1,used_marker,E_coal,N_col, &
                    imin_bk,imax_bk,jmin_bk,jmax_bk,bu_tmass,bu_fd)

    type (Group), intent(in)   :: g_1, g_2
    real(8), dimension(mxnbin,*),intent(inout)                :: new_N_1
    real(8), dimension(mxnbin,g_1%L,1+mxnmasscomp),intent(inout)  :: new_M_1
    ! catching bin
    integer,intent(in) :: i
    integer,dimension(mxnbin,*),intent(in) :: icond1
    integer,dimension(mxnbin,*),intent(in)      :: used_marker
    ! coalescence efficiency
    real(PS), dimension(mxnbin,mxnbin,*),intent(in)          :: E_coal
    ! total number of collected hydrometeors in j bin by i bin, N_col(i,j)
    real(PS),dimension(mxnbin,mxnbin,*),intent(in)   ::  N_col
    integer,intent(in) :: imin_bk,imax_bk,jmin_bk,jmax_bk
    real(PS),intent(in) :: bu_fd(2,*),bu_tmass(*)  ! 2014/10 T. Hashino modify for KID

    ! number of collitional breakup
    real(PS)         :: N_bk
    real(PS)      :: ratio_M

    integer            :: j,k,kk,n,l,i1d_pair
    real(PS) :: mod_rat!,sum_bu
    real(PS) :: mass_add
!!!    integer :: ID,JD,KD


    if(i<imin_bk.or.i>imax_bk) return


!    do kn=1,g_1%N_BIN*g_1%L
!      n=(kn-1)/g_1%n_bin+1
!      k=kn-(n-1)*g_1%n_bin
!      write(*,'("ck addfrc0:",2I5,20ES15.6)') i,n,new_N_1(k,n),new_M_1(k,n,1:2)
!    enddo

    do j=1,i-1
      if(j<jmin_bk.or.j>jmax_bk) cycle

      i1d_pair=j-jmin_bk+1+(i-imin_bk)*(1+i-imin_bk)/2
      if(bu_tmass(i1d_pair)<=1.0e-30_PS) cycle

!      do kn=1,g_1%N_BIN*g_1%L
!        n=(kn-1)/g_1%n_bin+1
!        k=kn-(n-1)*g_1%n_bin
      do n = 1, g_1%L
      do k = 1, g_1%n_bin

         if(used_marker(i,n)==1.or.icond1(i,n)==1) then
            kk=(i1d_pair-1)*g_1%N_BIN+k

            N_bk=max(0.0_PS,1.0_PS-E_coal(i,j,n))*N_col(i,j,n)
            mod_rat=(g_1%MS(i,n)%mean_mass+g_2%MS(j,n)%mean_mass)/bu_tmass(i1d_pair)

            new_N_1(k,n)=new_N_1(k,n)+bu_fd(2,kk)*N_bk*mod_rat
            mass_add=bu_fd(1,kk)*N_bk*mod_rat
            new_M_1(k,n,1)=new_M_1(k,n,1)+mass_add

            ! assume that the breakup fragments have the average property
            ! this is not really physical.
            ! In reality, the fragments distribution is made up of mass from small and large drop.
            ! The ratio of mass from two drops depends on CKE and other physical parameters.
            ! Doing this take more memory in lookup tables.

            do l=1,g_1%N_masscom
               ratio_M=0.0_PS
               if(l==rmat_m) then
                  ratio_M=(g_1%MS(i,n)%mass(rmat)+g_1%MS(j,n)%mass(rmat))/&
                          (g_1%MS(i,n)%mass(rmt)+g_1%MS(j,n)%mass(rmt))
               elseif(l==rmas_m) then
                  ratio_M=(g_1%MS(i,n)%mass(rmas)+g_1%MS(j,n)%mass(rmas))/&
                          (g_1%MS(i,n)%mass(rmt)+g_1%MS(j,n)%mass(rmt))
               elseif(l==rmai_m) then
                  ratio_M=max(0.0_PS,&
                          (g_1%MS(i,n)%mass(rmat)+g_1%MS(j,n)%mass(rmat))/&
                          (g_1%MS(i,n)%mass(rmt)+g_1%MS(j,n)%mass(rmt)) -&
                          (g_1%MS(i,n)%mass(rmas)+g_1%MS(j,n)%mass(rmas))/&
                          (g_1%MS(i,n)%mass(rmt)+g_1%MS(j,n)%mass(rmt)) &
                          )
               endif
               new_M_1(k,n,1+l)=new_M_1(k,n,1+l)+ratio_M*mass_add
            end do
!            if(l==rmat_m) then
!              write(*,'("ck addfrc",6I5,20ES15.6)') i,j,k,n,used_marker(i,n),icond1(i,n), &
!                      ratio_M,mass_add(kn),new_N_1(k,n),new_M_1(k,n,1:2),&
!                 g_1%MS(i,n)%mass(1:2),g_1%MS(j,n)%mass(1:2)
!            endif
         endif
      end do
      end do

!      sum_bu=0.0_PS
!       sum_bu=sum_bu+bu_fd(1,kk)*N_bk*mod_rat    ! mass

!       write(*,'("i1d,bu_tmass",7I5,10ES15.6)') i,j,k,kk,i1d_pair,imin_bk,jmin_bk,bu_tmass(i1d_pair)&
!                  ,bu_fd(1,kk),bu_fd(2,kk)
!       write(*,'("ID,JD,KD,new_N,M",3I5,3ES15.6)') ID,JD,KD,new_N_1(k),new_M_1(k,1)

    end do

!    if(sum_bu<=1.0e-30.and.N_bk>1.0e-30) then
!       write(*,*) "sum of mass breakup is 0 when number of breakup is not 0."
!       write(*,*) sum_bu,N_bk,m1,m2
!       new_N_1(i)=new_N_1(i)+m1*N_bk
!       new_N_1(j)=new_N_1(j)+m2*N_bk
!    elseif(sum_bu>m1+m2) then
!       write(*,*) "sum of colliding drops mass is larger than mass of breakup."
!       write(*,'("sum mass,m1,m2,i,j",3ES15.6,2I5)') sum_bu,m1,m2,i,j
!       write(*,'("mod_rat,bu_tmass",2ES15.6)') mod_rat,bu_tmass(i1d_pair)
!!!c       stop
!    end if
!!c    write(*,*) "sum_bu,(m1+m2)*N_bk",sum_bu,(m1+m2)*N_bk


  end subroutine add_fragments_col_vec

  subroutine cal_massratio_3d( g, ratio_M)
    type (Group), intent(in)   :: g
!tmp    real(PS), pointer, dimension(:,:)            :: ratio_M
    real(PS), dimension(mxnbin,1+mxnmasscomp,*)            :: ratio_M
    integer     :: i,j,n

!    do ijn=1,g%N_BIN*g%N_masscom*g%L
!      jn=(ijn-1)/g%N_BIN+1
!      i=ijn-(jn-1)*g%N_BIN
!      n=(jn-1)/g%N_masscom+1
!      j=jn-(n-1)*g%N_masscom
    do n = 1, g%L
    do j = 1, g%N_masscom
    do i = 1, g%N_BIN
      if( g%MS(i,n)%mass(1) > 1.0e-30_PS ) then
        ratio_M(i,j,n) = max(0.0_PS,min(1.0_PS,g%MS(i,n)%mass(1+j)/g%MS(i,n)%mass(1)))
      endif
    end do
    end do
    end do
  end subroutine cal_massratio_3d

  subroutine cal_massratio( g, n, ratio_M)
    type (Group), intent(in)   :: g
    integer,intent(in) :: n
!tmp    real(PS), pointer, dimension(:,:)            :: ratio_M
    real(PS), dimension(mxnbin,*)            :: ratio_M
    !integer, intent(in)        :: level
    integer     :: i,j

!    do ij=1,g%N_BIN*g%N_masscom
!      j=(ij-1)/g%N_BIN+1
!      i=ij-(j-1)*g%N_BIN
    do j = 1, g%N_masscom
    do i = 1, g%N_BIN
      if( g%MS(i,n)%mass(1) > 1.0e-30_PS ) then
        ratio_M(i,j) = max(0.0_PS,min(1.0_PS,g%MS(i,n)%mass(1+j)/g%MS(i,n)%mass(1)))
      endif
    end do
    end do
  end subroutine cal_massratio

  subroutine cal_collision_kernel_func(g_1,g_2,th_var,col_level,ibreak,&
               imin_bk,imax_bk,jmin_bk,jmax_bk,bu_tmass,&
               n,KC,E_coal,&
               adrpdrp,drpdrp,&
               ahexdrp,hexdrp,&
               abbcdrp,bbcdrp,&
               acoldrp,coldrp,&
               agp1drp,gp1drp,&
               agp4drp,gp4drp,&
               agp8drp,gp8drp)
    use class_Group, only: &
       col_lut_aux

!    use mod_amps_utility, only: getdrpdrp, &
!                           getcrydrp_col,getcrydrp_bbc,&
!                           getgpxdrp_den0p1,getgpxdrp_den0p4,getgpxdrp_den0p8
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate a collision kernel defined as
      !    K_col( x_i, x_j) = E_c (v_i - v_j) A_c
      !    Positive kernel means that x_i is catching x_j
      ! and a coalescence efficiency.
      !
      ! Assumptions
      ! - coalescence efficiency for ice-water process is assumed to 1.
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c  subroutine cal_collision_kernel_func(g_1,g_2,th_var,level,ibreak,n,KC,E_coal,vtdif,carea)
!!c    use com_amps
    type (Group), intent(in)               :: g_1, g_2
    type (Thermo_Var) :: th_var
!!c    type (Lookup_Table), intent(in)        :: lt
    integer, intent(in)           :: col_level,ibreak!,level
    integer,intent(in) :: imin_bk,imax_bk,jmin_bk,jmax_bk
    real(PS),intent(in) :: bu_tmass(*)  ! 2014/10 T. Hashino modify for KID !,bu_fd(2,*)
!tmp    real (PS), pointer, dimension(:,:)     :: KC,E_coal
    real (PS), intent(inout), dimension(mxnbin,*)     :: KC,E_coal
!
    type(col_lut_aux),intent(in) :: adrpdrp
    real(PS),intent(in),dimension(adrpdrp%nr,*) :: drpdrp
    type(col_lut_aux),intent(in) :: ahexdrp,abbcdrp,acoldrp
    real(PS),intent(in),dimension(ahexdrp%nr,*) :: hexdrp
    real(PS),intent(in),dimension(abbcdrp%nr,*) :: bbcdrp
    real(PS),intent(in),dimension(acoldrp%nr,*) :: coldrp
    type(col_lut_aux),intent(in) :: agp1drp,agp4drp,agp8drp
    real(PS),intent(in),dimension(agp1drp%nr,*) :: gp1drp
    real(PS),intent(in),dimension(agp4drp%nr,*) :: gp4drp
    real(PS),intent(in),dimension(agp8drp%nr,*) :: gp8drp
!!c    real (PS), pointer, dimension(:,:)     :: KC,E_coal,vtdif,carea
    integer                                :: i,j,n,i1d_pair

    ! collision efficiency
    real(PS),dimension(g_1%n_bin,g_2%n_bin)                 :: E_c
    ! swiping cross-section area
    real(PS),dimension(g_1%n_bin,g_2%n_bin)                 :: A_c
    real(PS) :: D_L,D_S,S_T,S_C,DS_S,CKE

    ! minimum possible riming density is assumed to 1.0e-2.
    real(PS), parameter         :: den_min = 1.0d-2
    ! density of riming
    real(PS)                    :: den_R

    ! error message
    integer,dimension(g_1%n_bin,g_2%n_bin) :: em
    integer,dimension(g_1%n_bin,g_2%n_bin) :: icond1



    real(PS) :: Nre_rp,Nre_sp
    integer :: i1,j1
    real(PS) :: x1,y1,wx,wy
    real(PS),parameter :: ec_min=0.0D0
    real(PS) :: NreL_p,rrat,rrat_p

    ! initialize
!    do ij=1,g_1%n_bin*g_2%N_bin
!      j=(ij-1)/g_1%N_BIN+1
!      i=ij-(j-1)*g_1%N_BIN
    do j = 1, g_2%N_BIN
    do i = 1, g_1%N_BIN
     KC(i,j)=0.0_PS
      E_c(i,j)=0.0_PS
      E_coal(i,j)=0.0_PS
      em(i,j)=0
      if((g_1%MS(i,n)%con>1.0e-30_PS .and. g_2%MS(j,n)%con>1.0e-30_PS ).and.&
         (g_1%MS(i,n)%mass(1)>1.0e-30_PS .and. g_2%MS(j,n)%mass(1)>1.0e-30_PS)) then
        icond1(i,j)=0
      else
        icond1(i,j)=1
      endif
    enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the cross-section (sweeping) area
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! case where i is catching j.
    if(g_1%token==1.and.g_2%token==1 ) then
      if (col_level==0) then
!        do ij=1,g_1%n_bin*g_2%N_bin
!          j=(ij-1)/g_1%N_BIN+1
!          i=ij-(j-1)*g_1%N_BIN
         do j = 1, g_2%N_BIN
         do i = 1, g_1%N_BIN
          if(icond1(i,j)==0) then
            ! case where i is catching j.
            if(g_2%MS(j,n)%len > 0.0001_PS .or. g_1%MS(i,n)%len > 0.0001_PS) then
              A_c(i,j)=0.0_PS
            else
              A_c(i,j)=0.25_PS*PI*(g_1%MS(i,n)%len+g_2%MS(j,n)%len)**2.0
            endif
          endif
        enddo
        enddo
      else
!        do ij=1,g_1%n_bin*g_2%N_bin
!          j=(ij-1)/g_1%N_BIN+1
!          i=ij-(j-1)*g_1%N_BIN
         do j = 1, g_2%N_BIN
         do i = 1, g_1%N_BIN
          if(icond1(i,j)==0) then
            ! case where i is catching j.
            A_c(i,j)=0.25_PS*PI*(g_1%MS(i,n)%len+g_2%MS(j,n)%len)**2.0
          endif
        enddo
        enddo
      endif
    else if(g_1%token==2.and.g_2%token==2 ) then
!      do ij=1,g_1%n_bin*g_2%N_bin
!        j=(ij-1)/g_1%N_BIN+1
!        i=ij-(j-1)*g_1%N_BIN
       do j = 1, g_2%N_BIN
       do i = 1, g_1%N_BIN
        if(icond1(i,j)==0) then
        ! maximum cross section model
          if( g_1%MS(i,n)%semi_a > g_1%MS(i,n)%semi_c ) then
            ! --- case where the cross-section area is an circle ---
            A_c(i,j) = PI*( max(g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c)+g_1%MS(i,n)%semi_a )**2.0
          else
            ! g_1%MS(i,n)%semi_a <= g_1%MS(i,n)%semi_c
            ! --- case where the cross-section area is an ellipse ---
            A_c(i,j) = 4.0_PS*( max(g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c)+g_1%MS(i,n)%semi_c )*&
               ( max(g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c) +  g_1%MS(i,n)%semi_a )
          end if
        endif
      enddo
      enddo
    else if(g_1%token==1.and.g_2%token==2 ) then
      if (col_level==0) then
!        do ij=1,g_1%n_bin*g_2%N_bin
!          j=(ij-1)/g_1%N_BIN+1
!          i=ij-(j-1)*g_1%N_BIN
         do j = 1, g_2%N_BIN
         do i = 1, g_1%N_BIN
          if(icond1(i,j)==0) then
            if(g_1%MS(i,n)%len > 0.002_PS) then
              A_c(i,j) = 0.0_PS
            else
              A_c(i,j) = PI*( max(g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c)+0.5_PS*g_1%MS(i,n)%len )**2.0
            endif
          endif
        enddo
        enddo
      else
!        do ij=1,g_1%n_bin*g_2%N_bin
!          j=(ij-1)/g_1%N_BIN+1
!          i=ij-(j-1)*g_1%N_BIN
         do j = 1, g_2%N_BIN
         do i = 1, g_1%N_BIN
          if(icond1(i,j)==0) then
            A_c(i,j) = PI*( max(g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c)+0.5_PS*g_1%MS(i,n)%len )**2.0
          endif
        enddo
        enddo
      endif
    else if(g_1%token==2.and.g_2%token==1 ) then
!CDIR NODEP
      if (col_level==0) then
!        do ij=1,g_1%n_bin*g_2%N_bin
!          j=(ij-1)/g_1%N_BIN+1
!          i=ij-(j-1)*g_1%N_BIN
         do j = 1, g_2%N_BIN
         do i = 1, g_1%N_BIN
          if(icond1(i,j)==0) then
            if( g_1%MS(i,n)%semi_a > g_1%MS(i,n)%semi_c ) then
              ! --- case where the cross-section area is an circle ---
              if(g_2%MS(j,n)%len > 0.002_PS) then
                A_c(i,j) = 0.0_PS
              else
                A_c(i,j) = PI*( 0.5_PS*g_2%MS(j,n)%len+g_1%MS(i,n)%semi_a )**2.0
              endif
            else if( g_1%MS(i,n)%semi_a <= g_1%MS(i,n)%semi_c ) then
              if((g_1%IS(i,n)%sh_type<=2.and.g_1%IS(i,n)%is_mod(2)==2).or.&
                g_1%IS(i,n)%sh_type==5) then
                ! --- case where the cross-section area is an ellipse ---
                if(g_2%MS(j,n)%len > 0.002_PS) then
                  A_c(i,j) = 0.0_PS
                else
                  A_c(i,j) = PI*( 0.5_PS*g_2%MS(j,n)%len+g_1%MS(i,n)%semi_c )*&
                     ( 0.5_PS*g_2%MS(j,n)%len +  g_1%MS(i,n)%semi_a )
                endif
              else
                ! --- case where the cross-section area is rectangular ---
                if(g_2%MS(j,n)%len > 0.002_PS) then
                  A_c(i,j) = 0.0_PS
                else
                  A_c(i,j) = 4.0_PS*( 0.5_PS*g_2%MS(j,n)%len+g_1%MS(i,n)%semi_c )*&
                     ( 0.5_PS*g_2%MS(j,n)%len +  g_1%MS(i,n)%semi_a )
                endif
              endif
            end if
          endif
        enddo
        enddo
      else
!        do ij=1,g_1%n_bin*g_2%N_bin
!          j=(ij-1)/g_1%N_BIN+1
!          i=ij-(j-1)*g_1%N_BIN
         do j = 1, g_2%N_BIN
         do i = 1, g_1%N_BIN
          if(icond1(i,j)==0) then
            if( g_1%MS(i,n)%semi_a > g_1%MS(i,n)%semi_c ) then
              ! --- case where the cross-section area is an circle ---
              A_c(i,j) = PI*( 0.5_PS*g_2%MS(j,n)%len+g_1%MS(i,n)%semi_a )**2.0
            else if( g_1%MS(i,n)%semi_a <= g_1%MS(i,n)%semi_c ) then
              if((g_1%IS(i,n)%sh_type<=2.and.g_1%IS(i,n)%is_mod(2)==2).or.&
                g_1%IS(i,n)%sh_type==5) then
                ! --- case where the cross-section area is an ellipse ---
                A_c(i,j) = PI*( 0.5_PS*g_2%MS(j,n)%len+g_1%MS(i,n)%semi_c )*&
                   ( 0.5_PS*g_2%MS(j,n)%len +  g_1%MS(i,n)%semi_a )
              else
                ! --- case where the cross-section area is rectangular ---
                A_c(i,j) = 4.0_PS*( 0.5_PS*g_2%MS(j,n)%len+g_1%MS(i,n)%semi_c )*&
                   ( 0.5_PS*g_2%MS(j,n)%len +  g_1%MS(i,n)%semi_a )
              endif
            end if
          endif
        enddo
        enddo
      endif
    end if

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! determine the collision efficiency
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if( ( g_1%token == 1 .and. g_2%token == 1 ) .or. &
        ( g_1%token == 1 .and. g_2%token == 11 ) ) then
!      do ij=1,g_1%n_bin*g_2%N_bin
!        j=(ij-1)/g_1%N_BIN+1
!        i=ij-(j-1)*g_1%N_BIN
       do j = 1, g_2%N_BIN
       do i = 1, g_1%N_BIN
        if(icond1(i,j)==0) then
          NreL_p=max(g_1%MS(i,n)%Nre,1.0e-10_RP)
          rrat=g_2%MS(j,n)%len/g_1%MS(i,n)%len
          if(rrat<0.0_RP) then
            em(i,j)=1
            rrat_p=0.0_RP
            NreL_p=max(g_1%MS(i,n)%Nre,1.0e-10_RP)
            rrat=g_2%MS(j,n)%len/g_1%MS(i,n)%len
            if(debug) write(*,*) "something is not right getdrpdrp",i,j,rrat,NreL_p,&
                 g_2%MS(j,n)%len,g_1%MS(i,n)%len
          elseif(rrat>1.0_RP) then
            rrat_p=1.0/rrat
          else
            rrat_p=rrat
          endif

          j1=max(1,min(adrpdrp%nc-1 &
               ,int((rrat_p-adrpdrp%xs)/adrpdrp%dx)+1))
          x1=real(j1-1,PS_KIND)*adrpdrp%dx+adrpdrp%xs

          i1=max(1,min(adrpdrp%nr-1 &
               ,int((log10(NreL_p)-adrpdrp%ys)/adrpdrp%dy)+1))
          y1=real(i1-1,PS_KIND)*adrpdrp%dy+adrpdrp%ys

          wx=max(0.0_RP,min(1.0_RP,(rrat_p-x1)/adrpdrp%dx))
          wy=max(0.0_RP,min(1.0_RP,(log10(NreL_p)-y1)/adrpdrp%dy))

          E_c(i,j)=min(1.0_RP,max(ec_min, &
               (1.0_RP-wx)*(1.0_RP-wy)*drpdrp(i1,j1)+ &
               (1.0_RP-wx)*wy*drpdrp(i1,j1+1)+ &
               wx*(1.0_RP-wy)*drpdrp(i1+1,j1)+ &
               wx*wy*drpdrp(i1+1,j1+1)))

!          call getdrpdrp(E_c(i,j),em(ij),real(g_1%MS(i,n)%Nre), real(g_2%MS(j,n)%len/g_1%MS(i,n)%len))
          if(E_c(i,j)>15.0_RP) then
            E_c(i,j)=15.0_PS
          endif
        endif
      enddo
      enddo
    else if( ( g_1%token == 2 .and. g_2%token == 1  ) .or. &
             ( g_1%token == 2 .and. g_2%token == 11  ) ) then
!      do ij=1,g_1%n_bin*g_2%N_bin
!        j=(ij-1)/g_1%N_BIN+1
!        i=ij-(j-1)*g_1%N_BIN
       do j = 1, g_2%N_BIN
       do i = 1, g_1%N_BIN
        if(icond1(i,j)==0) then
          if( g_1%IS(i,n)%sh_type <= 2 ) then

            Nre_rp=max(g_2%MS(j,n)%Nre,1.0e-10_RP)
            Nre_sp=max(g_1%MS(i,n)%Nre,1.0e-10_RP)


            select case(g_1%IS(i,n)%habit)
            case(1,5,6)
!
!     assume that irregular crystal is close to hexagonal plate
              j1=max(1,min(ahexdrp%nc-1 &
                   ,int((log10(Nre_rp)-ahexdrp%xs)/ahexdrp%dx)+1))
              x1=real(j1-1,PS_KIND)*ahexdrp%dx+ahexdrp%xs

              i1=max(1,min(ahexdrp%nr-1 &
                   ,int((log10(Nre_sp)-ahexdrp%ys)/ahexdrp%dy)+1))
              y1=real(i1-1,PS_KIND)*ahexdrp%dy+ahexdrp%ys
!
!     do not extrapolate!
              wx=min(1.0_RP,max(0.0_RP,(log10(Nre_rp)-x1)/ahexdrp%dx))
              wy=min(1.0_RP,max(0.0_RP,(log10(Nre_sp)-y1)/ahexdrp%dy))

              E_c(i,j)=min(1.0_RP,max(ec_min, &
                   (1.0_RP-wx)*(1.0_RP-wy)*hexdrp(i1,j1)+ &
                   (1.0_RP-wx)*wy*hexdrp(i1,j1+1)+ &
                   wx*(1.0_RP-wy)*hexdrp(i1+1,j1)+ &
                   wx*wy*hexdrp(i1+1,j1+1)))
            case(2,4)
!     assume that rosette bullets char is close to broad branced crystal.
              j1=max(1,min(abbcdrp%nc-1 &
                   ,int((log10(Nre_rp)-abbcdrp%xs)/abbcdrp%dx)+1))
              x1=real(j1-1,PS_KIND)*abbcdrp%dx+abbcdrp%xs

              i1=max(1,min(abbcdrp%nr-1 &
                   ,int((log10(Nre_sp)-abbcdrp%ys)/abbcdrp%dy)+1))
              y1=real(i1-1,PS_KIND)*abbcdrp%dy+abbcdrp%ys

!     do not extrapolate!
              wx=min(1.0_RP,max(0.0_RP,(log10(Nre_rp)-x1)/abbcdrp%dx))
              wy=min(1.0_RP,max(0.0_RP,(log10(Nre_sp)-y1)/abbcdrp%dy))

              E_c(i,j)=min(1.0_RP,max(ec_min, &
                   (1.0_RP-wx)*(1.0_RP-wy)*bbcdrp(i1,j1)+ &
                   (1.0_RP-wx)*wy*bbcdrp(i1,j1+1)+ &
                   wx*(1.0_RP-wy)*bbcdrp(i1+1,j1)+ &
                   wx*wy*bbcdrp(i1+1,j1+1)))

            case default
              j1=max(1,min(acoldrp%nc-1 &
                   ,int((log10(Nre_rp)-acoldrp%xs)/acoldrp%dx)+1))
              x1=real(j1-1,PS_KIND)*acoldrp%dx+acoldrp%xs

              i1=max(1,min(acoldrp%nr-1 &
                   ,int((log10(Nre_sp)-acoldrp%ys)/acoldrp%dy)+1))
              y1=real(i1-1,PS_KIND)*acoldrp%dy+acoldrp%ys

!     do not extrapolate!
              wx=min(1.0_RP,max(0.0_RP,(log10(Nre_rp)-x1)/acoldrp%dx))
              wy=min(1.0_RP,max(0.0_RP,(log10(Nre_sp)-y1)/acoldrp%dy))

              E_c(i,j)=min(1.0_RP,max(ec_min, &
                   (1.0_RP-wx)*(1.0_RP-wy)*coldrp(i1,j1)+ &
                   (1.0_RP-wx)*wy*coldrp(i1,j1+1)+ &
                   wx*(1.0_RP-wy)*coldrp(i1+1,j1)+ &
                   wx*wy*coldrp(i1+1,j1+1)))
            end select
          else
            ! --- aggregates, rimed aggreagtes, graupel ---
            NreL_p=max(g_1%MS(i,n)%Nre,1.0e-10_RP)
            rrat=g_2%MS(j,n)%len*0.5_RP/max(g_1%MS(i,n)%semi_a,g_1%MS(i,n)%semi_c)

            if(g_1%MS(i,n)%den<=0.2_PS) then
              j1=max(1,min(agp1drp%nc-1 &
                   ,int((rrat-agp1drp%xs)/agp1drp%dx)+1))
              x1=real(j1-1,PS_KIND)*agp1drp%dx+agp1drp%xs

              i1=max(1,min(agp1drp%nr-1 &
                   ,int((log10(NreL_p)-agp1drp%ys)/agp1drp%dy)+1))
              y1=real(i1-1,PS_KIND)*agp1drp%dy+agp1drp%ys

!     do not extrapolate
              wx=min(1.0_RP,max(0.0_RP,(rrat-x1)/agp1drp%dx))
              wy=min(1.0_RP,max(0.0_RP,(log10(NreL_p)-y1)/agp1drp%dy))

              E_c(i,j)=min(1.0_RP,max(ec_min, &
                   (1.0_RP-wx)*(1.0_RP-wy)*gp1drp(i1,j1)+ &
                   (1.0_RP-wx)*wy*gp1drp(i1,j1+1)+ &
                   wx*(1.0_RP-wy)*gp1drp(i1+1,j1)+ &
                   wx*wy*gp1drp(i1+1,j1+1)))

            elseif(g_1%MS(i,n)%den<=0.6_PS) then
              j1=max(1,min(agp4drp%nc-1 &
                   ,int((rrat-agp4drp%xs)/agp4drp%dx)+1))
              x1=real(j1-1,PS_KIND)*agp4drp%dx+agp4drp%xs

              i1=max(1,min(agp4drp%nr-1 &
                   ,int((log10(NreL_p)-agp4drp%ys)/agp4drp%dy)+1))
              y1=real(i1-1,PS_KIND)*agp4drp%dy+agp4drp%ys

!     do not extrapolate
              wx=min(1.0_RP,max(0.0_RP,(rrat-x1)/agp4drp%dx))
              wy=min(1.0_RP,max(0.0_RP,(log10(NreL_p)-y1)/agp4drp%dy))

              E_c(i,j)=min(1.0_RP,max(ec_min, &
                   (1.0_RP-wx)*(1.0_RP-wy)*gp4drp(i1,j1)+ &
                   (1.0_RP-wx)*wy*gp4drp(i1,j1+1)+ &
                   wx*(1.0_RP-wy)*gp4drp(i1+1,j1)+ &
                   wx*wy*gp4drp(i1+1,j1+1)))

            else
              j1=max(1,min(agp8drp%nc-1 &
                   ,int((rrat-agp8drp%xs)/agp8drp%dx)+1))
              x1=real(j1-1,PS_KIND)*agp8drp%dx+agp8drp%xs

              i1=max(1,min(agp8drp%nr-1 &
                   ,int((log10(NreL_p)-agp8drp%ys)/agp8drp%dy)+1))
              y1=real(i1-1,PS_KIND)*agp8drp%dy+agp8drp%ys

!     do not extrapolate
              wx=min(1.0_RP,max(0.0_RP,(rrat-x1)/agp8drp%dx))
              wy=min(1.0_RP,max(0.0_RP,(log10(NreL_p)-y1)/agp8drp%dy))

              E_c(i,j)=min(1.0_RP,max(ec_min, &
                   (1.0_RP-wx)*(1.0_RP-wy)*gp8drp(i1,j1)+ &
                   (1.0_RP-wx)*wy*gp8drp(i1,j1+1)+ &
                   wx*(1.0-wy)*gp8drp(i1+1,j1)+ &
                   wx*wy*gp8drp(i1+1,j1+1)))
            endif
          endif
        endif
      enddo
      enddo
    else if( g_1%token == 2 .and. g_2%token == 2  ) then
      ! --- case of a frozen hydrometeor collectiong a frozen hydrometeor ---
!      do ij=1,g_1%n_bin*g_2%N_bin
!        j=(ij-1)/g_1%N_BIN+1
!        i=ij-(j-1)*g_1%N_BIN
       do j = 1, g_2%N_BIN
       do i = 1, g_1%N_BIN
        if(icond1(i,j)==0) then
          E_c(i,j)=1.0_PS
        end if
      enddo
      enddo
    endif

!    do ij=1,g_1%n_bin*g_2%N_bin
!      j=(ij-1)/g_1%N_BIN+1
!      i=ij-(j-1)*g_1%N_BIN
    do j = 1, g_2%N_BIN
    do i = 1, g_1%N_BIN
      E_c(i,j)=max(E_c(i,j), 0.0_PS)
    enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! determine the coalescence efficiency
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do ij=1,g_1%n_bin*g_2%N_bin
!      j=(ij-1)/g_1%N_BIN+1
!      i=ij-(j-1)*g_1%N_BIN
    do j = 1, g_2%N_BIN
    do i = 1, g_1%N_BIN
      if(icond1(i,j)==0) then
        call cal_Coalescence_Efficiency(g_1,i,g_2,j,n,th_var,E_coal(i,j),&
             D_L,D_S,S_T,S_C,DS_S,CKE)
!!c      E_coal(i,j) = 1.0_PS
      endif
    enddo
    enddo

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! determine the collection kernel times number concentration of collectee
    !    times delta time
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    do ij=1,g_1%n_bin*g_2%N_bin
!      j=(ij-1)/g_1%N_BIN+1
!      i=ij-(j-1)*g_1%N_BIN
    do j = 1, g_2%N_BIN
    do i = 1, g_1%N_BIN
      if(icond1(i,j)==0) then
        KC(i,j)=E_c(i,j)*( g_1%MS(i,n)%vtm - g_2%MS(j,n)%vtm )*A_c(i,j)* &
                g_2%MS(j,n)%con*g_1%dt
!!c        KC(i,j) = 1500.0_PS * (g_1%MS(i,n)%mean_mass + g_2%MS(j,n)%mean_mass) * g_2%MS(j,n)%con*g_1%dt ! Golovin kernel
!!c        E_coal(i,j) = 1.0D0 ! Golovin kernel
!!c        E_c(i,j) = 1.0_PS
!!c      KC(i,j) = 0.5_PS * g_2%MS(j,n)%con*g_1%dt ! constant kernel
         !if (g_1%MS(i,n)%mean_mass >= 6.545e-8 .or.&
         !    g_2%MS(j,n)%mean_mass >= 6.545e-8) then ! 4.19e-6 200 um, 5.236e-7 100 um, 6.545e-8 50 um
         !  KC(i,j)=0.0D0
         !  E_coal(i,j) = 0.0D0
         !endif
      endif
    enddo
    enddo
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! test the collision occurence since the rime density can be less than for
    ! a minimum for a certain case.
    !
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if(g_1%token==2.and.g_2%token==1 ) then
!      do ij=1,g_1%n_bin*g_2%N_bin
!        j=(ij-1)/g_1%N_BIN+1
!        i=ij-(j-1)*g_1%N_BIN
       do j = 1, g_2%N_BIN
       do i = 1, g_1%N_BIN
        if(icond1(i,j)==0) then
          if(g_1%MS(i,n)%inmlt==0.and.g_1%MS(i,n)%tmp<273.16_PS) then
            ! +++ calculate the density of rime deposite +++
            ! assume this is given by original solid hydrometeor
            call cal_density_rime2(den_r,em(i,j),g_1, g_2, i,n, j)

            ! +++ check if the density is zero (no collision) +++
            if( den_R < den_min ) then
              KC(i,j)=0.0_PS
!tmp            write(*,*) "test:rim0",n,i,j,den_R
            endif
          end if
        end if
      enddo
      enddo
    endif

    if(ibreak==1) then
!      do ij=1,g_1%n_bin*g_2%N_bin
!        j=(ij-1)/g_1%N_BIN+1
!        i=ij-(j-1)*g_1%N_BIN
       do j = 1, g_2%N_BIN
       do i = 1, g_1%N_BIN
        if(icond1(i,j)==0) then
          if(i<imin_bk.or.i>imax_bk.or.j<jmin_bk.or.j>jmax_bk) then
          else
            i1d_pair=j-jmin_bk+1+(i-imin_bk)*(1+i-imin_bk)/2

            if(bu_tmass(i1d_pair)<=1.0e-30_PS) then
              E_coal(i,j)=1.0_PS
            end if
          end if
        end if
      end do
      end do
    endif

  end subroutine cal_collision_kernel_func

!!$  subroutine cal_ex_vapor_density( g, ag, ex_vden, n)
!!$    type (Group), intent(in)    :: g
!!$    type (AirGroup), intent(in) :: ag
!!$    ! ambient excess vapor density in g/cm^3
!!$    real(PS), dimension(*) :: ex_vden
!!$    ! grid number
!!$    integer, intent(in) :: n
!!$    ! gas constant for vapor in  ergs/deg/g
!!$    real(PS), parameter             :: R_v = 4.615e+06
!!$    ! density of saturated vapor at the surface of ice
!!$    ! crystal
!!$    real(PS)                        :: den_sv_sfc
!!$    ! density of saturated vapor at the surface of ice
!!$    ! crystal
!!$    real(PS)                        :: den_v_inf
!!$    ! saturation vapor pressure at the surface of hydrometeor
!!$    real(PS)                        :: e_s
!!$    integer                         :: i
!!$    ! latent heat of condensation in ergs/g
!!$    real (ps), parameter             :: l_e = 2.5e+10_ps
!!$
!!$    ! constant pressure specific heat of air at 0c
!!$    real(ps), parameter :: c_pa= 1004.64e+4_ps ! chiarui, origin 1004.0
!!$    !real(PS) :: s_i,T,aa
!!$
!!$!!c    aa=(l_e/c_pa/ag%TV(n)%T-1.0_PS)*M_a*gg/R_u/ag%TV(n)%T*ag%TV(n)%W
!!$!!c    s_i=ag%TV(n)%e_sat(1)/ag%TV(n)%e_sat(2)&
!!$!!c        *(min(0.0_PS,ag%TV(n)%s_v(1))+1.0_PS)*(exp(aa*g%dt)-1.0_PS)/aa/g%dt-1.0_PS
!!$!!c    s_i=(ag%TV(n)%s_v(2)+1.0_PS)&
!!$!!c        *(exp(aa*g%dt)-1.0_PS)/aa/g%dt-1.0_PS
!!$
!!$!!c    T=get_T_fesv_lk(2, ag%TV(n)%T, ag%TV(n)%e/(ag%TV(n)%s_v_n(2)+1.0_PS), ag%estbar, ag%esitbar )
!!$!!c    den_v_inf = ag%TV(n)%e/(R_v*T)
!!$    den_v_inf =(ag%TV(n)%s_v(2)+1.0_PS)*ag%TV(n)%e_sat(2)/(R_v*ag%TV(n)%T)
!!$    do i = 1, g%N_BIN
!!$       if( g%MS(i,n)%mass(1) == 0.0_PS .or. g%MS(i,n)%con == 0.0_PS ) then
!!$          ex_vden(i) = 0.0_PS
!!$          cycle
!!$       end if
!!$       ! The vapor excess is calculated with the suface temperature of
!!$       ! ice crystal
!!$       e_s = get_satvp_lk(ag,g%token, g%MS(i,n)%tmp)
!!$       den_sv_sfc = e_s/(R_v*g%MS(i,n)%tmp)
!!$       ex_vden(i) = den_v_inf - den_sv_sfc
!!$    end do
!!$    ! The vapor excess is calculated with ambient temperature
!!$!!c    e_s = get_satvp_lk(ag,g%token, ag%TV(n)%T)
!!$!!c    den_sv_sfc = e_s/(R_v*ag%TV(n)%T)
!!$!!c    e_s = get_satvp_lk(ag,g%token,T)
!!$!!c    den_sv_sfc = e_s/(R_v*T)
!!$!!c    ex_vden(g%N_BIN+1) = den_v_inf - den_sv_sfc
!!$    ex_vden(g%N_BIN+1)=ag%TV(n)%s_v(2)*ag%TV(n)%e_sat(2)/(R_v*ag%TV(n)%T)
!!$!!c    write(*,'("sv2,dsv2,s_i,old_T,T,ex_vden",8ES15.6)') ag%TV(n)%s_v(2),ag%TV(n)%s_v_n(2),s_i,ag%TV(n)%T,T,ex_vden(g%N_BIN+1),ag%TV(n)%W
!!$!!c    if(ex_vden(g%N_BIN+1)>0.20e-6) then
!!$!!c       write(*,'("n,T,s_v_n2,ex_vden",I5,8ES15.6)') n,ag%TV(n)%T-273.16,ag%TV(n)%s_v_n(2),ex_vden(g%N_BIN+1)
!!$!!c    end if
!!$
!!$  end subroutine cal_ex_vapor_density

  subroutine cal_ex_vapor_density_vec( g, ag, ex_vden)
    use class_Thermo_Var, only: &
       get_sat_vapor_pres_lk
    type (Group), intent(in)    :: g
    type (AirGroup), intent(in) :: ag
    ! ambient excess vapor density in g/cm^3
    real(PS), dimension(mxnbin+1,*) :: ex_vden
    ! density of saturated vapor at the surface of ice
    ! crystal
    real(PS)                        :: den_sv_sfc
    ! density of saturated vapor at the surface of ice
    ! crystal
    real(PS)                        :: den_v_inf
    ! saturation vapor pressure at the surface of hydrometeor
    real(PS)                        :: e_s
    integer                         :: i,n

    !real(PS) :: s_i,T,aa

!    do in=1,g%N_BIN*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

      den_v_inf =(ag%TV(n)%s_v(2)+1.0_PS)*ag%TV(n)%e_sat(2)/(R_v*ag%TV(n)%T)
      ! The vapor excess is calculated with ambient temperature
      ex_vden(g%N_BIN+1,n)=ag%TV(n)%s_v(2)*ag%TV(n)%e_sat(2)/(R_v*ag%TV(n)%T)

      if( g%MS(i,n)%mass(1) > 1.0e-30_PS .and. g%MS(i,n)%con > 1.0e-30_PS) then
        ! The vapor excess is calculated with the suface temperature of
        ! ice crystal
!org        e_s = get_satvp_lk(ag,g%token, g%MS(i,n)%tmp)
        e_s=get_sat_vapor_pres_lk(g%token,g%MS(i,n)%tmp,ag%estbar,ag%esitbar)

        den_sv_sfc = e_s/(R_v*g%MS(i,n)%tmp)
        ex_vden(i,n) = den_v_inf - den_sv_sfc

      else
        ex_vden(i,n) = 0.0_PS
      end if
    end do
    end do

  end subroutine cal_ex_vapor_density_vec

!!$  function get_ex_vapor_density( g, th_var, clctr,ngrid) result(ex_vden)
!!$    type (Group), intent(in)    :: g
!!$    type (Thermo_Var),intent(in) :: th_var
!!$
!!$    ! index of the bin under certain mechanism such as vapor deposition or
!!$    ! coalescence process.
!!$    integer, intent(in)                    :: clctr,ngrid
!!$
!!$    ! ambient excess vapor density in g/cm^3
!!$    real(PS)                       :: ex_vden
!!$    ! density of saturated vapor at the surface of ice
!!$    ! crystal
!!$    real(PS)                        :: den_sv_sfc
!!$    ! density of saturated vapor at the surface of ice
!!$    ! crystal
!!$    real(PS)                        :: den_v_inf
!!$    ! saturation vapor pressure at the surface of hydrometeor
!!$    real(PS)                        :: e_s
!!$
!!$    den_v_inf = th_var%e/(R_v*th_var%T)
!!$    e_s = get_sat_vapor_pres( g%token, g%MS(clctr,ngrid)%tmp)
!!$    den_sv_sfc = e_s/(R_v*g%MS(clctr,ngrid)%tmp)
!!$    ex_vden = den_v_inf - den_sv_sfc
!!$
!!$  end function get_ex_vapor_density

  subroutine cal_ratio_mass_vd_vec( g, ag, level,icond3, &
       gamma, ex_vden, d_mean_mass,&
       dMcon, Mp, ratio_Mp, d_axis_len, d_vol,len_switch,&
       iwet,mes_rc,rdsd,ihabit_gm_random)
    use mod_amps_utility, only: cal_growth_mode_hex_inl_vec,random_genvar
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of
    !     1. ratio of each increased mass components to total mass, and
    !     2. growth in a-axis and c-axis
    ! for vapor deposition proceses.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)    :: g
    ! thermo variable object
    type (AirGroup), intent(in)  :: ag
    ! level of complexity
    integer, intent(in)           :: level
    integer,dimension(mxnbin+1,*),intent(in) :: icond3

    ! inherent growth ratio
!tmp    real(PS),pointer,dimension(:)       :: gamma
    real(PS),dimension(g%L,2),intent(inout)       :: gamma

    !integer,dimension(mxnbin,*), intent(in)         :: growth_mode
    integer,dimension(mxnbin,*),intent(inout)         :: iwet

    ! ambient excess vapor density in g/cm^3
    real(PS), dimension(mxnbin+1,*),intent(in) :: ex_vden

    ! mass change at mean mass, not total mass change in the bin.
    real(PS), dimension(mxnbin,*), intent(inout)        :: d_mean_mass

    ! change of total mass in the bin before mapping
    real(PS), dimension(mxnbin,*), intent(inout)        :: dMcon

    ! ratio of each component mass to the total mass in the shifted bin
    ! ratio_Mp(imr_m) : rime
    ! ratio_Mp(ima_m) : aggregation
    ! ratio_Mp(imc_m) : ice crystal
    real(PS), dimension(mxnbin+1,g%L,mxnmasscomp)      :: ratio_Mp


    ! change in a-axis and c-axis in the shifted bin
    real(PS), dimension(mxnbin+1,g%L,2)            :: d_axis_len

    ! volume change in the shifted bin
    real(PS),dimension(mxnbin,g%L,mxnvol)        :: d_vol

    ! random generaion: 1, max frequency: 0
    integer, intent(in)           :: ihabit_gm_random

    ! message from reality check
    integer,dimension(*),intent(in)   :: mes_rc

    ! total mass in the shifted bin
    real(PS),dimension(mxnbin+1,*),intent(in)          :: Mp

    ! indication of conditional axis growth
    integer,dimension(mxnbin,g%L,3),intent(inout) :: len_switch

    type(random_genvar),intent(inout) :: rdsd

    ! weight, left-over mass
    !real(PS)                    :: w
    real(PS),dimension(mxnbin,LMAX,mxnmasscomp) :: left_mass
    real(PS) :: gamma_d!,d_mm_hex

    integer,dimension(mxnbin,LMAX) :: icond1

    ! volume,volume of core of ice, porus volume, dummy volume
    !real(PS)                   :: V_R,V_core,V_space,V_n
    !real(PS) :: nsemi_a,nsemi_c

    real(PS) :: devap_ice

    ! error message
    !integer :: em

    !
    real(PS) :: mass_ice,dia_ice,den_ice,dia_par,mass_par,aa,bb,n_ice,d_mm_ice

    real(PS) :: rat,f_ice!,coef

    integer  :: i,n,j!,ick, istatus, var_Status
    integer,dimension(mxnbin,LMAX)  :: ierr
    ! random number
    !integer,dimension(mxnbin,LMAX) :: igm
    integer,dimension(g%N_BIN,g%L) :: igm

    if(g%token==1) then
      ! liquid hydrometeors
      if(level>=4) then
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN

          if(icond3(i,n)==1) then
            ratio_Mp(i,n,rmat_m)=g%MS(i,n)%mass(rmat)/Mp(i,n)
            ratio_Mp(i,n,rmas_m)=g%MS(i,n)%mass(rmas)/Mp(i,n)
            ratio_Mp(i,n,rmai_m)=max(ratio_Mp(i,n,rmat_m)-ratio_Mp(i,n,rmas_m),0.0_PS)
          endif
        enddo
        enddo
      end if
    elseif(g%token==2) then
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate growth of axis lengths

!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
        icond1(i,n)=0
        if(icond3(i,n)==1) then
          if(level<=5.or.&
            (level>=6.and.ag%TV(n)%T<T_0.and.g%MS(i,n)%inmlt==0)) then
            ! dry growth
            icond1(i,n)=1
          else
            ! wet growth
            icond1(i,n)=2
          endif
        endif
      enddo
      enddo

      call cal_growth_mode_hex_inl_vec(igm,g%N_bin,g%L,ihabit_gm_random &
                        ,ag%TV(1:g%L)%T,ag%TV(1:g%L)%s_v(2),rdsd)


!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
        if(icond1(i,n)==1) then
          ! dry growth
          select case(g%IS(i,n)%sh_type)
          case(1,2)
          ! for ice crystals
!!c         len_switch(1)=dend_zone(level,ag%TV(n),d_mm_hex,&
            len_switch(i,n,1)=dend_zone(level,ag%TV(n),d_mean_mass(i,n),&
                  g%MS(i,n)%a_len,g%IS(i,n)%d,mes_rc(n))

            if(ag%TV(n)%T<=253.16) then
              if(g%IS(i,n)%init_growth==1) then
!!c             if(g%IS(i,n)%growth_mode/=2.and.g%IS(i,n)%growth_mode/=3) then
                   gamma_d=gamma(n,igm(i,n))
!!c                write(*,'("gamma_d,gmode",3ES15.6,I5)') ag%TV(n)%T,ag%TV(n)%s_v(2),gamma_d,g%IS(i,n)%growth_mode
              elseif(g%IS(i,n)%growth_mode/=2.and.g%IS(i,n)%growth_mode/=3) then
                if(g%IS(i,n)%phi_ic>=1.0_PS) then
                  gamma_d=gamma(n,2)
                else
                  gamma_d=gamma(n,1)
                end if
              else
                gamma_d=gamma(n,g%IS(i,n)%growth_mode-1)
              end if
            else
              ! NOTE: gamma is set up to be the same in T>-20C for planar and columnar growths.
              gamma_d=gamma(n,1)
            end if


            call acd_mode(ag%TV(n),g%MS(i,n)%a_len,g%MS(i,n)%c_len &
                  ,ex_vden(i,n) &
                  ,gamma_d,g%MS(i,n)%fac,g%MS(i,n)%mean_mass,d_mean_mass(i,n) &
!!c               ,gamma_d,g%MS(i,n)%fac,d_mm_hex&
!!c               ,gamma_d,g%MS(i,n)%fac,d_mean_mass/(1.0_PS+g%IS(i,n)%n_exice)&
                  ,d_axis_len(i,n,1),d_axis_len(i,n,2))

!!c             call high_mode5(g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%r,g%IS(i,n)%e&
!!c                     ,Mp(i,n)/g%MS(i,n)%con,d_mean_mass,g%IS(i,n)%growth_mode&
!!c                     ,d_axis_len,len_switch)
!!c          elseif(g%IS(i,n)%sh_type<=4) then
          case default
            !
            ! dry growth of aggregates, rimed aggregates
            !
            n_ice=(g%MS(i,n)%mass(imc)+g%MS(i,n)%mass(ima))/&
                   g%MS(i,n)%mass(imc)
            d_mm_ice=d_mean_mass(i,n)/n_ice
            mass_ice=g%MS(i,n)%mass(imc)/g%MS(i,n)%con

            len_switch(i,n,1)=dend_zone(level,ag%TV(n),d_mm_ice,&
                 g%MS(i,n)%a_len,g%IS(i,n)%d,mes_rc(n))

            if(ag%TV(n)%T<=253.16) then
              if(g%IS(i,n)%init_growth==1) then
                gamma_d=gamma(n,igm(i,n))
              elseif(g%IS(i,n)%growth_mode/=2.and.g%IS(i,n)%growth_mode/=3) then
                if(g%IS(i,n)%phi_ic>=1.0_PS) then
                  gamma_d=gamma(n,2)
                else
                  gamma_d=gamma(n,1)
                end if
              else
                gamma_d=gamma(n,g%IS(i,n)%growth_mode-1)
              end if
            else
              ! NOTE: gamma is set up to be the same in T>-20C for planar and columnar growths.
              gamma_d=gamma(n,1)
            end if


            call acd_mode(ag%TV(n),g%MS(i,n)%a_len,g%MS(i,n)%c_len&
                  ,ex_vden(i,n)&
                  ,gamma_d,g%MS(i,n)%fac,mass_ice,d_mm_ice&
                  ,d_axis_len(i,n,1),d_axis_len(i,n,2))

            if(d_mean_mass(i,n)<0.0_PS) then
              ! calculate diameter and mass of average crystal component
              dia_ice=(g%IS(i,n)%V_ic/coefpi6)**(1.0/3.0)
              den_ice=mass_ice/g%IS(i,n)%V_ic
              dia_par=(g%IS(i,n)%V_cs/coefpi6)**(1.0/3.0)

              ! calculate the coefficient of density-max dimension relationship
              call cal_dendim_coef2(aa,bb,&
                                   den_ice,dia_ice,mass_ice,&
                                   g%IS(i,n)%den_ip,dia_par,mass_par)

              if(bb<-1.0e-25_PS) then
                ! assume den=aa*dia_par**bb for evaporation
                d_vol(i,n,1)=d_mean_mass(i,n)/g%IS(i,n)%den_ip*&
                   max(0.0_PS,1.0_PS-g%IS(i,n)%V_cs/coefpi6*(aa/g%IS(i,n)%den_ip)**(3.0/bb)*&
                      bb/(3.0_PS+bb))
              else
                d_vol(i,n,1)=d_mean_mass(i,n)/g%IS(i,n)%den_ip

              endif
            else
!!c                d_vol(i,n,1)=d_mean_mass(i,n)/g%IS(i,n)%den_ip
              ! this is the minimum growth of volume
              d_vol(i,n,1)=d_mean_mass(i,n)/den_i
            endif


          end select
        elseif(icond1(i,n)==2) then
          if(dMcon(i,n)>0.0_PS) then
            ! case of wet growth
            ! NOTE: wet growth is reflected only to melt mass component.
            !       V_cs is not changed because it is circumscribing sphere volume of dry ice particle.
            d_vol(i,n,1)=0.0_PS
            iwet(i,n)=1
          else
            ! case of wet evaporation

            devap_ice=(g%MS(i,n)%mass(imw)+dMcon(i,n))/g%MS(i,n)%con
            mass_ice=g%MS(i,n)%mass(imc)/g%MS(i,n)%con
            if(devap_ice<0.0_PS) then
              select case(g%IS(i,n)%sh_type)
              case(1,2)
                ! for ice crystals
                len_switch(i,n,1)=dend_zone(level,ag%TV(n),devap_ice,&
                        g%MS(i,n)%a_len,g%IS(i,n)%d,mes_rc(n))

                if(ag%TV(n)%T<=253.16) then
                  if(g%IS(i,n)%init_growth==1) then
                    gamma_d=gamma(n,igm(i,n))
                  elseif(g%IS(i,n)%growth_mode/=2.and.g%IS(i,n)%growth_mode/=3) then
                    if(g%IS(i,n)%phi_ic>=1.0_PS) then
                      gamma_d=gamma(n,2)
                    else
                      gamma_d=gamma(n,1)
                    end if
                  else
                    gamma_d=gamma(n,g%IS(i,n)%growth_mode-1)
                  end if
                else
                  ! NOTE: gamma is set up to be the same in T>-20C for planar and columnar growths.
                  gamma_d=gamma(n,1)
                end if


                call acd_mode(ag%TV(n),g%MS(i,n)%a_len,g%MS(i,n)%c_len&
                        ,ex_vden(i,n)&
                        ,gamma_d,g%MS(i,n)%fac,mass_ice,devap_ice&
                        ,d_axis_len(i,n,1),d_axis_len(i,n,2))

              case default
                ! for aggregates and rimed aggregates
                n_ice=(g%MS(i,n)%mass(imc)+g%MS(i,n)%mass(ima))/&
                       g%MS(i,n)%mass(imc)

                d_mm_ice=devap_ice/n_ice

                len_switch(i,n,1)=dend_zone(level,ag%TV(n),d_mm_ice,&
                      g%MS(i,n)%a_len,g%IS(i,n)%d,mes_rc(n))

                if(ag%TV(n)%T<=253.16) then
                  if(g%IS(i,n)%init_growth==1) then
                    gamma_d=gamma(n,igm(i,n))
                  elseif(g%IS(i,n)%growth_mode/=2.and.g%IS(i,n)%growth_mode/=3) then
                    if(g%IS(i,n)%phi_ic>=1.0_PS) then
                      gamma_d=gamma(n,2)
                    else
                      gamma_d=gamma(n,1)
                    end if
                  else
                    gamma_d=gamma(n,g%IS(i,n)%growth_mode-1)
                  end if
                else
                  ! NOTE: gamma is set up to be the same in T>-20C for planar and columnar growths.
                  gamma_d=gamma(n,1)
                end if


                call acd_mode(ag%TV(n),g%MS(i,n)%a_len,g%MS(i,n)%c_len&
                        ,ex_vden(i,n)&
                        ,gamma_d,g%MS(i,n)%fac,mass_ice,d_mm_ice&
                        ,d_axis_len(i,n,1),d_axis_len(i,n,2))

                dia_ice=(g%IS(i,n)%V_ic/coefpi6)**(1.0_PS/3.0_PS)
                den_ice=mass_ice/g%IS(i,n)%V_ic
                dia_par=(g%IS(i,n)%V_cs/coefpi6)**(1.0_PS/3.0_PS)

                ! calculate the coefficient of density-max dimension relationship
                call cal_dendim_coef2(aa,bb,&
                                   den_ice,dia_ice,mass_ice,&
                                   g%IS(i,n)%den_ip,dia_par,mass_par)

                if(bb<-1.0e-25_PS) then
                  ! assume den=aa*dia_par**bb
                  d_vol(i,n,1)=devap_ice/g%IS(i,n)%den_ip*&
                  max(0.0_PS,1.0_PS-g%IS(i,n)%V_cs/coefpi6*(aa/g%IS(i,n)%den_ip)**(3.0/bb)*&
                             bb/(3.0_PS+bb))
                else
                  d_vol(i,n,1)=devap_ice/g%IS(i,n)%den_ip
                endif

              end select
            else
              d_vol(i,n,1)=0.0_PS
              iwet(i,n)=1
            end if

          end if
        end if
      enddo
      enddo
!!c       if(len_switch(1)/=0) then
!!c          if((g%IS(i,n)%d+d_axis_len(1))/(g%MS(i,n)%a_len+d_axis_len(1))>2.0/3.0.and.&
!!c              (g%MS(i,n)%c_len+d_axis_len(2))/(g%MS(i,n)%a_len+d_axis_len(1))<1.0) then
!!c             write(*,*) "2 dendrite forming at bin,grid,T",i,n,ag%TV(n)%T-273.16
!!c             write(*,'("d_axislen(1,2)",5ES15.6)') d_axis_len(1:2)
!!c             write(*,*) "alen,clen,d",g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d
!!c          else
!!c             write(*,*) "2 den not forming at bin,grid,T",i,n,ag%TV(n)%T-273.16
!!c             write(*,'("d_axislen(1,2)",5ES15.6)') d_axis_len(1:2)
!!c             write(*,*) "alen,clen,d",g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d
!!c          end if
!!c       end if
      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! calculate the ratio of total masss in the shifted bin for each component
!      do ijn=1,g%n_bin*g%N_masscom*g%L
!        in=(ijn-1)/g%N_masscom+1
!        j=ijn-(in-1)*g%N_masscom
!        n=(in-1)/g%n_bin+1
!        i=in-(n-1)*g%n_bin
      do j = 1, g%N_masscom
      do n = 1, g%L
      do i = 1, g%n_bin
        left_mass(i,n,j)=g%MS(i,n)%mass(1+j)
      enddo
      enddo
      enddo

      if(level<=5) then

!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN

          ierr(i,n)=0
          if(real(icond1(i,n),PS_KIND)*dMcon(i,n)>0.0_PS ) then
            !--- case of deposition ---
            if( g%IS(i,n)%sh_type <= 2 ) then
              ratio_Mp(i,n,imc_m) = (g%MS(i,n)%mass(imc)+dMcon(i,n))/Mp(i,n)
              ratio_Mp(i,n,ima_m) = g%MS(i,n)%mass(ima)/Mp(i,n)
              ratio_Mp(i,n,imr_m) = g%MS(i,n)%mass(imr)/Mp(i,n)
            else
              f_ice=g%MS(i,n)%mass(imc)/&
                  (g%MS(i,n)%mass(imc)+g%MS(i,n)%mass(ima))

              ratio_Mp(i,n,imc_m) =(g%MS(i,n)%mass(imc)+dMcon(i,n)*f_ice)/Mp(i,n)
              ratio_Mp(i,n,ima_m) = (g%MS(i,n)%mass(ima)+dMcon(i,n)*(1.0_PS-f_ice))/Mp(i,n)
              ratio_Mp(i,n,imr_m) = g%MS(i,n)%mass(imr)/Mp(i,n)
            endif

          elseif(real(icond1(i,n),PS_KIND)*dMcon(i,n)<0.0_PS ) then
            !--- case of evaporation ---
            ! melt water mass
            ! assumption: evaporate water mass first.

            ! assume that hydrometeor evaporate by keeping the ratio between
            ! graupel and (aggregate+crystal mass) the same, and the ratio
            ! between aggregate and crystal mass the same.
             call dep_mass3_vec2(dMcon(i,n),g%MS(i,n)%con,g%MS(i,n)%mass,&
                            left_mass(i,n,1),ierr(i,n))
!!c             call dep_mass2(dMcon(i,n),g%MS(i,n)%mass,&
!!c                            left_mass,ierr,'cal_ratio_mass_vd_1')

            ratio_Mp(i,n,imr_m)=left_mass(i,n,imr_m)/Mp(i,n)
            ratio_Mp(i,n,ima_m)=left_mass(i,n,ima_m)/Mp(i,n)
            ratio_Mp(i,n,imc_m)=left_mass(i,n,imc_m)/Mp(i,n)

          end if

          ! Adjustments on mass components
          if(icond1(i,n)>0) then
            if(ratio_Mp(i,n,ima_m)<1.0e-6_PS.and.ratio_Mp(i,n,imr_m)<1.0e-6_PS) then
              ratio_Mp(i,n,imr_m)=0.0_PS
              ratio_Mp(i,n,ima_m)=0.0_PS
              ratio_Mp(i,n,imc_m)=1.0_PS
            elseif(ratio_Mp(i,n,ima_m)<1.0e-6_PS) then
              ratio_Mp(i,n,imc_m)=ratio_Mp(i,n,imc_m)+ratio_Mp(i,n,ima_m)
              ratio_Mp(i,n,ima_m)=0.0_PS
            end if
          end if
        enddo
        enddo

      else

!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN

          ierr(i,n)=0
          if(real(icond1(i,n),PS_KIND)*dMcon(i,n) > 0.0_PS ) then
            if(icond1(i,n)==1) then
              ! dry growth
              if( g%IS(i,n)%sh_type <= 2 ) then
                ratio_Mp(i,n,imc_m) = (g%MS(i,n)%mass(imc)+dMcon(i,n))/Mp(i,n)
                ratio_Mp(i,n,ima_m) = g%MS(i,n)%mass(ima)/Mp(i,n)
                ratio_Mp(i,n,imr_m) = g%MS(i,n)%mass(imr)/Mp(i,n)
              else
                f_ice=g%MS(i,n)%mass(imc)/&
                       (g%MS(i,n)%mass(imc)+g%MS(i,n)%mass(ima))

                ratio_Mp(i,n,imc_m) = (g%MS(i,n)%mass(imc)+dMcon(i,n)*f_ice)/Mp(i,n)
                ratio_Mp(i,n,ima_m) = (g%MS(i,n)%mass(ima)+dMcon(i,n)*(1.0_PS-f_ice))/Mp(i,n)
                ratio_Mp(i,n,imr_m) = g%MS(i,n)%mass(imr)/Mp(i,n)

              end if
              ! melt water mass
              ratio_Mp(i,n,imw_m)=g%MS(i,n)%mass(imw)/Mp(i,n)
              ! freezing nucleation mass
              ratio_Mp(i,n,imf_m)=g%MS(i,n)%mass(imf)/Mp(i,n)

            else
              ! wet growth
              ratio_Mp(i,n,imr_m)=g%MS(i,n)%mass(imr)/Mp(i,n)
              ratio_Mp(i,n,ima_m)=g%MS(i,n)%mass(ima)/Mp(i,n)
              ratio_Mp(i,n,imc_m)=g%MS(i,n)%mass(imc)/Mp(i,n)
              ! melt water mass
              ratio_Mp(i,n,imw_m)=(g%MS(i,n)%mass(imw)+dMcon(i,n))/Mp(i,n)
              ! freezing nucleation mass
              ratio_Mp(i,n,imf_m)=g%MS(i,n)%mass(imf)/Mp(i,n)
            endif
          elseif(real(icond1(i,n),PS_KIND)*dMcon(i,n) < 0.0_PS ) then
            ! melt water mass
            ! assumption: evaporate water mass first.
            ratio_Mp(i,n,imw_m)=max(0.0_PS,g%MS(i,n)%mass(imw)+dMcon(i,n))/Mp(i,n)
            dMcon(i,n)=dMcon(i,n)+g%MS(i,n)%mass(imw)
            if(dMcon(i,n)<0.0_PS) then
              ! assume that hydrometeor evaporate by keeping the ratio between
              ! graupel and (aggregate+crystal mass) the same, and the ratio
              ! between aggregate and crystal mass the same.
              call dep_mass3_vec2(dMcon(i,n),g%MS(i,n)%con,g%MS(i,n)%mass,&
                             left_mass(i,n,1),ierr(i,n))
!!c                call dep_mass2(dMcon(i,n),g%MS(i,n)%mass,&
!!c                               left_mass,ierr,'cal_ratio_mass_vd_2')
            end if

            ratio_Mp(i,n,imr_m)=left_mass(i,n,imr_m)/Mp(i,n)
            ratio_Mp(i,n,ima_m)=left_mass(i,n,ima_m)/Mp(i,n)
            ratio_Mp(i,n,imc_m)=left_mass(i,n,imc_m)/Mp(i,n)

            ! freezing nucleation mass
            ratio_Mp(i,n,imf_m)=min(ratio_Mp(i,n,imc_m),g%MS(i,n)%mass(imf)/Mp(i,n))
          endif

          ! Adjustments on mass components
          if(icond1(i,n)>0) then
            if(ratio_Mp(i,n,ima_m)<1.0e-6_PS.and.ratio_Mp(i,n,imr_m)<1.0e-6_PS &
              .and.ratio_Mp(i,n,imw_m)<1.0e-6_PS) then
              ratio_Mp(i,n,imr_m)=0.0_PS
              ratio_Mp(i,n,ima_m)=0.0_PS
              ratio_Mp(i,n,imc_m)=1.0_PS
              ratio_Mp(i,n,imw_m)=0.0_PS
            elseif(ratio_Mp(i,n,ima_m)<1.0e-6_PS) then
              ratio_Mp(i,n,imc_m)=ratio_Mp(i,n,imc_m)+ratio_Mp(i,n,ima_m)
              ratio_Mp(i,n,ima_m)=0.0_PS
            end if
            ratio_Mp(i,n,imf_m)=min(ratio_Mp(i,n,imc_m),ratio_Mp(i,n,imf_m))

          endif

        enddo
        enddo
      end if

      if ( debug ) then
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
            if(ierr(i,n)>0) then
               f_ice=g%MS(i,n)%mass(imc)/(g%MS(i,n)%mass(imc)+g%MS(i,n)%mass(ima))
               rat=g%MS(i,n)%mass(imr)/(g%MS(i,n)%mass(imc)+g%MS(i,n)%mass(ima)+g%MS(i,n)%mass(imr))
               write(*,*) "dep_mass3,everything is 0! cal_ratio_mass_vd_vec"
               write(*,*) "dMcon",dMcon(i,n)
               write(*,*) "masscom",g%MS(i,n)%mass
               write(*,*) "rat,f_ice",rat,f_ice
               write(*,*) "left_mass",left_mass(i,n,:)
!!c           stop
            endif
         enddo
         enddo
      end if

      ! aerosol mass components
      if(level>=4) then
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN

          if(icond1(i,n)>0) then
            ratio_Mp(i,n,imat_m)=g%MS(i,n)%mass(imat)/Mp(i,n)
            ratio_Mp(i,n,imas_m)=g%MS(i,n)%mass(imas)/Mp(i,n)
            ratio_Mp(i,n,imai_m)=max(ratio_Mp(i,n,imat_m)-ratio_Mp(i,n,imas_m),0.0_PS)
          endif
        enddo
        enddo
      end if
    endif

  end subroutine cal_ratio_mass_vd_vec

!!$  subroutine deposition_mode_vec(gs,ga,ag,level &
!!$                                ,vigp,rdsd,ihabit_gm_random)
!!$    use mod_amps_utility, only: get_growth_mode_hex &
!!$                         ,cal_growth_mode_hex_inl_vec,random_genvar
!!$!tmp    use mod_amps_utility, only: get_growth_mode_hex_max
!!$    ! -----------------------------------------------------------------------------------------
!!$    ! assume insoluble particles to nucleate.
!!$    ! -----------------------------------------------------------------------------------------
!!$    ! solid hydrometeor group
!!$    type (Group), intent(inout)   :: gs
!!$    ! aerosol group
!!$    type (Group), dimension(*)  :: ga
!!$    ! thermo variable object
!!$    type (AirGroup), intent(inout)  :: ag
!!$    ! level of complexity
!!$    integer, intent(in)           :: level
!!$
!!$    !integer :: ID(*),JD(*),KD(*)
!!$    !
!!$    ! Inherent Growth parameterization
!!$    type (vap_igp_aux),intent(in) :: vigp
!!$    type(random_genvar),intent(inout) :: rdsd
!!$    ! random generaion: 1, max frequency: 0
!!$    integer, intent(in)           :: ihabit_gm_random
!!$
!!$    ! message from reality-check
!!$    !integer,dimension(*)   :: mes_rc
!!$    !integer,intent(in)            :: flagp_a
!!$
!!$    ! the nucleated ice mass, and the aerosol mass
!!$    real(PS),dimension(LMAX) :: am1,am0
!!$    ! radius of the nucleated ice crystal
!!$    real(PS),dimension(LMAX) :: r0
!!$    ! number concentration of existing ice particles
!!$    real(PS),dimension(LMAX) :: ni_0
!!$
!!$    integer,dimension(LMAX) :: IBI
!!$
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! tendency of
!!$    ! (1) mass (g/cm^3)
!!$    ! (2) concentration (#/cm^3)
!!$    ! (3) volume (cm^3/cm^3)
!!$    real(PS), dimension(3)        :: tend
!!$
!!$    ! produced concentration of ice nuclei
!!$    real(PS)                      :: N_IN
!!$    ! temperature of freezing
!!$    real(PS), parameter           :: TF = 273.16
!!$
!!$    ! change of mass at mean mass point
!!$    real(PS)                      :: d_mean_mass
!!$
!!$    ! inherent growth ratio
!!$    real(PS),dimension(2,LMAX)            :: gamma
!!$    real(PS)          :: gamma_d
!!$    real(PS)     :: ex_vden
!!$    real(PS)     :: cmod_inh
!!$
!!$    integer,dimension(LMAX)            :: growth_mode
!!$
!!$    ! non-mass variables of a representative particle in the shifted bin
!!$    ! argument 1 : volume of circumscribing sphere
!!$    !          2 : a-axis length
!!$    !          3 : c-axis length
!!$    !          4 : d-axis length
!!$    !          5 : r-axis length
!!$    !          6 : volume by riming
!!$    !          7 : volume by aggregation
!!$    !          8 : semi major axis length
!!$    !          9 : semi minor axis length
!!$    real(PS), dimension(mxnnonmc+2,LMAX)             :: Qp
!!$
!!$    real(PS), dimension(2,LMAX) :: d_axis_len
!!$
!!$    integer,dimension(LMAX)            :: icond1,icond2 &
!!$                                         ,ierror
!!$
!!$    ! random number
!!$    integer,dimension(LMAX) :: igm
!!$
!!$    real(PS),parameter :: mlmt=1.0e-30,nlmt=1.0e-30
!!$    real(PS) :: phi,den_max
!!$
!!$    ! type of process
!!$    integer                       :: pro_type=7
!!$
!!$    !integer    :: em ! not used
!!$    integer    :: i,n
!!$
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the inherent growth ratio
!!$    call cal_inherent_growth_ratio_vec(ag,gamma,vigp)
!!$
!!$
!!$    do n=1,ag%L
!!$! changed for SHEBA simulation
!!$    if( ( ( ag%TV(n)%T_n <= TF-5.0.and.ag%TV(n)%s_v_n(1) > 0.0_PS) .or.&
!!$          ( ag%TV(n)%s_v_n(2) >= 0.05_PS.and.ag%TV(n)%T_n < TF )).and.&
!!$!!c      if( ( (ag%TV(n)%s_v_n(2) >= 0.05_PS).and.(ag%TV(n)%T_n < TF ) ).and.&
!!$! end changed for SHEBA simulation
!!$         (ga(2)%MS(1,n)%con>=nlmt.and.ga(2)%MS(1,n)%mass(1)>=mlmt) ) then
!!$        icond1(n)=1
!!$      else
!!$        icond1(n)=0
!!$      endif
!!$    enddo
!!$
!!$    call cal_growth_mode_hex_inl_vec(igm,1,ag%L,ihabit_gm_random &
!!$                      ,ag%TV(1:ag%L)%T,ag%TV(1:ag%L)%s_v(2),rdsd)
!!$
!!$    do n=1,ag%L
!!$      d_axis_len(1,n)=0.0
!!$      d_axis_len(2,n)=0.0
!!$      ierror(n)=0
!!$      if(icond1(n)==1.and.ag%TV(n)%s_v_n(2)>0.0_PS) then
!!$        icond2(n)=1
!!$
!!$
!!$        ! adjust inherent ratio according to the timestep used.
!!$        !   The timstep adjusted ranges from 20 sec to 0.1 sec.
!!$        !   The regime T<-20 C is less senstive to the inherent growth since the
!!$        !   growth is much weaker.
!!$        if(ag%TV(n)%T-273.16>-20.0_PS) then
!!$          cmod_inh=get_cmod_inh(gs%dt)
!!$        else
!!$          cmod_inh=0.5_PS
!!$        endif
!!$        gamma(1,n) = 10.0_PS**(cmod_inh*log10(gamma(1,n)))
!!$        gamma(2,n) = 10.0_PS**(cmod_inh*log10(gamma(2,n)))
!!$        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$        ! +++ calculate the excess vapor density +++
!!$        ex_vden=ag%TV(n)%s_v(2)*ag%TV(n)%e_sat(2)/(R_v*ag%TV(n)%T)
!!$
!!$        if(ag%TV(n)%T<=253.16) then
!!$          if(ag%TV(n)%nuc_gmode/=2.and.ag%TV(n)%nuc_gmode/=3) then
!!$            gamma_d=gamma(igm(n),n)
!!$          else
!!$            gamma_d=gamma(ag%TV(n)%nuc_gmode-1,n)
!!$          end if
!!$        else
!!$          ! NOTE: gamma is set up to be the same in T>-20C for planar and columnar growths.
!!$          gamma_d=gamma(1,n)
!!$        end if
!!$
!!$        r0(n)=((ga(2)%MS(1,n)%mean_mass/den_i)/3.0_PS/sq_three)**(1.0/3.0)
!!$
!!$        am0(n)=ga(2)%MS(1,n)%mean_mass
!!$
!!$        d_mean_mass=ga(2)%MS(1,n)%coef(1)*ag%TV(n)%s_v_n(2)*gs%dt
!!$        am1(n)=am0(n)+d_mean_mass
!!$
!!$        call acd_mode(ag%TV(n),r0(n),r0(n)&
!!$             ,ex_vden &
!!$             ,gamma_d,1.0_PS,am0(n),d_mean_mass,d_axis_len(1,n))
!!$
!!$
!!$        phi=(r0(n)+d_axis_len(2,n))/(r0(n)+d_axis_len(1,n))
!!$        den_max=coef3sq3*phi*den_i/(coef4pi3*(1.0+phi**2)**1.5)
!!$        d_axis_len(1,n)=(am1(n)/den_max/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi**2.0)-r0(n)
!!$        d_axis_len(2,n)=(r0(n)+d_axis_len(1,n))*phi-r0(n)
!!$      else
!!$        icond2(n)=0
!!$        am1(n)=ga(2)%MS(1,n)%mean_mass
!!$
!!$      endif
!!$    enddo
!!$
!!$    if(level==3.or.level==5.or.level==7) then
!!$      do n=1,ag%L
!!$        if(ag%TV(n)%T<=253.16) then
!!$          growth_mode(n)=ag%TV(n)%nuc_gmode
!!$        else
!!$          if(d_axis_len(1,n)>d_axis_len(2,n)) then
!!$            growth_mode(n)=2
!!$          else
!!$            growth_mode(n)=3
!!$          end if
!!$        end if
!!$      enddo
!!$    else
!!$      do n=1,ag%L
!!$        if(d_axis_len(1,n)>d_axis_len(2,n)) then
!!$          growth_mode(n)=2
!!$        else
!!$          growth_mode(n)=3
!!$        end if
!!$      enddo
!!$    end if
!!$
!!$    call assign_Qpini_v3_vec(Qp,ag,am1,am1,r0,r0,icond2,d_axis_len,growth_mode)
!!$
!!$    do n=1,ag%L
!!$      if(icond1(n)==1.and.(icond2(n)==0.or.am1(n)<gs%binb(1))) then
!!$        ! assume that the mass reaches to gs%binb(1) quickly over the time step.
!!$!!c        mod_rat=gs%binb(1)*1.1_PS/am1(n)
!!$        am1(n)=gs%binb(1)*1.1_PS
!!$
!!$!!c        am0(n)=gs(2)%MS(1,n)%mean_mass
!!$!!c        d_mean_mass(n)=am1(n)-am0(n)
!!$
!!$        Qp(iacr,n)=(am1(n)/den_i/coef3s)**(1.0/3.0)
!!$        Qp(iccr,n)=Qp(iacr,n)
!!$        Qp(ivcs,n)=coef4pi3*(Qp(iacr,n)**2+Qp(iccr,n)**2)**1.5
!!$      endif
!!$    enddo
!!$
!!$
!!$    do n=1,ag%L
!!$
!!$      icond2(n)=icond1(n)
!!$      ni_0(n)=0.0_PS
!!$
!!$      if(icond1(n)==1) then
!!$        if(am1(n)/(coef4pi3*(Qp(iacr,n)**2+Qp(iccr,n)**2)**1.5)<1.0e-3) then
!!$          ierror(n)=1
!!$        endif
!!$        ! maximum possible bulk sphere density of pristine hexagonal crystal
!!$        den_max=coef3sq3*(Qp(iccr,n)/Qp(iacr,n))*den_i*(1.0-(Qp(idcr,n)/Qp(iacr,n)))/&
!!$            (coef4pi3*(1.0+(Qp(iccr,n)/Qp(iacr,n))**2)**1.5)
!!$        if(1.01*den_max<am1(n)/(coef4pi3*(Qp(iacr,n)**2+Qp(iccr,n)**2)**1.5)) then
!!$          ierror(n)=ierror(n)+2
!!$
!!$        endif
!!$
!!$        Qp(iacr,n)=Qp(iacr,n)*Qp(iacr,n)*Qp(iacr,n)
!!$        Qp(iccr,n)=Qp(iccr,n)*Qp(iccr,n)*Qp(iccr,n)
!!$      endif
!!$    enddo
!!$
!!$    if(any(ierror(1:ag%L)>0)) then
!!$      do n=1,ag%L
!!$        if(ierror(n)==1.or.ierror(n)==3) then
!!$          write(*,*) "dep in> small den",n,am1(n),Qp(iacr,n),Qp(iccr,n),&
!!$               am1(n)/(coef4pi3*(Qp(iacr,n)**2+Qp(iccr,n)**2)**1.5)
!!$        elseif(ierror(n)==2.or.ierror(n)==3) then
!!$          write(*,*) "dep in> large den",n,am1(n),Qp(iacr,n),Qp(iccr,n),&
!!$               am1(n)/(coef4pi3*(Qp(iacr,n)**2+Qp(iccr,n)**2)**1.5),den_max
!!$        endif
!!$      enddo
!!$    endif
!!$
!!$    ! find the ice bin that contain the am1(n).
!!$    do i=1,gs%N_BIN
!!$      do n=1,ag%L
!!$        if(icond2(n)==1) then
!!$          if(gs%binb(i)<=am1(n).and.am1(n)<gs%binb(i+1)) then
!!$            IBI(n)=i
!!$            icond2(n)=0
!!$          end if
!!$        end if
!!$        ! calculate the current number concentration of ice crystals
!!$        ni_0(n)=ni_0(n)+gs%MS(i,n)%con
!!$      end do
!!$    end do
!!$
!!$    do n=1,ag%L
!!$      if(icond1(n)==1) then
!!$! changed for SHEBA
!!$! sheba       N_IN = min(get_inact(ag%TV(n)%s_v_n(2)),ga(2)%MS(1,n)%con)
!!$!         N_IN = min(get_inact(ag%TV(n)%s_v_n(2)),ga(2)%MS(1,n)%con) ! SHEBA CHIARUI
!!$        N_IN=min(max(get_inact_tropic(ag%TV(n)%s_v_n(2),ag%TV(n)%T_n)-ni_0(n),0.0_PS)  &
!!$            ,ga(2)%MS(1,n)%con)
!!$!!!        N_IN=max(0.0_PS,ga(2)%MS(1,n)%con-ni_0(n))
!!$! end changed for SHEBA
!!$
!!$!!c       tend(2) = max( N_IN - gs%MS(1,n)%con, 0.0_PS)/gs%dt
!!$        tend(2) = max(N_IN,0.0_PS)/gs%dt
!!$
!!$        tend(1) = tend(2)*am1(n)
!!$
!!$!!c        write(*,*) "dep check",n,N_IN,ga(2)%MS(1,n)%con,ni_0(n)
!!$        ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$        ! put all the nucleated ices into the IBI bin.
!!$        gs%MS(IBI(n),n)%dmassdt(imt,pro_type)=tend(1)
!!$        gs%MS(IBI(n),n)%dmassdt(imc,pro_type)=tend(1)
!!$
!!$        gs%MS(IBI(n),n)%dcondt(pro_type)=tend(2)
!!$
!!$        ! aerosol tendency
!!$        ga(2)%MS(1,n)%dcondt(pro_type)=-tend(2)
!!$        ga(2)%MS(1,n)%dmassdt(amt,pro_type)=-tend(2)*ga(2)%MS(1,n)%mean_mass
!!$      endif
!!$    enddo
!!$
!!$!    do in=1,gs%N_nonmass*ag%L
!!$!      n=(in-1)/gs%N_nonmass+1
!!$!      i=in-(n-1)*gs%N_nonmass
!!$    do n = 1, ag%L
!!$    do i = 1, gs%N_nonmass
!!$
!!$      if(icond1(n)==1) then
!!$        tend(2)=gs%MS(IBI(n),n)%dcondt(pro_type)
!!$        gs%MS(IBI(n),n)%dvoldt(i,pro_type)=tend(2)*Qp(i,n)
!!$      endif
!!$    enddo
!!$    enddo
!!$
!!$    if(level>=4) then
!!$      do n=1,ag%L
!!$        if(icond1(n)==1) then
!!$          tend(2)=gs%MS(IBI(n),n)%dcondt(pro_type)
!!$          ga(2)%MS(1,n)%dmassdt(ams,pro_type)= &
!!$            -tend(2)*ga(2)%MS(1,n)%mean_mass*ga(2)%MS(1,n)%eps_map
!!$
!!$
!!$          ga(2)%MS(1,n)%dmassdt(ami,pro_type)=&
!!$             ga(2)%MS(1,n)%dmassdt(amt,pro_type)-ga(2)%MS(1,n)%dmassdt(ams,pro_type)
!!$
!!$          gs%MS(IBI(n),n)%dmassdt(imat,pro_type)=min(gs%MS(IBI(n),n)%dmassdt(imt,pro_type)&
!!$             ,real(tend(2)*ga(2)%MS(1,n)%mean_mass,DS))
!!$
!!$          gs%MS(IBI(n),n)%dmassdt(imas,pro_type)=min(gs%MS(IBI(n),n)%dmassdt(imat,pro_type)&
!!$             ,real(tend(2)*ga(2)%MS(1,n)%mean_mass*ga(2)%MS(1,n)%eps_map,DS))
!!$
!!$          gs%MS(IBI(n),n)%dmassdt(imai,pro_type)=min(gs%MS(IBI(n),n)%dmassdt(imat,pro_type)&
!!$             ,gs%MS(IBI(n),n)%dmassdt(imat,pro_type)-gs%MS(IBI(n),n)%dmassdt(imas,pro_type))
!!$        endif
!!$      enddo
!!$    end if
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$  end subroutine deposition_mode_vec

  subroutine acd_mode(th_var,alen,clen,ex_vden&
       ,gamma,fac,mean_mass,d_mean_mass,d_axis_len1,d_axis_len2)
    implicit none
    ! level of complexity
    !integer, intent(in)           :: level
    ! thermo variable object
    type (Thermo_Var), intent(in) :: th_var

    real(PS),intent(in) :: alen,clen,ex_vden,gamma,fac!,ex_vden_env
    ! mean mass of a single crystal in the bin
    real(PS), intent(in)        :: mean_mass
    ! mass change at mean mass, not total mass change in the bin.
    real(PS), intent(in)        :: d_mean_mass
    ! change in a-axis and c-axis in the shifted bin
!tmp    real(PS), pointer, dimension(:)      :: d_axis_len
    real(PS)                    :: d_axis_len1
    real(PS)                    :: d_axis_len2
    ! error message
    !integer :: em

    ! inherent growth ratio with ventilation effects
    real(PS)                    :: fgamma

    ! volume for the mean mass (cm^3)
    real(PS)                    :: v
    ! volume change at mean mass
    real(PS)                    :: dv
    ! mass density at the time of deposition in g/cm^3
    real(PS)                    :: dep_den

    ! bulk density of the spheroid
    real(PS)                    :: den_sr

    ! maximum and minimum aspect ratio
    real(PS),parameter  :: phi_max=2.0e+1,phi_min=5.0e-3

    !real(PS):: dum_a,dum_c,v_cs,den_cs,den_sr0,den_cs0
    integer :: i_tmp_le0,i_dm_ge0

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! +++++++++++++++++++++ calculate the growth of a anc c axis ++++++++++++++++++++
    ! +++ calculate apparent volume based on spheroid assumption +++
    v = coef4pi3*alen*alen*clen
    den_sr=mean_mass/v
!dbg    den_sr0=den_sr

!dbg    v_cs = coef4pi3*(alen**2+clen**2 )**1.5
!dbg    den_cs0=mean_mass/v_cs

    i_tmp_le0=0.5*(1.0+sign(1.0_PS,273.16_PS-th_var%T))
    i_dm_ge0=0.5*(1.0+sign(1.0_PS,d_mean_mass))

    dep_den=real(i_tmp_le0,PS_KIND)*&
       ! +++ calculate the mass density at the time of deposition based on
       !     Chen and Lamb (1994a)
              max( 0.91_PS * exp( -3.0_PS*&
              max( ex_vden*1.0e+6_PS - 0.05_PS, 0.0_PS)/gamma), 1.0e-1_PS) &
           +(1.0-real(i_tmp_le0,PS_KIND))*&
              0.91_PS


    dv = d_mean_mass/dep_den

    ! +++ modify the inherent growth ratio to take the ventilation effects +++
    ! +++ into account.                                                    +++
    fgamma = fac*gamma
    !
    ! NOTE if the ratio of dv/v is too small, or lengths are too small compared to
    ! volume change, then axis length change becomes too large.
    ! This can lead to unrealistic bulk sphere density.
    ! a-axis
    !  So, we assume that during the evaporation
    !    1. axis ratio
    !    2. bulk density
    !    are conserved.
!org    d_axis_len1 = alen * (dv/v)/(fgamma+2.0_PS)
    d_axis_len1 = real(i_dm_ge0,PS_KIND)*alen * (dv/v)/(fgamma+2.0_PS) +&
              (1.0_RP-real(i_dm_ge0,PS_KIND))*(&
         (max(0.0_RP,mean_mass+d_mean_mass)/(den_sr*coef4pi3*clen/alen))**(1.0_RP/3.0_RP)-&
           alen)
    ! c-axis
!org    d_axis_len2 = clen * (dv/v)*fgamma/(fgamma+2.0_PS)
    d_axis_len2 = real(i_dm_ge0,PS_KIND)*clen * (dv/v)*fgamma/(fgamma+2.0_PS) +&
              (1.0_RP-real(i_dm_ge0,PS_KIND))*(&
              clen/alen*d_axis_len1)

!dbg    v_cs = coef4pi3*((alen+d_axis_len1)**2+(clen+d_axis_len2)**2 )**1.5_RP
!dbg    den_cs=(mean_mass+d_mean_mass)/v_cs
!dbg    v = coef4pi3*(alen+d_axis_len1)**2*(clen+d_axis_len2)
!dbg    den_sr=(mean_mass+d_mean_mass)/v
!!c    write(*,'("acd_mode:",I5,20ES15.6)')i_dm_ge0,d_mean_mass,dep_den,alen,clen,den_sr0,den_sr,&
!!c         den_cs0,den_cs,&
!!c         clen/alen,(clen+d_axis_len2)/(alen+d_axis_len1)
!         alen * (dv/v)/(fgamma+2.0_PS),d_mean_mass/(den_sr*coef4pi3*clen/alen),&
!         clen * (dv/v)*fgamma/(fgamma+2.0_PS),&
!         (1.0_RP-real(i_dm_ge0))*d_mean_mass/(den_sr*coef4pi3*alen*alen/(clen*clen))




    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  end subroutine acd_mode


  function dend_zone(level,th_var,d_mean_mass,alen,dlen,mes_rc) result(iout)
    ! level of complexity
    integer, intent(in)           :: level
    ! thermo variable object
    type (Thermo_Var), intent(in) :: th_var
    real(PS),intent(in) :: alen,dlen,d_mean_mass
    integer, intent(in)           :: mes_rc
    integer :: iout

    iout=0
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! case of dendritic growth
    if( level >= 2 ) then
       if(d_mean_mass>=0.0_PS) then
          if(alen>10.0e-4_PS) then
             ! -16 <= T <= -12
!!c             if( ( 257.16_PS <= th_var%T .AND. th_var%T <=  261.16_PS ).or. &
!!c                  (dlen >= 1.0e-3_PS) ) then
             if( ( ( 257.16_PS <= th_var%T .AND. th_var%T <=  261.16_PS ) &
                  .AND. (mes_rc==2.or.mes_rc==4.or.th_var%s_v(1)>=-1.0e-6_PS)) .or. &
!tmp                  .AND. th_var%s_v(1)>=-1.0e-6_PS) .or. &
                  dlen >= 1.0e-3_PS)   then
                iout=1
!!c                   write(*,'("mes_rc,sv1,sv2,dm",I5,4ES15.6)') mes_rc,th_var%s_v_n(1),th_var%s_v_n(2),d_mean_mass
             end if
          end if
       else
          if(dlen>0.0_PS) then
             iout=1
          end if
       end if
    end if
! sense test
    !iout = 0
  end function dend_zone

!!$  function dend_zone_vec(level,th_var,d_mean_mass,alen,dlen,mes_rc) result(iout)
!!$    ! level of complexity
!!$    integer, intent(in)           :: level
!!$    ! thermo variable object
!!$    type (Thermo_Var), intent(in) :: th_var
!!$    real(PS),intent(in) :: alen,dlen,d_mean_mass
!!$    integer, intent(in)           :: mes_rc
!!$    integer :: i_lvl_ge2,i_dmm_ge0,i_a_ge10,i_d_ge10 &
!!$              ,i_d_ge0,i_t_gem16,i_t_lem12,i_s_gt0 &
!!$              ,i_mesrc_eq2,i_mesrc_eq4
!!$    integer :: iout
!!$
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! case of dendritic growth
!!$    i_lvl_ge2=0.5*(1.0+sign(1.0_PS,real(level-2,PS_KIND)))
!!$    i_dmm_ge0=0.5*(1.0+sign(1.0_PS,d_mean_mass))
!!$    i_a_ge10=0.5*(1.0+sign(1.0_PS,alen-10.0e-4_PS))
!!$    i_d_ge10=0.5*(1.0+sign(1.0_PS,dlen-10.0e-4_PS))
!!$    i_d_ge0=0.5*(1.0+sign(1.0_PS,dlen))
!!$    i_t_gem16=0.5*(1.0+sign(1.0_PS,th_var%T-257.16_PS))
!!$    i_t_lem12=0.5*(1.0+sign(1.0_PS,261.16_PS-th_var%T))
!!$    i_s_gt0=0.5*(1.0+sign(1.0_PS,th_var%s_v(1)-(-1.0e-6_PS)))
!!$
!!$    i_mesrc_eq2=max(0.0_RP,(-isign(1,mes_rc-2)*max(0,mes_rc-2)+1.0_RP))*&
!!$                max(0.0_RP,(-isign(1,mes_rc-2)*min(0,mes_rc-2)+1.0_RP))
!!$    i_mesrc_eq4=max(0.0_RP,(-isign(1,mes_rc-4)*max(0,mes_rc-4)+1.0_RP))*&
!!$                max(0.0_RP,(-isign(1,mes_rc-4)*min(0,mes_rc-4)+1.0_RP))
!!$
!!$    iout=i_lvl_ge2*( &
!!$           i_dmm_ge0*&
!!$             (i_a_ge10*&
!!$               (i_t_gem16*i_t_lem12*i_mesrc_eq2 + &
!!$                i_t_gem16*i_t_lem12*i_mesrc_eq4 + &
!!$                i_t_gem16*i_t_lem12*i_s_gt0 + &
!!$                i_d_ge10) &
!!$             )+ &
!!$           (1-i_dmm_ge0)*i_d_ge0 &
!!$         )
!!$    iout=max(0,min(1,iout))
!!$
!!$!org    if( level >= 2 ) then
!!$!org       if(d_mean_mass>=0.0_PS) then
!!$!org          if(alen>10.0e-4_PS) then
!!$!org             ! -16 <= T <= -12
!!$!org             if( ( ( 257.16_PS <= th_var%T .AND. th_var%T <=  261.16_PS ) &
!!$!org                  .AND. (mes_rc==2.or.mes_rc==4.or.th_var%s_v(1)>=-1.0e-6_PS)) .or. &
!!$!org                  dlen >= 1.0e-3_PS)   then
!!$!org                iout=1
!!$!org             end if
!!$!org          end if
!!$!org       else
!!$!org          if(dlen>0.0_PS) then
!!$!org             iout=1
!!$!org          end if
!!$!org       end if
!!$!org    end if
!!$  end function dend_zone_vec

  subroutine cal_ratio_mass_col_vec( g_1, g_2, ag, level, icond3, &
      n_all,Mc, dN_ice,ratio_M_2, dM_col, Mp, ratio_Mp)
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of
    !     1. ratio of each increased mass components to total mass
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)    :: g_1, g_2
    ! thermo variable object
    type (AirGroup), intent(in) :: ag
    integer, intent(in)         :: level
    ! mass components of collecter group
!tmp    real(PS), pointer, dimension(:,:)            :: Mc
    integer,intent(in),dimension(mxnbin+1,*) :: icond3
    real(PS), dimension(mxnbin+1,mxnmasscomp,*)            :: Mc
    ! total number of sub-bins in a clctr bin
    integer,dimension(*),intent(in)         :: n_all


    ! ratio of each component mass to the total mass in the shifted bin
    ! ratio_Mp(imr_m) : rime
    ! ratio_Mp(ima_m) : aggregation
    real(PS), dimension(mxnbin+1,g_1%L,mxnmasscomp),intent(inout)   :: ratio_Mp

    ! ratio of mass components in original bin to total mass
    real(PS), dimension(mxnbin,1+mxnmasscomp,*)            :: ratio_M_2
    ! number of drops that each sub bin i collects from all the bins
    ! per a parent drop
    real(PS), dimension(mxnbin+1,*)   ::  dN_ice
    ! total mass increase by collision-coalescence process
    real(PS), dimension(mxnbin+1,mxnbin,*)      :: dM_col

    ! total mass in the shifted bin
    real(PS),dimension(mxnbin+1,*)                    :: Mp

    ! total mass change on mass component in the bin
    real(PS),dimension(mxnbin+1,LMAX)       :: dM_1,dM_2

    !real(PS)  :: ratio_ice

!    integer,dimension((mxnbin+1)*LMAX) :: ierror

    integer                     :: i,j,n,n_all_max


    n_all_max=maxval(n_all(1:g_1%L))

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if( g_1%token == 1 .and. g_2%token == 1 ) then
      ! --- case of coalescence processes ---

      if(level>=4) then

        do n = 1, g_2%L
        do j = 1, n_all_max
           ! total mass of aerosols
           dM_1(j,n) = 0.0_PS
           ! soluble mass of aerosols
           dM_2(j,n) = 0.0_PS
        end do
        end do
        do i = 1, g_2%N_BIN
!          do jn=1,n_all_max*g_2%L
!            n=(jn-1)/n_all_max+1
!            j=jn-(n-1)*n_all_max
           do n = 1, g_2%L
           do j = 1, n_all_max
            if(icond3(j,n)==1.and.j<=n_all(n)) then
              if( dM_col(j,i,n) > 0.0_PS ) then
                dM_1(j,n)=dM_1(j,n)+ratio_M_2(i,rmat_m,n)*dM_col(j,i,n)
                dM_2(j,n)=dM_2(j,n)+ratio_M_2(i,rmas_m,n)*dM_col(j,i,n)
              end if
            endif
          enddo
          enddo
        end do
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
        do n = 1, g_2%L
        do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,rmat_m)=(Mc(j,rmat_m,n)+dM_1(j,n))/Mp(j,n)
            ratio_Mp(j,n,rmas_m)=(Mc(j,rmas_m,n)+dM_2(j,n))/Mp(j,n)
            ratio_Mp(j,n,rmai_m)=max(ratio_Mp(j,n,rmat_m)-ratio_Mp(j,n,rmas_m),0.0_PS)
          end if
        enddo
        enddo
      endif
!!c       if( ratio_Mp(rmat_m)<=0.0_PS ) then
!!c          write(*,'("ratio_MP(1) is less than 0 in liq col at",I5,4ES15.6)') clctr,Mc(clctr,1:rmai_m),Mp
!!c          do i=1,g_2%N_BIN
!!c             write(*,'(I5,4ES15.6)') i,ratio_M_2(i,1),ratio_M_2(i,2),ratio_M_2(i,3),dM_col(clctr,i)
!!c          end do
!!c!!c          stop
!!c       end if
!!c       if( ratio_Mp(rmas_m)<0.0_PS ) then
!!c          write(*,'("ratio_MP(2) is less than 0 in liq col at",I5,4ES15.6)') clctr,Mc(clctr,1:rmai_m),Mp
!!c          do i=1,g_2%N_BIN
!!c             write(*,'(I5,4ES15.6)') i,ratio_M_2(i,1),ratio_M_2(i,2),ratio_M_2(i,3),dM_col(clctr,i)
!!c          end do
!!c          stop
!!c       end if

    elseif( g_1%token == 2 .and. g_2%token == 2 ) then
      ! --- case of aggregation processes ---
      ! NOTE: It is assumed that mass of collected hydrometeor
      !       is distributed as
      !       - aggregate mass of the collector hydrometeor
      !                         <= collected pristine mass and aggregate mass
      !       - rime mass of the collector hydrometeor
      !                         <= rime mass from collected hydrometeor.
      !
      do n = 1, g_2%L
      do j = 1, n_all_max
         ! rim mass
         dM_1(j,n) = 0.0_PS
         ! ice crystal mass
         dM_2(j,n) = 0.0_PS
      end do
      end do
      do i = 1, g_2%N_BIN
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            if( dM_col(j,i,n) > 0.0_PS ) then
              dM_1(j,n)=dM_1(j,n)+ratio_M_2(i,imr_m,n)*dM_col(j,i,n)
              dM_2(j,n)=dM_2(j,n)+ratio_M_2(i,imc_m,n)*dM_col(j,i,n)
            end if
          endif
        enddo
        enddo
      end do

!      ierror(1:n_all_max*g_1%L)=0
!      do jn=1,n_all_max*g_2%L
!        n=(jn-1)/n_all_max+1
!        j=jn-(n-1)*n_all_max
      do n = 1, g_2%L
      do j = 1, n_all_max
        if(icond3(j,n)==1.and.j<=n_all(n)) then
          ratio_Mp(j,n,imr_m)=(Mc(j,imr_m,n)+dM_1(j,n))/Mp(j,n)
          ratio_Mp(j,n,imc_m)=(Mc(j,imc_m,n)+dM_2(j,n))*&
                   (1.0_PS/(1.0_PS+dN_ice(j,n)))/Mp(j,n)
          if ( debug ) then
             if(ratio_Mp(j,n,imr_m)<0.0_PS) then
                write(*,*) "ratio_MP(1) is less than 0 in sol col",j,n,Mc(j,1:imf_m,n),Mp(j,n)
             endif
             if(ratio_Mp(j,n,imc_m)<0.0_PS) then
                write(*,*) "ratio_MP(3) is less than 0 in sol col",j,n,Mc(j,1:imf_m,n),Mp(j,n)
             endif
          end if
        endif
      enddo
      enddo


      ! calculate
      if(level>=6) then
        do n = 1, g_2%L
        do j = 1, n_all_max
           ! - melt water mass
           dM_1(j,n) = 0.0_PS
           ! - freezing nucleation mass
           !     on the solid hydrometeors
           dM_2(j,n) = 0.0_PS
        end do
        end do
        do i = 1, g_2%N_BIN
!          do jn=1,n_all_max*g_1%L
!            n=(jn-1)/n_all_max+1
!            j=jn-(n-1)*n_all_max
           do n = 1, g_2%L
           do j = 1, n_all_max
            if(icond3(j,n)==1.and.j<=n_all(n)) then
              if( dM_col(j,i,n) > 0.0_PS ) then
                dM_1(j,n)=dM_1(j,n)+ratio_M_2(i,imw_m,n)*dM_col(j,i,n)
                dM_2(j,n)=dM_2(j,n)+ratio_M_2(i,imf_m,n)*dM_col(j,i,n)
              end if
            endif
          enddo
          enddo
        end do

!        ierror(1:n_all_max*g_1%L)=0
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
        do n = 1, g_2%L
        do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,imw_m)=(Mc(j,imw_m,n)+dM_1(j,n))/Mp(j,n)
            ratio_Mp(j,n,imf_m)=min((Mc(j,imf_m,n)+dM_2(j,n))*&
                 (1.0_PS/(1.0_PS+dN_ice(j,n)))/Mp(j,n),&
                 ratio_Mp(j,n,imc_m))
            if ( debug ) then
               if(ratio_Mp(j,n,imw_m)<0.0_PS) then
                  write(*,*) "ratio_MP(7) is less than 0 in sol col",j,n,Mc(j,1:imf_m,n),Mp(j,n)
               endif
               if(ratio_Mp(j,n,imf_m)<0.0_PS) then
                  write(*,*) "ratio_MP(8) is less than 0 in sol col",j,n,Mc(j,1:imf_m,n),Mp(j,n)
               endif
            end if
          endif
        enddo
        enddo

      endif
      ! calculate aerosol mass components
      if(level>=4) then
        do n = 1, g_2%L
        do j = 1, n_all_max
           ! total mass of aerosols
           dM_1(j,n) = 0.0_PS
           ! soluble mass of aerosols
           dM_2(j,n) = 0.0_PS
        end do
        end do
        do i = 1, g_2%N_BIN
!          do jn=1,n_all_max*g_2%L
!            n=(jn-1)/n_all_max+1
!            j=jn-(n-1)*n_all_max
           do n = 1, g_2%L
           do j = 1, n_all_max
            if(icond3(j,n)==1.and.j<=n_all(n)) then
              if( dM_col(j,i,n) > 0.0_PS ) then
                dM_1(j,n)=dM_1(j,n)+ratio_M_2(i,imat_m,n)*dM_col(j,i,n)
                dM_2(j,n)=dM_2(j,n)+ratio_M_2(i,imas_m,n)*dM_col(j,i,n)
              end if
            endif
          enddo
          enddo
        end do
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
        do n = 1, g_2%L
        do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,imat_m)=(Mc(j,imat_m,n)+dM_1(j,n))/Mp(j,n)
            ratio_Mp(j,n,imas_m)=(Mc(j,imas_m,n)+dM_2(j,n))/Mp(j,n)
            ratio_Mp(j,n,imai_m)=max(ratio_Mp(j,n,imat_m)-ratio_Mp(j,n,imas_m),0.0_PS)
          end if
        enddo
        enddo
      endif

      ! calculate aggregation mass component
      if(level<=5) then
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,ima_m)=max(1.0_PS-ratio_Mp(j,n,imr_m)-ratio_Mp(j,n,imc_m),0.0_PS)
          end if
        enddo
        enddo
      else
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,ima_m)=max(1.0_PS-ratio_Mp(j,n,imr_m)-&
                                ratio_Mp(j,n,imc_m)-ratio_Mp(j,n,imw_m),0.0_PS)
          end if
        enddo
        enddo
      end if


!       if( ratio_Mp(ima_m)<0.0_PS ) then
!          write(*,*) "ratio_MP(2) is less than 0 in sol col",Mc(j,1:imc_m),Mp
!          do i=1,g_2%N_BIN
!             write(*,'(I5,2ES15.6)') i,ratio_M_2(i,ima_m),ratio_M_2(i,imc_m)
!          end do
!          stop
!       end if
!       if( ratio_Mp(imc_m)<=0.0_PS ) then
!          write(*,*) "ratio_MP(3) is less than 0 in sol col",Mc(j,1:imc_m),Mp
!       end if
!!c       if( sum(ratio_Mp) > 1.0_PS ) then
!!c          write(*,*) " cal_ratio_mass_col > ratio_Mp", ratio_Mp
!!c       end if
    else if(( g_1%token == 2 .and. g_2%token == 1 ) .or.  &
         ( g_1%token == 2 .and. g_2%token == 11 ))then
      ! --- case of riming processes ---
      ! riming mass
      ! assume that ice freezes after riming in T<T_0
      ! and assume stay water in T>=T_0

      do n = 1, g_2%L
      do j = 1, n_all_max
         dM_1(j,n) = 0.0_PS
      end do
      end do
      do i = 1, g_2%N_BIN
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            if( dM_col(j,i,n) > 0.0_PS ) then
              dM_1(j,n)=dM_1(j,n)+dM_col(j,i,n)
            end if
          endif
        enddo
        enddo
      end do

      if(level<=5) then
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,imr_m)=(Mc(j,imr_m,n)+dM_1(j,n))/Mp(j,n)
          end if
        enddo
        enddo
      else
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            if(ag%TV(n)%T<T_0) then
              ! sense test Ong Chia Rui
              ratio_Mp(j,n,imr_m)=(Mc(j,imr_m,n)+dM_1(j,n))/Mp(j,n)
              !ratio_Mp(j,n,imc_m)=(Mc(j,imc_m,n)+dM_1(j,n))/Mp(j,n)
              ! end of sense test
              ratio_Mp(j,n,imw_m)=Mc(j,imw_m,n)/Mp(j,n)
            else
              ! sense test Ong Chia Rui
              ratio_Mp(j,n,imr_m)=Mc(j,imr_m,n)/Mp(j,n)
              !ratio_Mp(j,n,imc_m)=Mc(j,imc_m,n)/Mp(j,n)
              ! end of sense test
              ! melt mass
              ratio_Mp(j,n,imw_m)=(Mc(j,imw_m,n)+dM_1(j,n))/Mp(j,n)
            end if
          end if
        enddo
        enddo
      endif

!      ierror(1:n_all_max*g_1%L)=0
!      do jn=1,n_all_max*g_2%L
!        n=(jn-1)/n_all_max+1
!        j=jn-(n-1)*n_all_max
      do n = 1, g_2%L
      do j = 1, n_all_max
         if(icond3(j,n)==1.and.j<=n_all(n)) then
            ! sense test Ong Chia Rui
            ! ice crystal mass
            ratio_Mp(j,n,imc_m)=Mc(j,imc_m,n)/Mp(j,n)
            !ratio_Mp(j,n,imr_m)=Mc(j,imr_m,n)/Mp(j,n)
            ! end of sense test
            ! freezing nucleation mass
            ratio_Mp(j,n,imf_m)=min(ratio_Mp(j,n,imc_m),Mc(j,imf_m,n)/Mp(j,n))
            if ( debug ) then
               if(ratio_Mp(j,n,imc_m)<0.0_PS) then
                  write(*,*) "ratio_MP(3) is less than 0 in sol col",j,n,Mc(j,1:imf_m,n),Mp(j,n)
               end if
            end if
         end if
      end do
      end do

      ! aerosol mass components
      if(level>=4) then
        do n = 1, g_2%L
        do j = 1, n_all_max
           ! total mass of aerosols
           dM_1(j,n) = 0.0_PS
           ! soluble mass of aerosols
           dM_2(j,n) = 0.0_PS
        end do
        end do
        do i = 1, g_2%N_BIN
!          do jn=1,n_all_max*g_2%L
!            n=(jn-1)/n_all_max+1
!            j=jn-(n-1)*n_all_max
           do n = 1, g_2%L
           do j = 1, n_all_max
            if(icond3(j,n)==1.and.j<=n_all(n)) then
              if( dM_col(j,i,n) > 0.0_PS ) then
                dM_1(j,n)=dM_1(j,n)+ratio_M_2(i,imat_m,n)*dM_col(j,i,n)
                dM_2(j,n)=dM_2(j,n)+ratio_M_2(i,imas_m,n)*dM_col(j,i,n)
              end if
            endif
          enddo
          enddo
        end do
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
        do n = 1, g_2%L
        do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,imat_m)=(Mc(j,imat_m,n)+dM_1(j,n))/Mp(j,n)
            ratio_Mp(j,n,imas_m)=(Mc(j,imas_m,n)+dM_2(j,n))/Mp(j,n)
            ratio_Mp(j,n,imai_m)=max(ratio_Mp(j,n,imat_m)-ratio_Mp(j,n,imas_m),0.0_PS)
          end if
        enddo
        enddo
      endif

      ! calculate aggregation mass component
      if(level<=5) then
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,ima_m)=max(1.0_PS-ratio_Mp(j,n,imr_m)-ratio_Mp(j,n,imc_m),0.0_PS)
          end if
        enddo
        enddo
      else
!        do jn=1,n_all_max*g_2%L
!          n=(jn-1)/n_all_max+1
!          j=jn-(n-1)*n_all_max
         do n = 1, g_2%L
         do j = 1, n_all_max
          if(icond3(j,n)==1.and.j<=n_all(n)) then
            ratio_Mp(j,n,ima_m)=max(1.0_PS-ratio_Mp(j,n,imr_m)-&
                                ratio_Mp(j,n,imc_m)-ratio_Mp(j,n,imw_m),0.0_PS)
          end if
        enddo
        enddo
      end if

!       if( ratio_Mp(imc_m)<=0.0_PS ) then
!          write(*,*) "ratio_MP(3) is less than 0(rim)",Mc(j,1:imc_m),Mp
!       end if
!!c       if( sum(ratio_Mp) > 1.0_PS ) then
!!c          write(*,*) " cal_ratio_mass_col > ratio_Mp", ratio_Mp
!!c       end if

    end if

  end subroutine cal_ratio_mass_col_vec

  subroutine cal_Qp2_vec( g_1, g_2, icond1, clctr, n_all, &
       N_drops, Qp, checker,dN_ice)
    use scale_prc, only: &
       PRC_abort
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculation of
    !     1. each increased/decreased quality components by collection.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)    :: g_1, g_2
    ! thermo variable object
    !type (AirGroup), intent(in)   :: ag
    !integer, intent(in)         :: level
    ! bin number of collecting hydrometeor
    integer, intent(in)         :: clctr
    integer,intent(in),dimension(mxnbin,*) :: icond1
    ! total number of sub-bins in a collector bin
    integer,dimension(*),intent(in)         :: n_all
    ! number of drops that each sub bin i collects from jth bin, N_drops(i,j)
    ! per a parent drop
!tmp    real(PS), pointer, dimension(:,:)   ::  N_drops
    real(PS), dimension(mxnbin+1,mxnbin,*)   ::  N_drops
    ! number of drops that each sub bin i collects from all the bins
    ! per a parent drop
!tmp    real(PS), pointer, dimension(:)   ::  dN_ice
    real(PS), dimension(mxnbin+1,*)   ::  dN_ice
    ! increase for the mean mass (used for riming of cloud droplets)
    !real(PS), intent(in)                            :: d_mean_mass

    ! quality variable for a particle
!tmp    real(PS), pointer, dimension(:,:)                     :: Qp
    real(PS), dimension(mxnbin+1,g_1%L,mxnnonmc+2)                     :: Qp
    ! growth in axis length
!tmp    real(PS), pointer, dimension(:,:)                     :: d_axis_len
    !real(PS), dimension(mxnbin+1,g_1%L,2)            :: d_axis_len

    ! checker of collision, 0: no collision, 1: collide
!tmp    integer, pointer, dimension(:,:)       :: checker
    integer, dimension(mxnbin+1,mxnbin,*)       :: checker
!    integer,dimension((mxnbin+1)*LMAX) :: ierror

    integer                     :: j,n,k,jj,n_all_max!,var_Status,i

    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    if( g_1%token == 2 .and. g_2%token == 2 ) then
       ! ---- aggregation process ----
       n_all_max=maxval(n_all(1:g_1%L))
       ! initialize the quality variables
!       do jn=1,n_all_max*g_1%L
!         n=(jn-1)/n_all_max+1
!         j=jn-(n-1)*n_all_max
       do n = 1, g_1%L
       do j = 1, n_all_max
         if(icond1(clctr,n)==1.and.j<=n_all(n)) then
           Qp(j,n,ivcs) = g_1%IS(clctr,n)%V_cs
           Qp(j,n,iacr) = g_1%MS(clctr,n)%a_len**3
           Qp(j,n,iccr) = g_1%MS(clctr,n)%c_len**3
           Qp(j,n,idcr) = g_1%IS(clctr,n)%d**3
           Qp(j,n,iag) = g_1%IS(clctr,n)%ag**3
           Qp(j,n,icg) = g_1%IS(clctr,n)%cg**3
           Qp(j,n,inex) = g_1%IS(clctr,n)%n_exice
           Qp(j,n,mxnnonmc+1)=  g_1%IS(clctr,n)%semi_aip**3
           Qp(j,n,mxnnonmc+2)=  g_1%IS(clctr,n)%semi_cip**3
         endif
       end do
       end do

       ! --- case of aggregation processes ---
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate the growth of a anc c axis
       call cal_growth_aclen_agg3_vec( g_1, g_2, clctr,icond1,n_all, N_drops, Qp,dN_ice)
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate average Qp
!       ierror(1:n_all_max*g_1%L)=0
!       do jn=1,n_all_max*g_1%L
!         n=(jn-1)/n_all_max+1
!         j=jn-(n-1)*n_all_max
       do n = 1, g_1%L
       do j = 1, n_all_max
          if(icond1(clctr,n)==1.and.j<=n_all(n)) then
             Qp(j,n,mxnnonmc+1)=Qp(j,n,mxnnonmc+1)**(1.0_PS/3.0_PS)
             Qp(j,n,mxnnonmc+2)=Qp(j,n,mxnnonmc+2)**(1.0_PS/3.0_PS)
             Qp(j,n,inex)=Qp(j,n,inex)/(1.0_PS+dN_ice(j,n))
             if(Qp(j,n,inex)<-1.0e+5_PS.or.Qp(j,n,inex)>1.0e+5_PS) then
                LOG_ERROR("cal_Qp2_vec",*) "ck qp unreal0, i,j,n: ",clctr,j,n
                LOG_ERROR_CONT(*) inex,g_1%N_nonmass,Qp(j,n,g_1%N_nonmass),dN_ice(j,n)
                LOG_ERROR_CONT(*) Qp(j,n,ivcs),Qp(j,n,iacr),Qp(j,n,iccr),Qp(j,n,idcr),Qp(j,n,iag),Qp(j,n,icg),Qp(j,n,inex)
                LOG_ERROR_CONT(*) "nbin,N_drops"
                do jj=1,g_2%N_BIN
                   LOG_ERROR_CONT(*) jj,N_drops(j,jj,n)
                end do
                LOG_ERROR_CONT(*) clctr,g_1%MS(clctr,n)%semi_a,g_1%MS(clctr,n)%semi_c
                LOG_ERROR_CONT(*) "2,nbin,semi_a,semi_c"
                do jj=1,g_2%N_BIN
                   LOG_ERROR_CONT('(I5,3ES15.6)') jj,g_2%MS(jj,n)%semi_a,g_2%MS(jj,n)%semi_c
                end do
                call PRC_abort
             endif
          endif
       enddo
       enddo

       ! length variables
       do k=iacr,inex-1
!         ierror(1:n_all_max*g_1%L)=0
!         do jn=1,n_all_max*g_1%L
!           n=(jn-1)/n_all_max+1
!           j=jn-(n-1)*n_all_max
          do n = 1, g_1%L
          do j = 1, n_all_max
             if(icond1(clctr,n)==1.and.j<=n_all(n)) then
                Qp(j,n,k)=(Qp(j,n,k)/(1.0_PS+dN_ice(j,n)))**(1.0_PS/3.0_PS)

                if(Qp(j,n,k)<-1.0e+5_PS.or.Qp(j,n,k)>1.0e+5_PS) then
                   LOG_ERROR("cal_Qp2_vec",*) "ck qp unreal1, i,j,n,k: ",clctr,j,n,k
                   LOG_ERROR_CONT(100) Qp(j,n,ivcs),Qp(j,n,iacr),Qp(j,n,iccr),Qp(j,n,idcr),Qp(j,n,iag),Qp(j,n,icg),Qp(j,n,inex)
100                format("Qp is unrealistic.Qp=",10ES15.6)
                   LOG_ERROR_CONT(*) "nbin,N_drops"
                   do jj=1,g_2%N_BIN
                      LOG_ERROR_CONT(*) jj,N_drops(j,jj,n)
                   end do
                   LOG_ERROR_CONT(150) clctr,g_1%MS(clctr,n)%semi_a,g_1%MS(clctr,n)%semi_c
150                format("1,ctlr,semi_a,semi_c",I5,5ES15.6)
                   LOG_ERROR_CONT(*) "2,nbin,semi_a,semi_c"
                   do jj=1,g_2%N_BIN
                      LOG_ERROR_CONT('(I5,3ES15.6)') jj,g_2%MS(jj,n)%semi_a,g_2%MS(jj,n)%semi_c
                   end do
                   call PRC_abort
                endif
             endif
          enddo
          enddo
       enddo


    else if( g_1%token == 2 .and. g_2%token == 11 ) then
       ! --- riming process ---
       LOG_ERROR("cal_Qp2_vec",*) "not written yet"
       call PRC_abort

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! calculate the growth of a anc c axis
       !
!tmp       call cal_growth_aclen_rim1( g_1, g_2, ag, clctr,ngrid, &
!tmp            d_mean_mass, Qp, d_axis_len, checker)
       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    else if( g_1%token == 2 .and. g_2%token == 1 ) then
       ! --- riming process ---
       n_all_max=maxval(n_all(1:g_1%L))
       ! initialize the quality variables
       ! +++ no change on property of ice crystals
!       do jn=1,n_all_max*g_1%L
!         n=(jn-1)/n_all_max+1
!         j=jn-(n-1)*n_all_max
       do n = 1, g_1%L
       do j = 1, n_all_max
         if(icond1(clctr,n)==1.and.j<=n_all(n)) then
           Qp(j,n,ivcs) = g_1%IS(clctr,n)%V_cs
           Qp(j,n,iacr) = g_1%MS(clctr,n)%a_len
           Qp(j,n,iccr) = g_1%MS(clctr,n)%c_len
           Qp(j,n,idcr) = g_1%IS(clctr,n)%d
           Qp(j,n,iag) = g_1%IS(clctr,n)%ag
           Qp(j,n,icg) = g_1%IS(clctr,n)%cg
           Qp(j,n,inex) = g_1%IS(clctr,n)%n_exice
           Qp(j,n,mxnnonmc+1) = g_1%IS(clctr,n)%semi_aip**3
           Qp(j,n,mxnnonmc+2) = g_1%IS(clctr,n)%semi_cip**3
         endif
       enddo
       enddo

       call cal_growth_aclen_rim6_vec( g_1, g_2, clctr, icond1, n_all, &
            N_drops, Qp, checker)

!       do jn=1,n_all_max*g_1%L
!         n=(jn-1)/n_all_max+1
!         j=jn-(n-1)*n_all_max
       do n = 1, g_1%L
       do j = 1, n_all_max
         if(icond1(clctr,n)==1.and.j<=n_all(n)) then
           Qp(j,n,mxnnonmc+1)=Qp(j,n,mxnnonmc+1)**(1.0_PS/3.0_PS)
           Qp(j,n,mxnnonmc+2)=Qp(j,n,mxnnonmc+2)**(1.0_PS/3.0_PS)
         endif
       enddo
       enddo

       ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    end if
  end subroutine cal_Qp2_vec

  subroutine cal_density_rime2(den_r,em,g_1, g_2, clctr,ngrid, cdrop)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the density of rime deposit at the surface of a graupel.
    !
    ! Use the formula by Hymsifield and Pflaum (1985) and
    !                    Rasmussen and Heymsfield (1985)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    real (PS),intent(inout) :: den_r
    integer,intent(inout) :: em
    type (Group), intent(in)    :: g_1, g_2
    integer, intent(in)         :: clctr,ngrid, cdrop
    ! thermo variable object
    !type (Thermo_Var), intent(in) :: th_var
    !real (PS)   :: out
    real (PS)   :: Y!, X
    ! impact velocity (cm/s)
    real (PS)   :: U_imp
    ! Stokes number
    !real (PS)   :: N_s
    ! minimum density (g/cm^3) according to their experiments
    real (PS), parameter    :: den_min = 0.1_PS
    ! coefficients
    real (PS)   :: A, B1, B2, B3, B4, B5!, B0

    ! switch for impact speed modification
    !integer      :: impact_modify

!tmp    impact_modify = 0
    em=0

    ! +++ calculate the Stokes number +++
    U_imp = abs(g_1%MS(clctr,ngrid)%vtm - g_2%MS(cdrop,ngrid)%vtm)
!tmp    if( impact_modify == 1 ) then
!tmp       N_s = 4.0_PS*g_1%MS(clctr,ngrid)%Nre*rho_w*(g_2%MS(cdrop,ngrid)%a_len)**2.0/&
!tmp            (9.0_PS*th_var%den*&
!tmp            (2.0_PS*max(g_1%MS(clctr,ngrid)%semi_a, g_1%MS(clctr,ngrid)%semi_c))**2.0)
!tmp
!tmp
!tmp       if(N_s<=0.0.or.N_s>=1.0e+3) then
!tmp          write(*,*) "get_density>N_s is too large or 0 or neg.",N_s
!tmp          stop
!tmp       end if
!tmp       write(*,*) N_s
!tmp       X = log10(N_s)
!tmp
!tmp       stop
!tmp       !!!! under construction.
!tmp    end if


    ! +++ now calculate the density of rimed deposits +++
    A = 0.30_PS
    B1 = 0.44_PS
    B2 = -0.03115_PS
    B3 = -1.7030_PS
    B4 = 0.9116_PS
    B5 = -0.1224_PS

    ! watch out the unit of Y
    Y = - g_2%MS(cdrop,ngrid)%a_len*U_imp*100.0_PS/(g_1%MS(clctr,ngrid)%tmp-273.16_PS)
    if( Y < 0.0_PS ) then
!       write(*,*) "The surface temperatuer is more than 0 C"
!       stop
       den_r=0.0_PS
       em=1
    elseif(U_imp==0.0_PS) then
       den_r=0.0_PS
    elseif( g_1%MS(clctr,ngrid)%tmp <= -5.0_PS + 273.16_PS .or. Y <= 1.6_PS) then
       den_r=min(den_i,max(den_min,A*(Y**B1)))
    else
       den_r=min(den_i,max(den_min,exp(B2+B3*Y+B4*(Y**2.0)+B5*(Y**3.0))))
    end if
  end subroutine cal_density_rime2

!!$  subroutine cal_growth_aclen_rim6( g_1, g_2, clctr,ngrid, n_all, N_drops, &
!!$       Qp,checker)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the growth of a and c axis by riming process
!!$    !
!!$    ! Only shorter axis is grown.
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    type (Group), intent(inout)    :: g_1, g_2
!!$    integer, intent(in)         :: clctr,ngrid
!!$    !type (Thermo_Var), intent(in) :: th_var
!!$    ! total number of sub-bins in a clctr bin
!!$    integer, intent(in)         :: n_all
!!$    ! number of drops that each sub bin i collects from jth bin, N_drops(i,j)
!!$!tmp    real(PS), pointer, dimension(:,:)   ::  N_drops
!!$    real(PS), dimension(mxnbin+1,*)   ::  N_drops
!!$
!!$    ! new non-mass variables in the shifted bin
!!$    ! argument 1 : volume of circumscribing sphere
!!$    !          2 : a-axis length
!!$    !          3 : c-axis length
!!$    !          4 : d-axis length
!!$    !          5 : r-axis length
!!$    !          6 : e-axis length
!!$    !          7 : volume by riming
!!$    !          8 : volume by aggregation
!!$!tmp    real(PS), pointer, dimension(:,:)                     :: Qp
!!$    real(PS), dimension(mxnnonmc+2,*)                     :: Qp
!!$
!!$    ! axis change in shifted bins
!!$!tmp    real(PS), pointer, dimension(:,:)            :: d_axis_len
!!$    !real(PS), dimension(2,*)            :: d_axis_len
!!$
!!$    ! checker of collision, 0: no collision, 1: collide
!!$!tmp    integer, pointer, dimension(:,:)       :: checker
!!$    integer, dimension(mxnbin+1,*)  :: checker
!!$
!!$    ! minimum possible riming density is assumed to 1.0e-2.
!!$    real(PS), parameter         :: den_min = 1.0e-2_PS
!!$    ! density of riming
!!$    real(PS)                    :: den_R
!!$    ! volume produced by riming
!!$    real(PS)                    :: V_R
!!$    ! new length of semi axix of circumscribing sphere
!!$    real (PS)                   :: nsemi_a, nsemi_c
!!$    ! new axis ratio and volume,volume of core of ice, and porus volume
!!$    real (PS)                   :: phi_n, V_n,V_core,V_space
!!$    integer  :: i, j, em
!!$
!!$    do i=1,g_2%N_BIN+1
!!$       do j=1,g_2%N_BIN
!!$          checker(i,j) = 1
!!$       enddo
!!$    enddo
!!$
!!$    if( n_all == 1 ) return
!!$
!!$    if(g_1%MS(clctr,ngrid)%inmlt==0.and.g_1%MS(clctr,ngrid)%tmp<273.16_PS) then
!!$!!c    if( g_1%MS(clctr,ngrid)%tmp < 273.16_PS ) then
!!$       ! --- case where the surface of solid hydrometeor is dry ---
!!$!!c  if(clctr == 26 ) then
!!$!!c  write(*,*) "stop"
!!$!!c  endif
!!$
!!$       do i = 1, n_all
!!$
!!$          ! +++ calculate the growth of the volume
!!$          do j = 1, g_2%N_BIN
!!$             V_R=0.0_PS
!!$             if( N_drops(i,j) == 0.0_PS ) cycle
!!$
!!$             ! +++ initialize the dimensions +++
!!$             phi_n=g_1%IS(clctr,ngrid)%phi_cs
!!$             nsemi_a=g_1%IS(clctr,ngrid)%semi_aip
!!$             nsemi_c=g_1%IS(clctr,ngrid)%semi_cip
!!$
!!$             V_n=get_vip(g_1%IS(clctr,ngrid)%is_mod(2),g_1%IS(clctr,ngrid)%phi_cs,g_1%IS(clctr,ngrid)%semi_aip)
!!$
!!$!!c             if(g_1%IS(clctr,ngrid)%is_mod(2)==1) then
!!$!!c                ! assume the cylinder volume
!!$!!c                V_n=coef2p*phi_n*nsemi_a**3.0
!!$!!c             elseif(g_1%IS(clctr,ngrid)%is_mod(2)==2) then
!!$!!c                ! assume the spheroidal volume
!!$!!c                V_n=coef4pi3*phi_n*nsemi_a**3.0
!!$!!c             end if
!!$
!!$
!!$             V_core=(g_1%MS(clctr,ngrid)%mass(imr)+g_1%MS(clctr,ngrid)%mass(ima)+&
!!$                  g_1%MS(clctr,ngrid)%mass(imc))/g_1%MS(clctr,ngrid)%con/den_i+&
!!$                  g_1%MS(clctr,ngrid)%mass(imw)/g_1%MS(clctr,ngrid)%con/den_w
!!$
!!$             V_space=max(V_n-V_core,0.0_RP)
!!$
!!$
!!$             ! +++ calculate the density of rime deposite +++
!!$             ! assume this is given by original solid hydrometeor
!!$             call cal_density_rime2(den_r,em,g_1, g_2, clctr,ngrid,j)
!!$!org             den_R = get_density_rime2(g_1, g_2, th_var, clctr,ngrid, j)
!!$!!c             den_R = den_i
!!$
!!$             ! +++ check if the density is zero (no collision) +++
!!$! <<< 2014/10 T. Hashino modified
!!$!             if( den_R == 0.0_PS ) cycle
!!$             if( den_R < den_min ) then
!!$               checker(i,j) = 0
!!$               write(*,*) "cal:rim0",ngrid,clctr,j,den_R
!!$               cycle
!!$             endif
!!$! >>> 2014/10 T. Hashino modified
!!$
!!$             V_R=g_2%MS(j,ngrid)%mean_mass/max(den_min,den_R)
!!$             V_n=V_n+max(V_R*N_drops(i,j)-V_space,0.0_RP)
!!$
!!$
!!$             if( phi_n < 1.0_PS ) then
!!$                nsemi_a = max( nsemi_a, max( g_2%MS(j,ngrid)%semi_a, g_2%MS(j,ngrid)%semi_c))
!!$                phi_n = V_n/get_coef_ip(g_1%IS(clctr,ngrid)%is_mod(2))/nsemi_a**3
!!$                nsemi_c = nsemi_a*phi_n
!!$
!!$             else if( phi_n > 1.0_PS ) then
!!$                nsemi_c = max( nsemi_c, max( g_2%MS(j,ngrid)%semi_a, g_2%MS(j,ngrid)%semi_c))
!!$                phi_n=sqrt( get_coef_ip(g_1%IS(clctr,ngrid)%is_mod(2))*nsemi_c**3/V_n)
!!$                nsemi_a=nsemi_c/phi_n
!!$
!!$             else if( phi_n == 1.0_PS ) then
!!$                nsemi_a=(V_n/get_coef_ip(g_1%IS(clctr,ngrid)%is_mod(2)))**(1.0_RP/3.0_RP)
!!$                nsemi_c = nsemi_a
!!$             end if
!!$
!!$             ! calculate the sphere volume corresponding to the maximum dimension
!!$             v_n=get_vcs(g_1%IS(clctr,ngrid)%is_mod(2),phi_n,nsemi_a)
!!$
!!$
!!$             Qp(ivcs,i)=Qp(ivcs,i)+max(0.0_RP,V_n-g_1%IS(clctr,ngrid)%V_cs)
!!$
!!$             Qp(8,i)=Qp(8,i)+max(0.0_RP,nsemi_a**3-g_1%IS(clctr,ngrid)%semi_aip**3)*N_drops(i,j)
!!$             Qp(9,i)=Qp(9,i)+max(0.0_RP,nsemi_c**3-g_1%IS(clctr,ngrid)%semi_cip**3)*N_drops(i,j)
!!$
!!$          end do
!!$
!!$
!!$
!!$       end do
!!$    else
!!$       ! --- case where the surface of solid hydrometeor is wet ---
!!$       !     assume the axis ratio does not change
!!$       !     but fill the melt water into the space in the solid hydrometeor
!!$       !
!!$       !     assume no change on the circumscribing volume of dry ice particle.
!!$       !
!!$!!c       do i = 1, n_all
!!$!!c
!!$!!c          ! +++ calculate the volume by acretion of cloud droplets +++
!!$!!c          do j = 1, g_2%N_BIN
!!$!!c             if( N_drops(i,j) == 0.0_PS ) cycle
!!$!!c
!!$!!c             phi_n = g_1%IS(clctr,ngrid)%phi_cs
!!$!!c             nsemi_a = g_1%MS(clctr,ngrid)%semi_a
!!$!!c             nsemi_c = g_1%MS(clctr,ngrid)%semi_c
!!$!!c
!!$!!c             if(g_1%IS(clctr,ngrid)%sh_type<=3) then
!!$!!c                ! assume the cylinder volume
!!$!!c                coef=coef2p
!!$!!c             else
!!$!!c                ! assume the spheroidal volume
!!$!!c                coef=coef4pi3
!!$!!c             end if
!!$!!c             V_n=coef*phi_n*nsemi_a**3
!!$!!c
!!$!!c             V_core=(g_1%MS(clctr,ngrid)%mass(imr)+g_1%MS(clctr,ngrid)%mass(ima)+g_1%MS(clctr,ngrid)%mass(imc))/g_1%MS(clctr,ngrid)%con/den_i+&
!!$!!c                  g_1%MS(clctr,ngrid)%mass(imw)/g_1%MS(clctr,ngrid)%con/den_w
!!$!!c
!!$!!c             V_space=max(V_n-V_core,0.0_RP)
!!$!!c
!!$!!c             V_R=g_2%MS(j,ngrid)%mean_mass/den_w
!!$!!c             V_n=V_n+max(V_R-V_space,0.0_RP)
!!$!!c
!!$!!c             nsemi_a=(V_n/(coef*phi_n))**(1.0_RP/3.0_RP)
!!$!!c             nsemi_c=nsemi_a*phi_n
!!$!!c
!!$!!c             ! calculate the sphere volume corresponding to the maximum dimension
!!$!!c             if(g_1%IS(clctr,ngrid)%sh_type<=3) then
!!$!!c                ! assume the cylinder volume
!!$!!c                V_n=coef4pi3*nsemi_a**3.0*(1.0_PS+phi_n**2.0)**1.5
!!$!!c             else
!!$!!c                ! assume the spheroidal volume
!!$!!c                if(phi_n<1.0_PS) then
!!$!!c                   V_n=coef4pi3*nsemi_a**3
!!$!!c                else
!!$!!c                   V_n=coef4pi3*nsemi_c**3
!!$!!c                end if
!!$!!c             end if
!!$!!c             ! calculate the sphere volume corresponding to the maximum dimension
!!$!!c             Qp(ivcs,i)=Qp(ivcs,i)+max(0.0_RP,V_n-g_1%IS(clctr,ngrid)%V_cs)*N_drops(i,j)
!!$!!c
!!$!!c          end do
!!$!!c
!!$!!c       end do
!!$    end if
!!$  end subroutine cal_growth_aclen_rim6

  subroutine cal_growth_aclen_rim6_vec( g_1, g_2, clctr, icond1, n_all, N_drops, &
       Qp,checker)
    use class_Ice_Shape, only: &
       get_vip, &
       get_vcs, &
       get_coef_ip
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the growth of a and c axis by riming process
    !
    ! Only shorter axis is grown.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)    :: g_1, g_2
    integer, intent(in)         :: clctr
    integer,intent(in),dimension(mxnbin,*) :: icond1
    !type (AirGroup), intent(in) :: ag
    ! total number of sub-bins in a clctr bin
    integer,dimension(*),intent(in)         :: n_all
    ! number of drops that each sub bin i collects from jth bin, N_drops(i,j)
!tmp    real(PS), pointer, dimension(:,:)   ::  N_drops
    real(PS), dimension(mxnbin+1,mxnbin,*)   ::  N_drops

    ! new non-mass variables in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : e-axis length
    !          7 : volume by riming
    !          8 : volume by aggregation
!tmp    real(PS), pointer, dimension(:,:)                     :: Qp
    real(PS), dimension(mxnbin+1,g_1%L,mxnnonmc+2)                     :: Qp

    ! axis change in shifted bins
!tmp    real(PS), pointer, dimension(:,:)            :: d_axis_len
    !real(PS), dimension(mxnbin+1,g_1%L,2)            :: d_axis_len

    ! checker of collision, 0: no collision, 1: collide
!tmp    integer, pointer, dimension(:,:)       :: checker
    integer, dimension(mxnbin+1,mxnbin,*)       :: checker

    ! minimum possible riming density is assumed to 1.0e-2.
    real(PS), parameter         :: den_min = 1.0e-2_PS
    ! density of riming
    real(PS)                    :: den_R
    ! volume produced by riming
    real(PS)                    :: V_R
    ! new length of semi axix of circumscribing sphere
    real (PS)                   :: nsemi_a, nsemi_c
    ! new axis ratio and volume,volume of core of ice, and porus volume
    real (PS)                   :: phi_n, V_n,V_core,V_space
    ! old axis ratios
    real (PS)                   :: ophi_ic, opsi_ic, old_aaxis, old_caxis, new_aaxis, new_caxis, i_ismod_eq1o
    integer                     :: is_mod
    integer  :: i,j,n,n_all_max!,em

    n_all_max=maxval(n_all(1:g_1%L))

    ! +++ initialize +++
    do n = 1, g_1%L
    do j = 1, mxnbin
    do i = 1, mxnbin+1
       checker(i,j,n) = 1
    end do
    end do
    end do

    do j = 1, g_2%N_BIN
!      do in=1,n_all_max*g_1%L
!        n=(in-1)/n_all_max+1
!        i=in-(n-1)*n_all_max
       do n = 1, g_1%L
       do i = 1, n_all_max
        if(icond1(clctr,n)==1.and.i<=n_all(n).and.n_all(n)>1) then

          if(g_1%MS(clctr,n)%inmlt==0.and.g_1%MS(clctr,n)%tmp<273.16_PS) then
            ! --- case where the surface of solid hydrometeor is dry ---
            ! +++ calculate the growth of the volume
            if( N_drops(i,j,n) > 0.0_PS ) then

              ! +++ calculate the density of rime deposite +++
              ! assume this is given by original solid hydrometeor
!!c              call cal_density_rime2(den_r,em,g_1, g_2, ag%TV(n), clctr,n,j)
              den_r=den_i

              ! +++ check if the density is zero (no collision) +++
! <<< 2014/10 T. Hashino modified
!             if( den_R == 0.0_PS ) cycle
              if( den_R < den_min ) then
                checker(i,j,n) = 0
!tmp                write(*,*) "cal:rim0",n,clctr,j,den_R
              else
! >>> 2014/10 T. Hashino modified

              ! sense test (for crystal) Ong Chia Rui, original is false
!!$              if (.false.) then
!!$                ophi_ic=g_1%IS(clctr,n)%phi_ic
!!$                opsi_ic=g_1%IS(clctr,n)%psi_ic
!!$                new_aaxis = ( (g_1%MS(clctr,n)%mass(imc)/g_1%MS(clctr,n)%con + g_2%MS(j,n)%mean_mass*N_drops(i,j,n))/den_i/3.0_PS/sqrt(3.0_PS)/ophi_ic/(1.0_PS - opsi_ic) )**(1.0_PS/3.0_PS)
!!$                new_caxis = ( (g_1%MS(clctr,n)%mass(imc)/g_1%MS(clctr,n)%con + g_2%MS(j,n)%mean_mass*N_drops(i,j,n))/den_i/3.0_PS/sqrt(3.0_PS)*ophi_ic*ophi_ic/(1.0_PS - opsi_ic) )**(1.0_PS/3.0_PS)
!!$                old_aaxis = Qp(i,n,iacr)
!!$                old_caxis = Qp(i,n,iccr)
!!$                Qp(i,n,iacr) = Qp(i,n,iacr) + max( 0.0_PS, new_aaxis - old_aaxis )
!!$                Qp(i,n,iccr) = Qp(i,n,iccr) + max( 0.0_PS, new_caxis - old_caxis )
!!$                Qp(i,n,idcr) = Qp(i,n,idcr) + max( 0.0_PS, ( 1.0_PS - ( (g_1%MS(clctr,n)%mass(imc)/g_1%MS(clctr,n)%con + g_2%MS(j,n)%mean_mass*N_drops(i,j,n))/den_i/3.0_PS/sqrt(3.0_PS)/ophi_ic/Qp(i,n,iacr)**3 )*Qp(i,n,iacr) ) - Qp(i,n,idcr) )
!!$
!!$                phi_n=g_1%IS(clctr,n)%phi_cs
!!$                nsemi_a=g_1%IS(clctr,n)%semi_aip
!!$                nsemi_c=g_1%IS(clctr,n)%semi_cip
!!$
!!$                is_mod = g_1%IS(clctr,n)%is_mod(2)
!!$                i_ismod_eq1o=max(0.0_RP,(-isign(1,is_mod-1)*max(0,is_mod-1)+1.0_RP))*&
!!$                     max(0.0_RP,(-isign(1,is_mod-1)*min(0,is_mod-1)+1.0_RP))
!!$
!!$                nsemi_a = nsemi_a + max( 0.0_PS, new_aaxis - old_aaxis )
!!$                nsemi_c = nsemi_c + max( 0.0_PS, new_caxis - old_caxis )
!!$                V_n = &
!!$                     ! is_mod==1
!!$                     !   assume the cylinder volume
!!$                     real(i_ismod_eq1o,PS_KIND)*coef2p*phi_n*nsemi_a*nsemi_a*nsemi_a +&
!!$                     ! is_mod==2
!!$                     !   assume the spheroidal volume
!!$                     (1.0_RP-real(i_ismod_eq1o,PS_KIND))*coef4pi3*phi_n*nsemi_a*nsemi_a*nsemi_a
!!$
!!$                Qp(i,n,ivcs)=Qp(i,n,ivcs)+max(0.0_RP,V_n-g_1%IS(clctr,n)%V_cs)
!!$                Qp(i,n,mxnnonmc+1)=Qp(i,n,mxnnonmc+1)+&
!!$                            max(0.0_RP,nsemi_a**3-g_1%IS(clctr,n)%semi_aip**3)
!!$                Qp(i,n,mxnnonmc+2)=Qp(i,n,mxnnonmc+2)+&
!!$                            max(0.0_RP,nsemi_c**3-g_1%IS(clctr,n)%semi_cip**3)
!!$
!!$
!!$              else


                ! +++ initialize the dimensions +++
                phi_n=g_1%IS(clctr,n)%phi_cs
                nsemi_a=g_1%IS(clctr,n)%semi_aip
                nsemi_c=g_1%IS(clctr,n)%semi_cip

                V_n=get_vip(g_1%IS(clctr,n)%is_mod(2),g_1%IS(clctr,n)%phi_cs,g_1%IS(clctr,n)%semi_aip)

                V_core=(g_1%MS(clctr,n)%mass(imr)+g_1%MS(clctr,n)%mass(ima)+&
                        g_1%MS(clctr,n)%mass(imc))/g_1%MS(clctr,n)%con/den_i+&
                        g_1%MS(clctr,n)%mass(imw)/g_1%MS(clctr,n)%con/den_w

                V_space=max(V_n-V_core,0.0_RP)

                V_R=g_2%MS(j,n)%mean_mass/max(den_min,den_R)
                V_n=V_n+max(V_R*N_drops(i,j,n)-V_space,0.0_RP)

                if( phi_n < 1.0_PS ) then
                  nsemi_a = max( nsemi_a, max( g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c))
                  phi_n = V_n/get_coef_ip(g_1%IS(clctr,n)%is_mod(2))/nsemi_a**3
                  nsemi_c = nsemi_a*phi_n

                  if(phi_n>1.0_RP) then
                    phi_n=1.0_PS
                    if(g_1%IS(clctr,n)%is_mod(2)==2) then
                      nsemi_a=(V_n/get_coef_ip(g_1%IS(clctr,n)%is_mod(2)))**(1.0_RP/3.0_RP)
                    endif
                    nsemi_c=nsemi_a
                  endif

                else if( phi_n > 1.0_PS ) then
                  nsemi_c = max( nsemi_c, max( g_2%MS(j,n)%semi_a, g_2%MS(j,n)%semi_c))
                  phi_n=sqrt( get_coef_ip(g_1%IS(clctr,n)%is_mod(2))*nsemi_c**3/V_n)
                  nsemi_a=nsemi_c/phi_n

                  if(phi_n<1.0) then
                    phi_n=1.0_PS
                    if(g_1%IS(clctr,n)%is_mod(2)==2) then
                      nsemi_a=(V_n/get_coef_ip(g_1%IS(clctr,n)%is_mod(2)))**(1.0_RP/3.0_RP)
                      nsemi_c=nsemi_a
                    else
                      nsemi_a=nsemi_c
                    endif
                  endif

                else
                  nsemi_a=(V_n/get_coef_ip(g_1%IS(clctr,n)%is_mod(2)))**(1.0_RP/3.0_RP)
                  nsemi_c = nsemi_a
                end if


                ! calculate the sphere volume corresponding to the maximum dimension
                v_n=get_vcs(g_1%IS(clctr,n)%is_mod(2),phi_n,nsemi_a)

                Qp(i,n,ivcs)=Qp(i,n,ivcs)+max(0.0_RP,V_n-g_1%IS(clctr,n)%V_cs)
                Qp(i,n,mxnnonmc+1)=Qp(i,n,mxnnonmc+1)+&
                            max(0.0_RP,nsemi_a**3-g_1%IS(clctr,n)%semi_aip**3)
                Qp(i,n,mxnnonmc+2)=Qp(i,n,mxnnonmc+2)+&
                            max(0.0_RP,nsemi_c**3-g_1%IS(clctr,n)%semi_cip**3)

!              endif ! end of sense test Ong Chia Rui

              endif
            endif
!          else
            ! --- case where the surface of solid hydrometeor is wet ---
            !     assume the axis ratio does not change
            !     but fill the melt water into the space in the solid hydrometeor
            !
            !     assume no change on the circumscribing volume of dry ice particle.
            !
          end if
        end if
      end do
      end do
    end do
  end subroutine cal_growth_aclen_rim6_vec

  subroutine cal_growth_aclen_agg3_vec( g_1, g_2, clctr,icond1, n_all, N_drops, Qp,dN_ice)
    use mod_amps_utility, only: &
       acos_m
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the growth of maximum diameter and circumscribing volume.
    !
    ! The growth of axis by aggregation process follows parameterization
    ! similar to Chen and Lamb (1994b).
    !
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)    :: g_1, g_2
    integer, intent(in)         :: clctr
    integer,intent(in),dimension(mxnbin,*) :: icond1
    ! total number of sub-bins in a collector bin
    integer,dimension(*),intent(in)         :: n_all
    ! number of drops that each sub bin i collects from jth bin, N_drops(i,j)
    ! per a parent drop
!tmp    real(PS), pointer, dimension(:,:)   ::  N_drops
    real(PS), dimension(mxnbin+1,mxnbin,*)   ::  N_drops
    ! number of drops that each sub bin i collects from all the bins
    ! per a parent drop
!tmp    real(PS), pointer, dimension(:)   ::  dN_ice
    real(PS), dimension(mxnbin+1,*)   ::  dN_ice

!!c    ! total concentration in the shifted bin
!!c    real(PS), pointer, dimension(:)           :: Np

    ! new non-mass variables in the shifted bin
    ! argument 1 : volume of circumscribing sphere * concentration
    !          2 : (a-axis length**3) * concentration
    !          3 : (c-axis length**3) * concentration
    !          4 : (d-axis length**3) * concentration
    !          5 : (a-axis center of gravity length**3) * concentration
    !          6 : (c-axis center of gravity length**3) * concentration
    !          7 : number of extra crystals  * concentration
!tmp    real(PS), pointer, dimension(:,:)                     :: Qp
    real(PS), dimension(mxnbin+1,g_1%L,mxnnonmc+2)                     :: Qp

    ! separation ratio
    real (PS)       :: S
    ! crossing angle with maximum probability
    ! 45 deg
    real (PS), parameter        :: theta0_max =0.785398163_PS
    ! 22.5 deg
!!c    real (PS), parameter        :: theta0_max =0.392699081698724_PS
    ! 0 deg
!!c    real (PS), parameter        :: theta0_max =0.0

    ! off set of contact point from the edge of the particle
    real (PS)                   :: Df
    ! diameter squared from the contact point
    real (PS)                   :: L1p2,L2p2
    ! weihgted-average density between two ice hydrometeors
    !real(PS)                    :: den_ave
    ! angle between two circular plates and angle between the maximum dimensions
    real (PS)                   :: theta0, theta
    ! length of a new aggregate
    real(PS) :: L3,L5,L6
    ! large,small dimensions of ice particles (1:catching one, 2 caught one)
    real(PS) :: DL1,DS1,DL2,DS2
    ! bulk density of hexagonal ice crystal calculated with circumscribing sphere
    real(PS) :: den_hex1,den_hex2
    ! ratio of the distance between midpoints of two needles and longer length of
    ! the needle
    real(PS),parameter :: drat=0.35
    ! maximum dimension of the catching particle
    real(PS) :: max_dim1
!tmp    real(PS) :: max_a

    ! reference density for polycrystals assuming phi=0.25
    real(PS),parameter :: den_hex_pol=0.259572

    !
    real(PS),parameter :: m_s1=1.0e-3,m_s2=1.0e-2,S1=0.6,S2=0.0
!!c    real(PS),parameter :: grad_S=(S2-S1)/(log10(m_s2)-log10(m_s1))
    real(PS),parameter :: grad_S=(S2-S1)/(-2.0_PS-(-3.0_PS))
    !real(PS) :: mtg

    integer :: i,j,n,n_all_max!,k

    n_all_max=maxval(n_all(1:g_1%L))


    ! +++ initialize +++
!    do in=1,n_all_max*g_1%L
!      n=(in-1)/n_all_max+1
!      i=in-(n-1)*n_all_max
    do n = 1, g_1%L
    do i = 1, n_all_max
      dN_ice(i,n)=0.0_PS
    enddo
    enddo
    do j = 1, g_2%N_BIN
!      do in=1,n_all_max*g_1%L
!        n=(in-1)/n_all_max+1
!        i=in-(n-1)*n_all_max
       do n = 1, g_1%L
       do i = 1, n_all_max
        if(icond1(clctr,n)==1.and.i<=n_all(n).and.n_all(n)>1) then

          if( g_1%IS(clctr,n)%semi_aip > g_1%IS(clctr,n)%semi_cip ) then
            DL1 = 2.0_PS*g_1%IS(clctr,n)%semi_aip
            DS1 = 2.0_PS*g_1%IS(clctr,n)%semi_cip
          else
            DL1 = 2.0_PS*g_1%IS(clctr,n)%semi_cip
            DS1 = 2.0_PS*g_1%IS(clctr,n)%semi_aip
          end if

          den_hex1=1.240490015_PS*den_i*g_1%IS(clctr,n)%phi_cs/(1.0_PS+g_1%IS(clctr,n)%phi_cs**2.0)**1.5

!tmp          max_a=g_1%MS(clctr,n)%a_len
          max_dim1=sqrt(DL1**2.0+DS1**2.0)

          ! +++ calculate the growth of a and c axes by each collision +++
          if( N_drops(i,j,n)>0.0_PS ) then

            if( g_2%IS(j,n)%semi_aip > g_2%IS(j,n)%semi_cip ) then
              DL2 = 2.0_PS*g_2%IS(j,n)%semi_aip
              DS2 = 2.0_PS*g_2%IS(j,n)%semi_cip
            else
              DL2 = 2.0_PS*g_2%IS(j,n)%semi_cip
              DS2 = 2.0_PS*g_2%IS(j,n)%semi_aip
            end if

            if(g_1%IS(clctr,n)%phi_cs>=5.0.or.g_2%IS(j,n)%phi_cs>=5.0) then
              S=0.0_PS
              theta0=0.0_PS

            else
              S=0.6_PS

              den_hex2=1.240490015_PS*den_i*g_2%IS(j,n)%phi_cs/(1.0_PS+g_2%IS(j,n)%phi_cs**2.0)**1.5

              theta0 = theta0_max*max(1.0_PS - &
                  (g_1%IS(clctr,n)%V_cs*g_1%IS(clctr,n)%den_ip/den_hex1 + &
                  g_2%IS(j,n)%V_cs*g_2%IS(j,n)%den_ip/den_hex2)/&
                  (g_1%IS(clctr,n)%V_cs + g_2%IS(j,n)%V_cs),0.0_PS)

            endif

            Df=0.5_PS*(DL1+DL2)*(1.0_PS-S)
            L1p2=DS1*DS1+(DL1-Df)*(DL1-Df)
            L2p2=DS2*DS2+DL2*DL2

            theta=acos_m((DL1-Df)/sqrt(L1p2))-&
                acos_m(DL2/sqrt(L2p2))+PI-theta0

            L3=max(max_dim1,sqrt(L1p2+L2p2-2.0_PS*sqrt(L1p2*L2p2)*cos(theta)))
            L5=(DL2*cos(theta0)-DS2*sin(theta0))-(-DL1+Df)
            L6=(DL2*sin(theta0)+DS2*cos(theta0))-(-DS1)

            Qp(i,n,ivcs)=Qp(i,n,ivcs)+max(0.0_PS,coefpi6*L3*L3*L3-g_1%IS(clctr,n)%V_cs)*N_drops(i,j,n)

            if(g_1%IS(clctr,n)%phi_cs<1.0) then
              Qp(i,n,mxnnonmc+1)=Qp(i,n,mxnnonmc+1)+max(0.0_PS,0.125_PS*L5*L5*L5-&
                        g_1%MS(clctr,n)%semi_a*g_1%MS(clctr,n)%semi_a*g_1%MS(clctr,n)%semi_a)*N_drops(i,j,n)
              Qp(i,n,mxnnonmc+2)=Qp(i,n,mxnnonmc+2)+max(0.0_PS,0.125_PS*L6*L6*L6-&
                        g_1%MS(clctr,n)%semi_c*g_1%MS(clctr,n)%semi_c*g_1%MS(clctr,n)%semi_c)*N_drops(i,j,n)
            else
              Qp(i,n,mxnnonmc+1)=Qp(i,n,mxnnonmc+1)+max(0.0_PS,0.125_PS*L6*L6*L6-&
                        g_1%MS(clctr,n)%semi_a*g_1%MS(clctr,n)%semi_a*g_1%MS(clctr,n)%semi_a)*N_drops(i,j,n)
              Qp(i,n,mxnnonmc+2)=Qp(i,n,mxnnonmc+2)+max(0.0_PS,0.125_PS*L5*L5*L5-&
                        g_1%MS(clctr,n)%semi_c*g_1%MS(clctr,n)%semi_c*g_1%MS(clctr,n)%semi_c)*N_drops(i,j,n)
            end if

            ! if the average shape of ice crystals in aggregate is your interest,
            Qp(i,n,iacr)=Qp(i,n,iacr)+(g_2%MS(j,n)%a_len*g_2%MS(j,n)%a_len*g_2%MS(j,n)%a_len)*N_drops(i,j,n)
            Qp(i,n,iccr)=Qp(i,n,iccr)+(g_2%MS(j,n)%c_len*g_2%MS(j,n)%c_len*g_2%MS(j,n)%c_len)*N_drops(i,j,n)
            Qp(i,n,idcr)=Qp(i,n,idcr)+(g_2%IS(j,n)%d*g_2%IS(j,n)%d*g_2%IS(j,n)%d)*N_drops(i,j,n)
            Qp(i,n,iag)=Qp(i,n,iag)+(g_2%IS(j,n)%ag*g_2%IS(j,n)%ag*g_2%IS(j,n)%ag)*N_drops(i,j,n)
            Qp(i,n,icg)=Qp(i,n,icg)+(g_2%IS(j,n)%cg*g_2%IS(j,n)%cg*g_2%IS(j,n)%cg)*N_drops(i,j,n)
            Qp(i,n,inex)=Qp(i,n,inex)+g_2%IS(j,n)%n_exice*N_drops(i,j,n)
            dN_ice(i,n)=dN_ice(i,n)+N_drops(i,j,n)

!tmp            max_a=max(g_2%MS(j,n)%a_len,max_a)
          endif
        endif
      enddo
      enddo
    enddo
  end subroutine cal_growth_aclen_agg3_vec

  subroutine check_csvolume_vec( g, nN, NM, nQ)
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! This subroutine check if the volume of circumscribing sphere is
    ! reasonable or not.
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    type (Group), intent(inout)        :: g
    real(8),dimension(mxnbin,*)    :: nN
    real(8),dimension(mxnbin,g%L,1+mxnmasscomp)  :: nM
    real(8),dimension(mxnbin,g%L,mxnnonmc)  :: nQ
    ! possible minimum circumscribing volume by considering the density
    real(PS)                           :: min_csvol
    ! axis length
    !real(PS) :: a,c,d,r
    ! possible maximum density of ice
    real(PS), parameter                :: den_max = 0.91668

    integer                            :: i,n!,j

    if( g%token == 1 ) then
      ! --- case of liquid phase ---
      return
    else if( g%token == 2 ) then
      ! --- case of solid phase ---
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN

        if( nN(i,n) == 0.0_PS .OR. nM(i,n,imt) == 0.0_PS ) cycle
        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! check the minimum possible volume
        min_csvol = nM(i,n,imt)/den_max
!!c          a=(nQ(i,n,2)/nN(i,n))**(1.0/3.0)
!!c          c=(nQ(i,n,3)/nN(i,n))**(1.0/3.0)
!!c          d=(nQ(i,n,4)/nN(i,n))**(1.0/3.0)
!!c          r=(nQ(i,n,5)/nN(i,n))**(1.0/3.0)
!!c          m_ice = (get_vol_pcd(a,c,d)+get_vol_rss(r))*den_i*nN(i,n)
        if( nQ(i,n,ivcs) < min_csvol .and. nM(i,n,3) > nM(i,n,4) ) then
!!c             write(*,*) "check_csvolume > the cs volume reached minimum possible &
!!c                  length at ", i
          nQ(i,n,ivcs) = min_csvol
        end if
        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      end do
      end do
    end if
  end subroutine check_csvolume_vec

  subroutine cal_inherent_growth_ratio_vec(ag,gamma,vigp)
    use class_Group, only: &
       vap_igp_aux
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the inherent growth ratio based on curve obtained
    ! from the figure in Chen and Lamb (1994a)
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! thermo variable object
    type (AirGroup), intent(in)  :: ag
    real(PS),dimension(ag%L,2) :: gamma

    ! Inherent Growth parameterization
    type (vap_igp_aux),intent(in) :: vigp


    ! ambient air temperature [C]
    real(PS)                    :: T

    integer,dimension(LMAX) :: icond1
    integer :: i,n!,ii


! sense test Ong Chia Rui, original is true
!!$if (.true.) then

    do n=1,ag%L
      T = min(0.0_RP, ag%TV(n)%T - 273.16_RP)

      icond1(n)=0
      if(T<vigp%x(1)) then
!!c       write(*,*) "inherent_growth_ratio > Warning! The temperature is &
!!c            colder than -30C. Inherent ratio is set to 1."
!!c       out=1.0
!!c       return
        gamma(n,2) = vigp%a(1,1)*( T - vigp%x(1) )**3 + vigp%a(1,2)*( T - vigp%x(1) )**2 + &
            vigp%a(1,3)*( T - vigp%x(1) ) + vigp%a(1,4)
        gamma(n,1) = vigp%b(1,1)*( T - vigp%x(1) )**3 + vigp%b(1,2)*( T - vigp%x(1) )**2 + &
            vigp%b(1,3)*( T - vigp%x(1) ) + vigp%b(1,4)
        icond1(n)=1
      elseif(T>=vigp%x(vigp%nok)) then
        gamma(n,2) = vigp%a(vigp%nok,1)*( T - vigp%x(vigp%nok) )**3 + vigp%a(vigp%nok,2)*( T - vigp%x(vigp%nok) )**2 + &
              vigp%a(vigp%nok,3)*( T - vigp%x(vigp%nok) ) + vigp%a(vigp%nok,4)
        gamma(n,1) = vigp%b(vigp%nok,1)*( T - vigp%x(vigp%nok) )**3 + vigp%b(vigp%nok,2)*( T - vigp%x(vigp%nok) )**2 + &
              vigp%b(vigp%nok,3)*( T - vigp%x(vigp%nok) ) + vigp%b(vigp%nok,4)
        icond1(n)=1
      endif
    enddo

    do i=1, vigp%nok-1
      do n=1,ag%L

        T = min(0.0_RP, ag%TV(n)%T - 273.16_RP)
        if(icond1(n)==0.and.vigp%x(i) <= T.and.T<vigp%x(i+1) ) then
          gamma(n,2) = vigp%a(i,1)*( T - vigp%x(i) )**3 + vigp%a(i,2)*( T - vigp%x(i) )**2 + &
               vigp%a(i,3)*( T - vigp%x(i) ) + vigp%a(i,4)
          gamma(n,1) = vigp%b(i,1)*( T - vigp%x(i) )**3 + vigp%b(i,2)*( T - vigp%x(i) )**2 + &
               vigp%b(i,3)*( T - vigp%x(i) ) + vigp%b(i,4)
          icond1(n)=1
        endif
      enddo
      if(any(icond1(1:ag%L)==0)) then
        cycle
      else
        exit
      endif
    enddo



!!$else
!!$
!!$
!!$ if (.true.) then
!!$    ! sense test forcing gamma to 1 Ong Chia Rui
!!$
!!$    do n=1,ag%L
!!$
!!$      !gamma(n,1) = 1.0D0
!!$      !gamma(m,2) = 1.0D0
!!$      gamma(n,1) = 1.5D0
!!$      gamma(n,2) = 1.5D0
!!$      !gamma(n,1) = 0.635D0
!!$      !gamma(n,2) = 0.635D0
!!$      !gamma(n,1) = 0.27D0
!!$      !gamma(n,2) = 0.27D0
!!$      icond1(n)=1
!!$    enddo
!!$
!!$
!!$
!!$ else if (.false.) then
!!$
!!$    do n=1,ag%L
!!$      T = min(0.0_RP, ag%TV(n)%T - 273.16_RP)
!!$
!!$      icond1(n)=0
!!$      if(T<vigp%x(1)) then
!!$!!c       write(*,*) "inherent_growth_ratio > Warning! The temperature is &
!!$!!c            colder than -30C. Inherent ratio is set to 1."
!!$!!c       out=1.0
!!$!!c       return
!!$        gamma(n,2) = vigp%a(1,1)*( T - vigp%x(1) )**3 + vigp%a(1,2)*( T - vigp%x(1) )**2 + &
!!$            vigp%a(1,3)*( T - vigp%x(1) ) + vigp%a(1,4)
!!$        gamma(n,1) = vigp%b(1,1)*( T - vigp%x(1) )**3 + vigp%b(1,2)*( T - vigp%x(1) )**2 + &
!!$            vigp%b(1,3)*( T - vigp%x(1) ) + vigp%b(1,4)
!!$        if (gamma(n,2) > 1.0_PS) then
!!$          gamma(n,2) = 1.0_PS / gamma(n,2)
!!$        else
!!$          gamma(n,2) = 2.0_PS - gamma(b,2)
!!$        endif
!!$        if (gamma(n,1) > 1.0_PS) then
!!$          gamma(n,1) = 1.0_PS / gamma(n,1)
!!$        else
!!$          gamma(n,1) = 2.0_PS - gamma(n,1)
!!$        endif
!!$        icond1(n)=1
!!$      elseif(T>=vigp%x(vigp%nok)) then
!!$        gamma(n,2) = vigp%a(vigp%nok,1)*( T - vigp%x(vigp%nok) )**3 + vigp%a(vigp%nok,2)*( T - vigp%x(vigp%nok) )**2 + &
!!$              vigp%a(vigp%nok,3)*( T - vigp%x(vigp%nok) ) + vigp%a(vigp%nok,4)
!!$        gamma(n,1) = vigp%b(vigp%nok,1)*( T - vigp%x(vigp%nok) )**3 + vigp%b(vigp%nok,2)*( T - vigp%x(vigp%nok) )**2 + &
!!$              vigp%b(vigp%nok,3)*( T - vigp%x(vigp%nok) ) + vigp%b(vigp%nok,4)
!!$        if (gamma(n,2) > 1.0_PS) then
!!$          gamma(n,2) = 1.0_PS / gamma(n,2)
!!$        else
!!$          gamma(n,2) = 2.0_PS - gamma(n,2)
!!$        endif
!!$        if (gamma(n,1) > 1.0_PS) then
!!$          gamma(n,1) = 1.0_PS / gamma(n,1)
!!$        else
!!$          gamma(n,1) = 2.0_PS - gamma(n,1)
!!$        endif
!!$        icond1(n)=1
!!$      endif
!!$    enddo
!!$
!!$    do i=1, vigp%nok-1
!!$      do n=1,ag%L
!!$
!!$        T = min(0.0_RP, ag%TV(n)%T - 273.16_RP)
!!$        if(icond1(n)==0.and.vigp%x(i) <= T.and.T<vigp%x(i+1) ) then
!!$          gamma(n,2) = vigp%a(i,1)*( T - vigp%x(i) )**3 + vigp%a(i,2)*( T - vigp%x(i) )**2 + &
!!$               vigp%a(i,3)*( T - vigp%x(i) ) + vigp%a(i,4)
!!$          gamma(n,1) = vigp%b(i,1)*( T - vigp%x(i) )**3 + vigp%b(i,2)*( T - vigp%x(i) )**2 + &
!!$               vigp%b(i,3)*( T - vigp%x(i) ) + vigp%b(i,4)
!!$          if (gamma(n,2) > 1.0_PS) then
!!$            gamma(n,2) = 1.0_PS / gamma(n,2)
!!$          else
!!$            gamma(n,2) = 2.0_PS - gamma(n,2)
!!$          endif
!!$          if (gamma(n,1) > 1.0_PS) then
!!$            gamma(n,1) = 1.0_PS / gamma(n,1)
!!$          else
!!$            gamma(n,1) = 2.0_PS - gamma(n,1)
!!$          endif
!!$          icond1(n)=1
!!$        endif
!!$      enddo
!!$      if(any(icond1(1:ag%L)==0)) then
!!$        cycle
!!$      else
!!$        exit
!!$      endif
!!$    enddo
!!$
!!$ else
!!$
!!$    do n=1,ag%L
!!$      T = min(0.0_RP, ag%TV(n)%T - 273.16_RP)
!!$
!!$      icond1(n)=0
!!$      if(T<vigp%x(1)) then
!!$!!c       write(*,*) "inherent_growth_ratio > Warning! The temperature is &
!!$!!c            colder than -30C. Inherent ratio is set to 1."
!!$!!c       out=1.0
!!$!!c       return
!!$        gamma(n,2) = max( 0.0_RP, 1.0_RP / ( vigp%a(1,1)*( T - vigp%x(1) )**3 + vigp%a(1,2)*( T - vigp%x(1) )**2 + &
!!$            vigp%a(1,3)*( T - vigp%x(1) ) + vigp%a(1,4) ) )
!!$        gamma(n,1) = max( 0.0_RP, 1.0_RP / ( vigp%b(1,1)*( T - vigp%x(1) )**3 + vigp%b(1,2)*( T - vigp%x(1) )**2 + &
!!$            vigp%b(1,3)*( T - vigp%x(1) ) + vigp%b(1,4) ) )
!!$        icond1(n)=1
!!$      elseif(T>=vigp%x(vigp%nok)) then
!!$        gamma(n,2) = max( 0.0_RP, 1.0_RP / ( vigp%a(vigp%nok,1)*( T - vigp%x(vigp%nok) )**3 + vigp%a(vigp%nok,2)*( T - vigp%x(vigp%nok) )**2 + &
!!$              vigp%a(vigp%nok,3)*( T - vigp%x(vigp%nok) ) + vigp%a(vigp%nok,4) ) )
!!$        gamma(n,1) = max( 0.0_RP, 1.0_RP / ( vigp%b(vigp%nok,1)*( T - vigp%x(vigp%nok) )**3 + vigp%b(vigp%nok,2)*( T - vigp%x(vigp%nok) )**2 + &
!!$              vigp%b(vigp%nok,3)*( T - vigp%x(vigp%nok) ) + vigp%b(vigp%nok,4) ) )
!!$        icond1(n)=1
!!$      endif
!!$    enddo
!!$
!!$    do i=1, vigp%nok-1
!!$      do n=1,ag%L
!!$
!!$        T = min(0.0_RP, ag%TV(n)%T - 273.16_RP)
!!$        if(icond1(n)==0.and.vigp%x(i) <= T.and.T<vigp%x(i+1) ) then
!!$          gamma(n,2) = max( 0.0_RP, 1.0_RP / ( vigp%a(i,1)*( T - vigp%x(i) )**3.0 + vigp%a(i,2)*( T - vigp%x(i) )**2.0 + &
!!$               vigp%a(i,3)*( T - vigp%x(i) ) + vigp%a(i,4) ) )
!!$          gamma(n,1) = max( 0.0_RP, 1.0_RP / ( vigp%b(i,1)*( T - vigp%x(i) )**3.0 + vigp%b(i,2)*( T - vigp%x(i) )**2.0 + &
!!$               vigp%b(i,3)*( T - vigp%x(i) ) + vigp%b(i,4) ) )
!!$          icond1(n)=1
!!$        endif
!!$      enddo
!!$      if(any(icond1(1:ag%L)==0)) then
!!$        cycle
!!$      else
!!$        exit
!!$      endif
!!$    enddo
!!$
!!$ endif
!!$
!!$
!!$
!!$end if


    if(any(icond1(1:ag%L)<=0)) then
       LOG_ERROR("cal_inherent_growth_ratio_vec",*) "error"
      do n=1,ag%L
        if(icond1(n)<=0) then
           LOG_ERROR_CONT(*) "T:",n,icond1(n),ag%TV(n)%T-273.16_RP
        endif
      enddo
      stop
    endif

  end subroutine cal_inherent_growth_ratio_vec

!!$  subroutine cal_inherent_growth_ratio(d_T,gamma)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the inherent growth ratio based on curve obtained
!!$    ! from the figure in Chen and Lamb (1994a)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! ambient air temperature
!!$    real(PS), intent(in)  :: d_T
!!$    ! number of knots (data points)
!!$    integer, parameter    :: nok = 23
!!$    ! data points
!!$    real(PS), dimension(nok)  :: x
!!$
!!$    ! parameters for cubic approximation
!!$    real(PS), dimension(nok,4)  :: a,b
!!$
!!$    real(PS)                    :: T
!!$
!!$!tmp    real(PS),pointer,dimension(:) :: gamma
!!$    real(PS),dimension(*) :: gamma
!!$    integer :: i
!!$
!!$
!!$    T = d_T - 273.16
!!$
!!$    ! +++ definition +++
!!$    x = (/-60.0,-55.0, -50.0, -45.0, -40.0, -35.0, -30.0, -27.0, -25.0, -23.0, -21.0, -20.0, -17.0, &
!!$         -15.0, -12.0, -10.0, -8.0, -6.0, -5.0, -4.0, -3.5, -2.5, -1.5 /)
!!$
!!$
!!$!!c    a(1,:) = (/  0.0008,  -0.0120,  0.0, 2.3000/)
!!$!!c    a(2,:) = (/ 0.0044, -0.0339, -0.0600, 2.1000/)
!!$!!c    a(3,:) = (/ 0.0012, -0.0018, -0.0706,  1.5000/)
!!$!!c    a(1,:)=(/ 0.0017 , -0.0287 , 0.0 , 4.5000 /)
!!$!!c    a(2,:)=(/ 0.0126 , -0.1036 , -0.1565 , 4.0000 /)
!!$!!c    a(3,:)=(/ 0.0053 , -0.0145 , -0.2487 , 2.2000 /)
!!$
!!$
!!$!!c    a(1,:)=(/ 0.0003 , -0.0074 , -0.0700 , 3.5000 /)
!!$!!c    a(2,:)=(/ 0.0009 , -0.0120 , -0.1231 , 3.0000 /)
!!$!!c    a(3,:)=(/ 0.0083 , -0.0445 , -0.1737 , 2.2000 /)
!!$!!c    a(4,:) = (/    0.0,       0.0,         0.0,    1.2500/)
!!$!!c    a(5,:) = (/ -0.0025,    0.0220,        0.0,    1.2500/)
!!$!!c    a(6,:) = (/ -0.0073,   0.0375,   0.0640,    1.3800/)
!!$!!c    a(7,:) = (/ -0.0433,    0.0981,    0.1269,    1.6000/)
!!$!!c    a(8,:) = (/  0.0700,   -0.3150,      0.0,    1.9000/)
!!$!!c    a(9,:) = (/  0.3556,   -0.4356, -0.4200,    1.2000/)
!!$    a(1,:)=(/ 0.000000e+00 , 0.000000e+00 , -3.000000e-02 , 2.300000e+00 /)
!!$    a(2,:)=(/ 0.000000e+00 , 0.000000e+00 , -3.000000e-02 , 2.150000e+00 /)
!!$    a(3,:)=(/ -4.800000e-04 , 2.400000e-03 , -3.000000e-02 , 2.000000e+00 /)
!!$    a(4,:)=(/ 1.586667e-03 , -1.353333e-02 , -4.200000e-02 , 1.850000e+00 /)
!!$    a(5,:)=(/ 1.512821e-03 , -5.897436e-03 , -5.833333e-02 , 1.500000e+00 /)
!!$    a(6,:)=(/ -9.597381e-05 , 8.490998e-04 , -3.846154e-03 , 1.250000e+00 /)
!!$    a(7,:)=(/ -1.176598e-04 , 9.293226e-05 , -2.553191e-03 , 1.240000e+00 /)
!!$    a(8,:)=(/ 2.040230e-03 , -6.494253e-03 , -5.172414e-03 , 1.230000e+00 /)
!!$    a(9,:)=(/ -1.439394e-03 , 3.712121e-03 , -6.666667e-03 , 1.210000e+00 /)
!!$    a(10,:)=(/ -1.597052e-03 , -1.726044e-02 , -9.090909e-03 , 1.200000e+00 /)
!!$    a(11,:)=(/ 4.920791e-01 , -7.947818e-01 , -9.729730e-02 , 1.100000e+00 /)
!!$
!!$    b(1,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(2,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(3,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(4,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(5,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(6,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(7,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(8,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(9,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(10,:) = (/ 0.0 , 0.0 , 0.0 , 0.7600 /)
!!$    b(11,:) = (/ 0.0431 , -0.1031 , 0.0 , 0.7600 /)
!!$
!!$    a(12,:) = (/-0.0012,0.0363,-0.2244,0.7000/)
!!$!!c    a(10,:) = (/ -0.0074, 0.0807, -0.3355, 0.8000 /)
!!$    a(13,:) = (/ -0.0005, 0.0141, -0.0511, 0.3200 /)
!!$    a(14,:) = (/  0.0035, 0.0109, -0.0011, 0.2700 /)
!!$!    a(8,:) = (/ -0.0027,  0.0293,  0.0, 0.2700 /)
!!$    a(15,:) = (/ -0.0063, 0.0427, 0.1597, 0.4600 /)
!!$!    a(9,:) = (/ -0.0169, 0.0928, 0.1021, 0.4600 /)
!!$    a(16,:) = (/  0.0212, 0.0051, 0.2552, 0.9000 /)
!!$!    a(10,:) = (/ -0.0200, 0.0798, 0.2702, 0.9000 /)
!!$    a(17,:) = (/ -0.1109, 0.1320, 0.5294, 1.6000 /)
!!$    a(18,:) = (/  0.1061, -0.5332, -0.2729, 2.3000 /)
!!$    a(19,:) = (/  0.2758, -0.2148, -1.0209, 1.6000 /)
!!$    a(20,:) = (/ -0.0118, 0.6125, -0.6233, 0.6400 /)
!!$    a(21,:) = (/ -0.2951, 0.5948, -0.0197, 0.4800 /)
!!$    a(22,:) = (/  0.0550,   -0.0995, 0.1244, 0.7600 /)
!!$    a(23,:) = (/ -0.0000, 0.0108, 0.0906, 0.8400 /)
!!$
!!$    b(12:23,1:4)=a(12:23,1:4)
!!$
!!$
!!$    if(T<x(1)) then
!!$!!c       write(*,*) "inherent_growth_ratio > Warning! The temperature is &
!!$!!c            colder than -30C. Inherent ratio is set to 1."
!!$!!c       out=1.0
!!$!!c       return
!!$       gamma(2) = a(1,1)*( T - x(1) )**3 + a(1,2)*( T - x(1) )**2 + &
!!$            a(1,3)*( T - x(1) ) + a(1,4)
!!$       gamma(1) = b(1,1)*( T - x(1) )**3 + b(1,2)*( T - x(1) )**2 + &
!!$            b(1,3)*( T - x(1) ) + b(1,4)
!!$    else if(0.0<T) then
!!$       write(*,*) "inherent_growth_ratio > ERROR! The temperature is warmer than freezing point!"
!!$       stop
!!$    else
!!$       do i=1, nok-1
!!$          if( x(i) <= T .and. T < x(i+1) ) then
!!$             gamma(2) = a(i,1)*( T - x(i) )**3 + a(i,2)*( T - x(i) )**2 + &
!!$                  a(i,3)*( T - x(i) ) + a(i,4)
!!$             gamma(1) = b(i,1)*( T - x(i) )**3 + b(i,2)*( T - x(i) )**2 + &
!!$                  b(i,3)*( T - x(i) ) + b(i,4)
!!$             return
!!$          end if
!!$       end do
!!$       gamma(2) = a(nok,1)*( T - x(nok) )**3 + a(nok,2)*( T - x(nok) )**2 + &
!!$            a(nok,3)*( T - x(nok) ) + a(nok,4)
!!$       gamma(1) = b(nok,1)*( T - x(nok) )**3 + b(nok,2)*( T - x(nok) )**2 + &
!!$            b(nok,3)*( T - x(nok) ) + b(nok,4)
!!$    end if
!!$
!!$  end subroutine cal_inherent_growth_ratio

!!$  function inherent_growth_ratio(d_T ) result(out)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the inherent growth ratio based on curve obtained
!!$    ! from the figure in Chen and Lamb (1994a)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! ambient air temperature
!!$    real(PS), intent(in)  :: d_T
!!$    ! number of knots (data points)
!!$    integer, parameter    :: nok = 17
!!$    ! data points
!!$    real(PS), dimension(nok)  :: x
!!$    ! parameters for cubic approximation
!!$    real(PS), dimension(nok,4)  :: a
!!$
!!$    integer                 :: i
!!$    real(PS)                    :: out, T
!!$
!!$
!!$    T = d_T - 273.16
!!$    ! +++ definition +++
!!$    x = (/-30.0, -27.0, -25.0, -23.0, -21.0, -20.0, -17.0, &
!!$         -15.0, -12.0, -10.0, -8.0, -6.0, -5.0, -4.0, -3.5, -2.5, -1.5/)
!!$
!!$    a(1,:) = (/ -0.0021, 0.0198, 0.0033, 1.2500 /)
!!$    a(2,:) = (/ -0.0073, 0.0375, 0.0640, 1.3800 /)
!!$    a(3,:) = (/ -0.0433, 0.0981, 0.1269, 1.6000 /)
!!$    a(4,:) = (/  0.0405,  -0.2112, -0.0897, 1.9000 /)
!!$    a(5,:) = (/  0.0163, 0.0319, -0.4482, 1.2000 /)
!!$    a(6,:) = (/ -0.0074, 0.0807, -0.3355, 0.8000 /)
!!$    a(7,:) = (/ -0.0005, 0.0141, -0.0511, 0.3200 /)
!!$    a(8,:) = (/  0.0035, 0.0109, -0.0011, 0.2700 /)
!!$    a(9,:) = (/ -0.0063, 0.0427, 0.1597, 0.4600 /)
!!$    a(10,:) = (/  0.0212, 0.0051, 0.2552, 0.9000 /)
!!$    a(11,:) = (/ -0.1109, 0.1320, 0.5294, 1.6000 /)
!!$    a(12,:) = (/  0.1061, -0.5332, -0.2729, 2.3000 /)
!!$    a(13,:) = (/  0.2758, -0.2148, -1.0209, 1.6000 /)
!!$    a(14,:) = (/ -0.0118, 0.6125, -0.6233, 0.6400 /)
!!$    a(15,:) = (/ -0.2951, 0.5948, -0.0197, 0.4800 /)
!!$    a(16,:) = (/  0.0550,   -0.0995, 0.1244, 0.7600 /)
!!$    a(17,:) = (/ -0.0000, 0.0108, 0.0906, 0.8400 /)
!!$
!!$    if(T<x(1)) then
!!$!!c       write(*,*) "inherent_growth_ratio > Warning! The temperature is &
!!$!!c            colder than -30C. Inherent ratio is set to 1."
!!$       out=1.0
!!$       return
!!$    else if(0.0<T) then
!!$!!c       write(*,*) "inherent_growth_ratio > ERROR! The temperature is &
!!$!!c            warmer than freezing point!"
!!$       stop
!!$    end if
!!$    do i=1, nok-1
!!$       if( x(i) <= T .and. T < x(i+1) ) then
!!$          out = a(i,1)*( T - x(i) )**3 + a(i,2)*( T - x(i) )**2 + &
!!$               a(i,3)*( T - x(i) ) + a(i,4)
!!$          return
!!$       end if
!!$    end do
!!$    out = a(nok,1)*( T - x(nok) )**3 + a(nok,2)*( T - x(nok) )**2 + &
!!$         a(nok,3)*( T - x(nok) ) + a(nok,4)
!!$  end function inherent_growth_ratio

!!$  subroutine assign_Qp_v3(sh_type,m_ic,vcs,alen,clen,dlen,ag,cg,n_exice,semi_alen,semi_clen&
!!$                      , d_axis_len, d_vol, len_switch,growth_mode,init_growth&
!!$                      ,iwet,is_mod,Qp)
!!$    use mod_amps_utility, only: get_len_s3,get_len_s1,get_len_c2a
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the new non-mass variables in the shifted bin for
!!$    ! vapor deposition process
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    integer,intent(in) :: sh_type,growth_mode,init_growth
!!$    real(PS),intent(in) :: m_ic,vcs,alen,clen,dlen,ag,cg,n_exice,semi_alen,semi_clen!,Temp,S_ice
!!$!tmp    real(PS), pointer, dimension(:) :: Qp, d_vol, d_axis_len
!!$    real(PS), dimension(*) :: Qp, d_vol, d_axis_len
!!$    integer,intent(in)             :: iwet
!!$    !integer                    :: i
!!$    ! indication of dendritic growth
!!$!tmp    integer,pointer,dimension(:) :: len_switch
!!$    integer,dimension(*) :: len_switch
!!$    ! minimum possible volume of ice crystal
!!$    real(PS),parameter :: V_csmin=1.1847688e-11
!!$    ! maximum and minimum aspect ratio
!!$    real(PS),parameter  :: phi_max=2.0e+1,phi_min=5.0e-3
!!$
!!$    real(PS),parameter :: phi_ros=0.25_PS,phi_s3=0.25_PS,phi_sdpl=0.25_PS
!!$
!!$    real(PS) :: phi!,max_rad
!!$
!!$    ! ice shape model
!!$    integer,intent(in) :: is_mod
!!$
!!$    ! NOTE: quality component is defined for a partile, not for whole the bin.
!!$    !
!!$    ! assumption
!!$    ! 1. volume of circumscribing sphere is assumed to grow by capacitance calculated
!!$    !    by the sphere.
!!$    ! 2. In cases of aggregates or graupel, ice crystals inside do not grow.
!!$    !
!!$    Qp(ivcs)=Vcs
!!$    Qp(iacr)=alen
!!$    Qp(iccr)=clen
!!$    Qp(idcr)=dlen
!!$    Qp(iag)=ag
!!$    Qp(icg)=cg
!!$    Qp(inex)=n_exice
!!$    Qp(8)=semi_alen
!!$    Qp(9)=semi_clen
!!$
!!$    if(iwet==1) then
!!$       Qp(ivcs)=max(0.0_PS,Qp(ivcs)+d_vol(1))
!!$       return
!!$    end if
!!$    if(sh_type <= 5 ) then
!!$       ! calculate number of extra ice crystal
!!$       call cal_exice(init_growth,growth_mode,Qp(inex))
!!$
!!$
!!$       Qp(iacr)=Qp(iacr)+d_axis_len(1)
!!$       Qp(iccr)=Qp(iccr)+d_axis_len(2)
!!$
!!$       if(len_switch(1)/=0.or.d_axis_len(1)<0.0_PS) then
!!$          Qp(idcr)=max(Qp(idcr)+d_axis_len(1),0.0_PS)
!!$!!c          if(Temp<253.16.and.Qp(idcr)>0.0) then
!!$!!c             write(*,*) "here wrong Qp(idcr)",init_growth,growth_mode,len_switch,d_axis_len
!!$!!c          end if
!!$       end if
!!$
!!$       ! keep a and c axis lengths in realistic range
!!$       if(Qp(iacr)*phi_max<Qp(iccr)) then
!!$          d_axis_len(2)=Qp(iacr)*phi_max-clen
!!$          Qp(iccr)=Qp(iacr)*phi_max
!!$          Qp(icg)=min(Qp(icg),Qp(iccr))
!!$       else if(Qp(iacr)*phi_min>Qp(iccr)) then
!!$          d_axis_len(1)=Qp(iccr)/phi_min-alen
!!$          Qp(iacr)=Qp(iccr)/phi_min
!!$          Qp(iag)=min(Qp(iag),Qp(iacr))
!!$       end if
!!$
!!$!!c          ! assume that axis ratio does not cross phi=1 when evaporating.
!!$!!c          if(min(d_axis_len(1),d_axis_len(2))<0.0 )then
!!$!!c             if(clen/alen<=1.0_PS.and.Qp(iccr)/Qp(iacr)>=1.0_PS) then
!!$!!c                write(*,*) "phi from pla to col switch occurred:T",Temp
!!$!!c                Qp(iacr)=Qp(iccr)
!!$!!c                d_axis_len(1)=Qp(iacr)-alen
!!$!!c             elseif(clen/alen>=1.0_PS.and.Qp(iccr)/Qp(iacr)<=1.0_PS) then
!!$!!c                write(*,*) "phi from col to pla switch occurred:T",Temp
!!$!!c                Qp(iccr)=Qp(iacr)
!!$!!c                d_axis_len(2)=Qp(iccr)-clen
!!$!!c             end if
!!$!!c          end if
!!$
!!$       ! keep a and c axis length positive!
!!$       if(Qp(iacr)<1.0e-4_PS) then
!!$!!c             write(*,*) "Qp(iacr) is less than 1.0um, so fixed",Qp
!!$!!c             write(*,*) "d_axis_len",d_axis_len,len_switch
!!$          d_axis_len(1)=1.0e-4_PS-alen
!!$          Qp(iacr)=1.0e-4_PS
!!$          Qp(idcr)=0.0e-4_PS
!!$          Qp(iag)=min(Qp(iag),Qp(iacr))
!!$       end if
!!$       if(Qp(iccr)<1.0e-4_PS) then
!!$          d_axis_len(2)=1.0e-4_PS-clen
!!$          Qp(iccr)=1.0e-4_PS
!!$          Qp(icg)=min(Qp(icg),Qp(iccr))
!!$       end if
!!$
!!$
!!$       ! calculate center of gravity
!!$       call cal_gcord_ice(init_growth,growth_mode,Qp(iacr),Qp(iccr),Qp(iag),Qp(icg),d_axis_len) !Temp,S_ice,
!!$
!!$    endif
!!$    if(sh_type <= 2 ) then
!!$       if(growth_mode==2.or.growth_mode==3) then
!!$          Qp(ivcs)=coef4pi3*(Qp(iacr)**2.0+Qp(iccr)**2.0)**1.5
!!$          phi=Qp(iccr)/Qp(iacr)
!!$       elseif(growth_mode==4) then
!!$          Qp(ivcs)=coef4pi3*((1.0_PS+phi_ros**2.0)**1.5)*get_len_c2a(m_ic)**3.0
!!$          phi=phi_ros
!!$       elseif(growth_mode==1) then
!!$          Qp(ivcs)=coef4pi3*((1.0_PS+phi_s3**2.0)**1.5)*get_len_s3(m_ic)**3.0
!!$          phi=phi_s3
!!$       elseif(growth_mode==5) then
!!$          Qp(ivcs)=coef4pi3*((1.0_PS+phi_sdpl**2.0)**1.5)*get_len_s1(m_ic)**3.0
!!$          phi=phi_sdpl
!!$       end if
!!$       ! assume the cylinder volume
!!$!!c       Qp(8)=(Qp(ivcs)/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi**2.0)
!!$!!c       Qp(9)=Qp(8)*phi
!!$       call cal_semiac_ip(is_mod,phi,Qp(ivcs),Qp(mxnnonmc+1),Qp(mxnnonmc+2))
!!$    else
!!$!!c       if(semi_alen+d_axis_len(1)<1.0e-4_PS) then
!!$!!c          d_axis_len(1)=1.0e-4_PS-semi_alen
!!$!!c       end if
!!$!!c       if(semi_clen+d_axis_len(2)<1.0e-4_PS) then
!!$!!c          d_axis_len(2)=1.0e-4_PS-semi_clen
!!$!!c       end if
!!$!!c       Qp(ivcs)=coef4pi3*( (semi_alen+d_axis_len(1))**2.0+&
!!$!!c            (semi_clen+d_axis_len(2))**2.0 )**1.5
!!$
!!$       Qp(ivcs)=max(0.0_PS,Qp(ivcs)+d_vol(1))
!!$
!!$       phi=Qp(mxnnonmc+2)/Qp(mxnnonmc+1)
!!$       ! assume the cylinder volume
!!$!!c       Qp(8)=(Qp(ivcs)/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi**2.0)
!!$!!c       Qp(9)=Qp(8)*phi
!!$       call cal_semiac_ip(is_mod,phi,Qp(ivcs),Qp(mxnnonmc+1),Qp(mxnnonmc+2))
!!$    end if
!!$
!!$
!!$
!!$
!!$!!c    Qp(ivcs)=max(m_ic/den_i,Qp(ivcs))
!!$
!!$!!c    do i = 1, g%N_vol
!!$!!c       Qp(1+g%N_axis+i) = g%MS(clctr,ngrid)%vol(i) + d_vol(i)
!!$!!c    end do
!!$!!c    if( Qp(ivcs) < V_csmin) then
!!$!!c       Qp(ivcs)=V_csmin
!!$!!c       Qp(iacr)=1.0_PS
!!$!!c       Qp(iccr)=1.0_PS
!!$!!c       Qp(idcr)=0.0_PS
!!$!!c       Qp(iag)=0.0_PS
!!$!!c       Qp(icg)=0.0_PS
!!$!!c       Qp(inex)=0.0_PS
!!$!!c    end if
!!$!!c    if(max(alen,clen)>max(rlen,elen)) then
!!$!!c       if(max(Qp(iacr),Qp(iccr))<max(Qp(iag),Qp(icg))) then
!!$!!c          write(*,11) alen,clen,rlen,elen
!!$!!c          write(*,12) Qp(iacr),Qp(iccr),Qp(iag),Qp(icg)
!!$10        format("change-habit:bin, ngrid",2I5)
!!$11        format("change-habit:old values",5ES15.6)
!!$12        format("new values",5ES15.6)
!!$!!c       end if
!!$!!c    end if
!!$  end subroutine assign_Qp_v3

  subroutine assign_Qp_v3_vec(g,icond3,d_axis_len,d_vol,len_switch,iwet &
                             ,Mp,ratio_Mp,Qp)
    use class_Ice_Shape, only: &
       get_vcs, &
       cal_semiac_ip
    use mod_amps_utility, only: &
       get_len_s3, &
       get_len_s1, &
       get_len_c2a
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the new non-mass variables in the shifted bin for
    ! vapor deposition process
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! mass (liquid or solid) group
    type (Group), intent(in)   :: g
    ! thermo variable object
    !type (AirGroup), intent(in)  :: ag
    integer,dimension(mxnbin+1,*),intent(in) :: icond3
    real(PS), dimension(mxnbin+1,*),intent(in)           :: Mp
    ! ratio of mass change in sihfted bin on each axis to total mass
    real(PS), dimension(mxnbin+1,g%L,mxnmasscomp)      :: ratio_Mp
    real(PS), dimension(mxnbin,g%L,mxnvol),intent(inout)       :: d_vol
    real(PS), dimension(mxnbin+1,g%L,2),intent(inout)       :: d_axis_len
    real(PS), dimension(mxnbin+1,g%L,mxnnonmc+2),intent(inout) :: Qp
    integer,dimension(mxnbin,*),intent(in) :: iwet
    ! indication of dendritic growth
    integer,dimension(mxnbin,g%L,3),intent(in) :: len_switch

    integer                    :: i,n
!    integer,dimension((mxnbin+1)*LMAX) :: ierror1
    real(PS):: m_ic

    ! minimum possible volume of ice crystal
    real(PS),parameter :: V_csmin=1.1847688e-11
    ! maximum and minimum aspect ratio
    real,parameter  :: phi_max=2.0e+1,phi_min=5.0e-3

    real(PS),parameter :: phi_ros=0.25_PS,phi_s3=0.25_PS,phi_sdpl=0.25_PS

    real(PS) :: phi,phi_cs,semi_a,semi_c,vice!,max_rad

!    do in=1,g%N_BIN*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

!      ierror1(in)=0

      if(icond3(i,n)==1) then
        ! NOTE: quality component is defined for a partile, not for whole the bin.
        !
        ! assumption
        ! 1. volume of circumscribing sphere is assumed to grow by capacitance calculated
        !    by the sphere.
        ! 2. In cases of aggregates or graupel, ice crystals inside do not grow.
        !
        Qp(i,n,ivcs)=g%IS(i,n)%V_cs
        Qp(i,n,iacr)=g%MS(i,n)%a_len
        Qp(i,n,iccr)=g%MS(i,n)%c_len
        Qp(i,n,idcr)=g%IS(i,n)%d
        Qp(i,n,iag)=g%IS(i,n)%ag
        Qp(i,n,icg)=g%IS(i,n)%cg
        Qp(i,n,inex)=g%IS(i,n)%n_exice
        Qp(i,n,mxnnonmc+1)=g%MS(i,n)%semi_a
        Qp(i,n,mxnnonmc+2)=g%MS(i,n)%semi_c


        if(iwet(i,n)==1) then
          Qp(i,n,ivcs)=max(0.0_PS,Qp(i,n,ivcs)+d_vol(i,n,1))

        else
          ! calculate number of extra ice crystal
          call cal_exice(g%IS(i,n)%init_growth,g%IS(i,n)%growth_mode,Qp(i,n,inex))


          Qp(i,n,iacr)=Qp(i,n,iacr)+d_axis_len(i,n,1)
          Qp(i,n,iccr)=Qp(i,n,iccr)+d_axis_len(i,n,2)

          if(len_switch(i,n,1)/=0.or.d_axis_len(i,n,1)<0.0_PS) then
            Qp(i,n,idcr)=max(Qp(i,n,idcr)+d_axis_len(i,n,1),0.0_PS)
!!c          if(Temp<253.16.and.Qp(idcr)>0.0) then
!!c             write(*,*) "here wrong Qp(idcr)",init_growth,growth_mode,len_switch,d_axis_len
!!c          end if
          end if

          ! keep a and c axis lengths in realistic range
          if(Qp(i,n,iacr)*phi_max<Qp(i,n,iccr)) then
            d_axis_len(i,n,2)=Qp(i,n,iacr)*phi_max-g%MS(i,n)%c_len
            Qp(i,n,iccr)=Qp(i,n,iacr)*phi_max
            Qp(i,n,icg)=min(Qp(i,n,icg),Qp(i,n,iccr))
          else if(Qp(i,n,iacr)*phi_min>Qp(i,n,iccr)) then
            d_axis_len(i,n,1)=Qp(i,n,iccr)/phi_min-g%MS(i,n)%a_len
            Qp(i,n,iacr)=Qp(i,n,iccr)/phi_min
            Qp(i,n,iag)=min(Qp(i,n,iag),Qp(i,n,iacr))
          end if


          ! keep a and c axis length positive!
          if(Qp(i,n,iacr)<1.0e-4_PS) then
!!c             write(*,*) "Qp(iacr) is less than 1.0um, so fixed",Qp
!!c             write(*,*) "d_axis_len",d_axis_len,len_switch
            d_axis_len(i,n,1)=1.0e-4_PS-g%MS(i,n)%a_len
            Qp(i,n,iacr)=1.0e-4_PS
            Qp(i,n,idcr)=0.0e-4_PS
            Qp(i,n,iag)=min(Qp(i,n,iag),Qp(i,n,iacr))
          end if
          if(Qp(i,n,iccr)<1.0e-4_PS) then
            d_axis_len(i,n,2)=1.0e-4_PS-g%MS(i,n)%c_len
            Qp(i,n,iccr)=1.0e-4_PS
            Qp(i,n,icg)=min(Qp(i,n,icg),Qp(i,n,iccr))
          end if

          ! assume that axis ratio does not cross phi=1 when evaporating.
          if(min(d_axis_len(i,n,1),d_axis_len(i,n,2))<0.0_PS )then
             if(g%MS(i,n)%c_len/g%MS(i,n)%a_len<=1.0_PS.and.Qp(i,n,iccr)/Qp(i,n,iacr)>=1.0_PS) then
!!!                write(*,*) "phi from pla to col switch occurred:a,c",g%MS(i,n)%a_len,g%MS(i,n)%c_len
                Qp(i,n,iacr)=Qp(i,n,iccr)
                d_axis_len(i,n,1)=Qp(i,n,iacr)-g%MS(i,n)%a_len
             elseif(g%MS(i,n)%c_len/g%MS(i,n)%a_len>=1.0_PS.and.Qp(i,n,iccr)/Qp(i,n,iacr)<=1.0_PS) then
!!!                write(*,*) "phi from col to pla switch occurred:a,c",g%MS(i,n)%a_len,g%MS(i,n)%c_len
                Qp(i,n,iccr)=Qp(i,n,iacr)
                d_axis_len(i,n,2)=Qp(i,n,iccr)-g%MS(i,n)%c_len
             end if
          end if

          ! calculate center of gravity
          call cal_gcord_ice( & !ag%TV(n)%T,ag%TV(n)%s_v(2)
                  g%IS(i,n)%init_growth,g%IS(i,n)%growth_mode &
                  ,Qp(i,n,iacr),Qp(i,n,iccr),Qp(i,n,iag),Qp(i,n,icg),d_axis_len(i,n,1),d_axis_len(i,n,2))


          select case(g%IS(i,n)%sh_type)
          case(1)
            ! --- pristine crystals ---

            if(g%IS(i,n)%is_mod(2)==1) then
              m_ic=Mp(i,n)*ratio_Mp(i,n,imc_m)/g%MS(i,n)%con

              select case(g%IS(i,n)%growth_mode)
              case(2,3)
                semi_a=Qp(i,n,iacr)
                phi=Qp(i,n,iccr)/Qp(i,n,iacr)
              case(4)
                semi_a=get_len_c2a(m_ic)
                phi=phi_ros
              case(1)
                semi_a=get_len_s3(m_ic)
                phi=phi_s3
              case default
                semi_a=get_len_s1(m_ic)
                phi=phi_sdpl
              end select
              Qp(i,n,ivcs)=get_vcs(g%IS(i,n)%is_mod(2),phi,semi_a)
            else
              ! ice sphere
              phi=1.0
              m_ic=Mp(i,n)*(1.0-ratio_Mp(i,n,imw_m))/g%MS(i,n)%con
              Qp(i,n,ivcs)=max(V_csmin,m_ic/den_i)
            endif

            call cal_semiac_ip(g%IS(i,n)%is_mod(2),phi,Qp(i,n,ivcs),Qp(i,n,mxnnonmc+1),Qp(i,n,mxnnonmc+2))
          case(2)
            ! --- rimed crystals ---

            if(g%IS(i,n)%is_mod(2)==1) then
              m_ic=Mp(i,n)*ratio_Mp(i,n,imc_m)/g%MS(i,n)%con

              select case(g%IS(i,n)%growth_mode)
              case(2,3)
                semi_a=Qp(i,n,iacr)
                phi=Qp(i,n,iccr)/Qp(i,n,iacr)
              case(4)
                semi_a=get_len_c2a(m_ic)
                phi=phi_ros
              case(1)
                semi_a=get_len_s3(m_ic)
                phi=phi_s3
              case default
                semi_a=get_len_s1(m_ic)
                phi=phi_sdpl
              end select
              semi_c=semi_a*phi
              vice=get_vcs(g%IS(i,n)%is_mod(2),phi,semi_a)

              ! assume that
              !   vapor deposition does not change the semi minor axis length of
              !   ice particle model.
              if(phi<1.0_PS) then
                phi_cs=g%IS(i,n)%semi_cip/semi_a
                Qp(i,n,ivcs)=vice*((1.0_PS+phi_cs*phi_cs)/(1.0_PS+phi*phi))**1.5_PS
              else
                phi_cs=semi_c/g%IS(i,n)%semi_aip
                Qp(i,n,ivcs)=vice*((1.0_PS+1.0_PS/(phi_cs*phi_cs))/(1.0_PS+1.0_PS/(phi*phi)))**1.5_PS
              endif
            else
              ! ice sphere
              phi_cs=1.0_PS
              m_ic=Mp(i,n)*(1.0_PS-ratio_Mp(i,n,imw_m))/g%MS(i,n)%con
              Qp(i,n,ivcs)=max(V_csmin,m_ic/den_i)

            endif

            call cal_semiac_ip(g%IS(i,n)%is_mod(2),phi_cs,Qp(i,n,ivcs),Qp(i,n,mxnnonmc+1),Qp(i,n,mxnnonmc+2))
          case default


            Qp(i,n,ivcs)=max(V_csmin,Qp(i,n,ivcs)+d_vol(i,n,1))

            phi=Qp(i,n,mxnnonmc+2)/Qp(i,n,mxnnonmc+1)
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),phi,Qp(i,n,ivcs),Qp(i,n,mxnnonmc+1),Qp(i,n,mxnnonmc+2))
          end select

        endif

        if( debug .and. Qp(i,n,ivcs)<1.0e-30_PS) then
          m_ic=Mp(i,n)*ratio_Mp(i,n,imc_m)/g%MS(i,n)%con
          write(*,*) "Vcs less than 1.0e-30",i,n,qp(i,n,ivcs),g%IS(i,n)%v_cs &
              ,iwet(i,n),g%IS(i,n)%sh_type,d_vol(i,n,1),m_ic &
              ,Mp(i,n),ratio_Mp(i,n,imc_m),g%MS(i,n)%con &
              ,g%IS(i,n)%growth_mode,get_len_s3(m_ic),get_len_s3(m_ic)**3
        endif
      endif
    enddo
    enddo

!!c    Qp(ivcs)=max(m_ic/den_i,Qp(ivcs))

!!c    do i = 1, g%N_vol
!!c       Qp(1+g%N_axis+i) = g%MS(clctr,ngrid)%vol(i) + d_vol(i)
!!c    end do
!!c    if( Qp(ivcs) < V_csmin) then
!!c       Qp(ivcs)=V_csmin
!!c       Qp(iacr)=1.0_PS
!!c       Qp(iccr)=1.0_PS
!!c       Qp(idcr)=0.0_PS
!!c       Qp(iag)=0.0_PS
!!c       Qp(icg)=0.0_PS
!!c       Qp(inex)=0.0_PS
!!c    end if
!!c    if(max(alen,clen)>max(rlen,elen)) then
!!c       if(max(Qp(iacr),Qp(iccr))<max(Qp(iag),Qp(icg))) then
!!c          write(*,11) alen,clen,rlen,elen
!!c          write(*,12) Qp(iacr),Qp(iccr),Qp(iag),Qp(icg)
!!c10        format("change-habit:bin, ngrid",2I5)
!!c11        format("change-habit:old values",5ES15.6)
!!c12        format("new values",5ES15.6)
!!c       end if
!!c    end if
  end subroutine assign_Qp_v3_vec

  function get_massagg(ihabit,dia) result(mass)
    real(PS),intent(in) :: dia
    real(PS) :: mass
    integer,intent(inout) :: ihabit
    ! Kajikawa (1982)'s formula for density of aggregates with plates. den=a*D**b
    real(PS),parameter :: a_pla=0.00089_PS,b_pla=-1.23_PS
    ! Heymsfields et al. (2002)'s formula (table 1)
    real(PS),parameter :: a_ros=0.0035_PS,b_ros=-0.96_PS
    real(PS),parameter :: a_irr=0.0061_PS,b_irr=-0.92_PS

    if(ihabit<=3) then
       ! hexagonal crystals
       mass=coefpi6*a_pla*dia**(3.0+b_pla)
    elseif(ihabit==4) then
       ! columnar polycrystals
       mass=coefpi6*a_ros*dia**(3.0+b_ros)
    elseif(ihabit==5) then
       ! planar polycrystals
       mass=coefpi6*a_irr*dia**(3.0+b_irr)
    elseif(ihabit==6) then
       ! irregular polycrystals
       mass=coefpi6*a_irr*dia**(3.0+b_irr)
    endif
  end function get_massagg

  function get_volagg(ihabit,mass) result(vol)
    real(PS),intent(in) :: mass
    real(PS) :: vol
    integer,intent(inout) :: ihabit
    ! Kajikawa (1982)'s formula for density of aggregates with plates. den=a*D**b
    real(PS),parameter :: a_pla=0.00089_PS,b_pla=-1.23_PS
    real(PS),parameter :: a_ros=0.0035_PS,b_ros=-0.96_PS
    real(PS),parameter :: a_irr=0.0061_PS,b_irr=-0.92_PS

    if(ihabit<=3) then
       ! hexagonal crystals
       vol=coefpi6*(mass/(coefpi6*a_pla))**(3.0/(b_pla+3.0))
    elseif(ihabit==4) then
       ! columnar polycrystals
       vol=coefpi6*(mass/(coefpi6*a_ros))**(3.0/(b_ros+3.0))
    elseif(ihabit==5) then
       ! planar polycrystals
       vol=coefpi6*(mass/(coefpi6*a_irr))**(3.0/(b_irr+3.0))
    elseif(ihabit==6) then
       ! irregular polycrystals
       vol=coefpi6*(mass/(coefpi6*a_irr))**(3.0/(b_irr+3.0))
    endif
  end function get_volagg

  subroutine cal_dendim_coef2(aa,bb,den1,dia1,mass1,den2,dia2,mass2)
    real(PS),intent(in) :: dia1,dia2
    real(PS),intent(inout) :: aa,bb,den1,mass1,den2,mass2
    !integer,intent(inout) :: ihabit
    ! Kajikawa (1982)'s formula for density of aggregates with plates. den=a*D**b
    real(PS),parameter :: a_pla=0.00089,b_pla=-1.23
    real(PS),parameter :: a_ros=0.0035,b_ros=-0.96
    real(PS),parameter :: a_irr=0.0061,b_irr=-0.92

    !  if den_ice<g%MS(i,n)%den, it wont work
    if(den1>den2) then
       bb=log(den1/den2)/log(dia1/dia2)
! <<< 2014/11 T. Hashino added
       ! need a bound  (if bb=-3, then does not work since m=a*D^0)
       bb=max(-1.5_RP,min(-0.5_RP,bb))
! >>> 2014/11 T. Hashino added
       aa=den2/(dia2**bb)

! <<< 2014/11 T. Hashino added
       if(den1<aa*dia1**bb) then
          ! assume the smallest fragment has the same size as the crystal, and
          ! gain some mass by aggregation components
          mass1=coefpi6*aa*dia1**(3.0_RP+bb)
          den1=aa*dia1**bb
       end if
! >>> 2014/11 T. Hashino added


    else
       bb=0.0_RP
       aa=den2
       ! assume the smallest fragment has the same size as the crystal, and
       ! gain some mass by aggregation components
       mass1=coefpi6*aa*dia1**(3.0_RP+bb)
       den1=aa*dia1**bb
    end if
    mass2=coefpi6*aa*dia2**(3.0_RP+bb)

  end subroutine cal_dendim_coef2

  function fnc1(x) result(out)
    real(PS),intent(in) :: x
    real(PS) :: out
    out=exp(x)*(x*x*x-3.0_PS*x*x+6.0_PS*x-6.0_PS)
  end function fnc1

  function P_breakup(phase, a_star, max_dim) result(out)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate probability for the parent drop to break up in time dt
    ! based on Kombayashi et al. (1964)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! phase of water
    ! 1: water, 2: ice
    integer, intent(in)    :: phase
    ! radius of parent hydrometeor in mm
    real(PS), intent(in)  :: a_star
    ! maximum dimension, (radius), of rain or aggregate (cm)
    real(PS), intent(in)             :: max_dim
    real(PS)             :: k, out
    if( phase == 1 ) then
       ! case of liquid
       ! the probability becomes about 1 at 4.5 mm
       if( a_star >= max_dim ) then
          out = 1.0_PS
       else
          out = min( 2.94e-7_PS*exp(3.4_PS*a_star*10.0_PS), 1.0_PS )
       end if
    else if( phase == 2 ) then
       ! case of ice
       ! NOTE: assume that one coefficient is the same as liquid case
       if( a_star >= max_dim ) then
          out = 1.0_PS
       else
          k = 15.03968607_PS/(max_dim*10.0_PS)
          out = min(2.94e-7_PS*exp(k*a_star*10.0_PS),1.0_PS)
       end if
    end if
  end function P_BREAKUP

!!$  function Q_breakup(phase, a_star, a, m, switch) result(out)
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate (switch = 1): number of drops of mass between m and m+dm
!!$    !           (switch = 2): total number of drops between a and m (#/cm^3)
!!$    !                         a < m cm
!!$    !           (switch = 3): total mass of drops between a and m (a < m cm)
!!$    ! based on Srivastava (1971)
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! phase of water
!!$    ! 1: water, 2: ice
!!$    integer, intent(in)    :: phase
!!$    real(PS),intent(in)  :: a_star, a, m
!!$    integer, intent(in)  :: switch
!!$    real(PS)             :: out, x1, x2
!!$    real(PS), parameter     :: AA = 62.3
!!$    real(PS), parameter     :: BB = 7.0
!!$    if( phase == 1 ) then
!!$       if( switch == 1 ) then
!!$          out = (AA*BB/3.0_PS/m)*(a/a_star)*exp(-BB*a/a_star)
!!$       else if( switch == 2 ) then
!!$          out = -AA*( exp(-BB*m/a_star) - exp(-BB*a/a_star))
!!$       else if( switch == 3 ) then
!!$          !     a_2
!!$          ! M = \  (4*PI/3)*den_w*a^3 Q(a*,a) da
!!$          !     a_1
!!$          !
!!$          ! +++ change radius and to parameter +++
!!$          !     x = B a/a_star
!!$          x1 = BB*a/a_star
!!$          x2 = BB*m/a_star
!!$
!!$          out = (4.0_PS*PI/3.0_PS)*AA*((a_star/BB)**3.0)*&
!!$               fGM(4.0_PS, x1, x2)
!!$
!!$       end if
!!$    else if( phase == 2 ) then
!!$       if( switch == 1 ) then
!!$          out = (AA*BB/3.0_PS/m)*(a/a_star)*exp(-BB*a/a_star)
!!$       else if( switch == 2 ) then
!!$          out = -AA*( exp(-BB*m/a_star) - exp(-BB*a/a_star))
!!$       end if
!!$    end if
!!$
!!$
!!$
!!$  end function Q_BREAKUP

  function Q_breakup2(phase, a_star, a, m, AA, BB,switch) result(out)
    use mod_amps_utility, only: &
       fGM
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate (switch = 1): number of drops of mass between m and m+dm
    !           (switch = 2): total number of drops between a and m (#/cm^3)
    !                         a < m cm
    !           (switch = 3): total mass of drops between a and m (a < m cm)
    ! based on Srivastava (1971)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! phase of water
    ! 1: water, 2: ice
    integer, intent(in)    :: phase
    real(PS),intent(in)  :: a_star, a, m,AA,BB
    integer, intent(in)  :: switch
    real(PS)             :: out, x1, x2

    if( phase == 1 ) then
       if( switch == 1 ) then
          out = (AA*BB/3.0_PS/m)*(a/a_star)*exp(-BB*a/a_star)
       else if( switch == 2 ) then
          out = -AA*( exp(-BB*m/a_star) - exp(-BB*a/a_star))
       else if( switch == 3 ) then
          !     a_2
          ! M = \  (4*PI/3)*den_w*a^3 Q(a*,a) da
          !     a_1
          !
          ! +++ change radius and to parameter +++
          !     x = B a/a_star
          x1 = BB*a/a_star
          x2 = BB*m/a_star

          out = (4.0_PS*PI/3.0_PS)*AA*((a_star/BB)**3.0)*&
               fGM(4.0_PS, x1, x2)

       end if
    else if( phase == 2 ) then
       if( switch == 1 ) then
          out = (AA*BB/3.0_PS/m)*(a/a_star)*exp(-BB*a/a_star)
       else if( switch == 2 ) then
          out = -AA*( exp(-BB*m/a_star) - exp(-BB*a/a_star))
       end if
    end if

  end function Q_BREAKUP2

!!$  subroutine assign_Qpini_v3_vec(Qp,ag,m_ic,vcs,alen,clen,icond1,d_axis_len,growth_mode)
!!$    use mod_amps_utility, only: get_len_s3,get_len_s1,get_len_c2a
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the new non-mass variables in the shifted bin for
!!$    ! vapor deposition process
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! thermo variable object
!!$    type (AirGroup), intent(in)  :: ag
!!$    integer,dimension(*),intent(in) :: icond1
!!$    integer,dimension(*),intent(in) :: growth_mode
!!$    real(PS), dimension(*),intent(in) :: m_ic,vcs,alen,clen
!!$    ! ratio of mass change in sihfted bin on each axis to total mass
!!$    real(PS), dimension(2,*),intent(in)       :: d_axis_len
!!$    real(PS), dimension(mxnnonmc+2,*),intent(inout) :: Qp
!!$
!!$    integer :: init_growth,is_mod
!!$
!!$    integer                    :: n!,i
!!$
!!$    real(PS),parameter :: phi_ros=0.25_PS,phi_s3=0.25_PS,phi_sdpl=0.25_PS
!!$    ! minimum possible volume of ice crystal
!!$    real(PS),parameter :: V_csmin=1.1847688e-11
!!$
!!$    real(PS) :: phi,semi_a!,phi_cs,semi_c,vice
!!$
!!$    init_growth=1
!!$    is_mod=1
!!$    do n=1,ag%L
!!$
!!$      Qp(ivcs,n)=0.0_PS
!!$      Qp(iacr,n)=0.0_PS
!!$      Qp(iccr,n)=0.0_PS
!!$      Qp(idcr,n)=0.0_PS
!!$      Qp(iag,n)=0.0_PS
!!$      Qp(icg,n)=0.0_PS
!!$      Qp(inex,n)=0.0_PS
!!$      Qp(mxnnonmc+1,n)=0.0_PS
!!$      Qp(mxnnonmc+2,n)=0.0_PS
!!$      if(icond1(n)==1) then
!!$        ! NOTE: quality component is defined for a partile, not for whole the bin.
!!$        !
!!$        ! assumption
!!$        ! 1. volume of circumscribing sphere is assumed to grow by capacitance calculated
!!$        !    by the sphere.
!!$        ! 2. In cases of aggregates or graupel, ice crystals inside do not grow.
!!$        !
!!$        Qp(ivcs,n)=vcs(n)
!!$        Qp(iacr,n)=alen(n)
!!$        Qp(iccr,n)=clen(n)
!!$        Qp(idcr,n)=0.0_PS
!!$        Qp(iag,n)=0.0_PS
!!$        Qp(icg,n)=0.0_PS
!!$        Qp(inex,n)=0.0_PS
!!$        Qp(mxnnonmc+1,n)=alen(n)
!!$        Qp(mxnnonmc+2,n)=clen(n)
!!$
!!$
!!$        ! calculate number of extra ice crystal
!!$        call cal_exice(init_growth,growth_mode(n),Qp(inex,n))
!!$
!!$
!!$        Qp(iacr,n)=Qp(iacr,n)+d_axis_len(1,n)
!!$        Qp(iccr,n)=Qp(iccr,n)+d_axis_len(2,n)
!!$
!!$        ! calculate center of gravity
!!$        call cal_gcord_ice( &
!!$                  init_growth,growth_mode(n) &
!!$                  ,Qp(iacr,n),Qp(iccr,n),Qp(iag,n),Qp(icg,n),d_axis_len(1,n))
!!$
!!$
!!$        ! --- pristine crystals ---
!!$        if(is_mod==1) then
!!$          select case(growth_mode(n))
!!$          case(2,3)
!!$            semi_a=Qp(iacr,n)
!!$            phi=Qp(iccr,n)/Qp(iacr,n)
!!$          case(4)
!!$            semi_a=get_len_c2a(m_ic(n))
!!$            phi=phi_ros
!!$          case(1)
!!$            semi_a=get_len_s3(m_ic(n))
!!$            phi=phi_s3
!!$          case default
!!$            semi_a=get_len_s1(m_ic(n))
!!$            phi=phi_sdpl
!!$          end select
!!$          Qp(ivcs,n)=get_vcs(is_mod,phi,semi_a)
!!$        else
!!$          ! ice sphere
!!$          phi=1.0
!!$          Qp(ivcs,n)=max(V_csmin,m_ic(n)/den_i)
!!$        endif
!!$
!!$        call cal_semiac_ip(is_mod,phi,Qp(ivcs,n),Qp(mxnnonmc+1,n),Qp(mxnnonmc+2,n))
!!$      endif
!!$    enddo
!!$
!!$  end subroutine assign_Qpini_v3_vec

  subroutine cal_exice(init_growth,growth_mode,n_exice)
    !real(PS), intent(in)               :: T,S_max
    integer, intent(in) :: init_growth,growth_mode
    real(PS), intent(inout) :: n_exice

    if(init_growth==1) then
! sense test Ong Chia Rui, original is false
!!$if (.false.) then
!!$   !n_exice=0.0_PS
!!$   n_exice=1.0_PS
!!$else
       if(growth_mode==1) then
          n_exice=1.0_PS
       elseif(growth_mode<=3) then
          n_exice=0.0_PS
       elseif(growth_mode==4) then
          n_exice=1.0_PS
       elseif(growth_mode==5) then
          n_exice=1.0_PS
       end if
!!$endif
    end if
  end subroutine cal_exice

  subroutine cal_gcord_ice(init_growth,growth_mode,alen,clen,ag,cg,d_axis_len1,d_axis_len2)
    ! calculate center of gravity
    real(PS), intent(in)               :: alen,clen!,T,S_max
    integer,intent(in) :: init_growth,growth_mode
    real(PS), intent(inout) :: ag,cg
!tmp    real(PS), pointer, dimension(:) :: d_axis_len
    real(PS) :: d_axis_len1
    real(PS) :: d_axis_len2

    if(init_growth==1) then
! sense test Ong Chia Rui, original is false
!!$if (.false.) then
!!$   !ag=0.0_PS
!!$   !cg=0.0_PS
!!$   ag=0.0_PS
!!$   cg=clen
!!$else
       if(growth_mode==1) then
          ag=alen*0.5_PS
          cg=clen*0.5_PS
       elseif(growth_mode<=3) then
          ag=0.0_PS
          cg=0.0_PS
       elseif(growth_mode==4) then
          ag=0.0_PS
          cg=clen
       elseif(growth_mode==5) then
          ag=alen
          cg=0.0_PS
       end if
!!$endif
    else
! sense test Ong Chia Rui, original is false
!!$if (.false.) then
!!$   cg = max(cg+d_axis_len2,0.0_PS)
!!$   !ag=max(ag+d_axis_len1,0.0_PS) ! force planar polycrystals
!!$else
       ! asusme that the center of gravity is not affected by
       ! vapor deposition growth
       if(growth_mode==1) then
             ag=max(ag+d_axis_len1*0.5_PS,0.0_PS)
             cg=max(cg+d_axis_len2*0.5_PS,0.0_PS)
       elseif(growth_mode<=3) then
       elseif(growth_mode==4) then
!!c          cg=clen
             cg=max(cg+d_axis_len2,0.0_PS)
       elseif(growth_mode==5) then
!!c          ag=alen
             ag=max(ag+d_axis_len1,0.0_PS)
       end if
!!$endif
    end if

  end subroutine cal_gcord_ice

!!$  subroutine dep_mass(dM,mass_comp,left_mass)
!!$     ! assume that hydrometeor evaporate
!!$     !    1. aggregation mass com,or rime mass (larger one is the fist)
!!$     !    2. crystal mass com.
!!$     implicit none
!!$     real(PS),intent(in) :: dM
!!$     real(PS),dimension(:)  :: mass_comp,left_mass
!!$     real(PS) :: dum_m
!!$
!!$     if( mass_comp(imr)>=mass_comp(ima) ) then
!!$        dum_m=left_mass(imr_m)+dM
!!$        if( dum_m<0.0_PS ) then
!!$           left_mass(imr_m)=0.0_PS
!!$           dum_m=left_mass(ima_m)+dum_m
!!$           if( dum_m<0.0_PS ) then
!!$              left_mass(ima_m)=0.0_PS
!!$              dum_m=left_mass(imc_m)+dum_m
!!$              if( dum_m<0.0_PS ) then
!!$                 write(*,*) "everything is 0! (1)"
!!$                 write(*,*) "temp_dM",dM
!!$                 write(*,*) "masscom",mass_comp
!!$                 write(*,*) "dum_m",dum_m
!!$                 stop
!!$              else
!!$                 left_mass(imc_m)=dum_m
!!$              end if
!!$           else
!!$              left_mass(ima_m)=dum_m
!!$           end if
!!$        else
!!$           left_mass(imr_m)=dum_m
!!$        end if
!!$     else if( mass_comp(imr)<mass_comp(ima) ) then
!!$        dum_m=left_mass(ima_m)+dM
!!$        if( dum_m<0.0_PS ) then
!!$           left_mass(ima_m)=0.0_PS
!!$           dum_m=left_mass(imr_m)+dum_m
!!$           if( dum_m<0.0_PS ) then
!!$              left_mass(imr_m)=0.0_PS
!!$              dum_m=left_mass(imc_m)+dum_m
!!$              if( dum_m<0.0_PS ) then
!!$                 write(*,*) "everything is 0! (2)"
!!$                 write(*,*) "temp_dM",dM
!!$                 write(*,*) "masscom",mass_comp
!!$                 write(*,*) "dum_m",dum_m
!!$                 stop
!!$              else
!!$                 left_mass(imc_m)=dum_m
!!$              end if
!!$           else
!!$              left_mass(imr_m)=dum_m
!!$           end if
!!$        else
!!$           left_mass(ima_m)=dum_m
!!$        end if
!!$     end if
!!$
!!$     if(left_mass(imc_m)<=0.0) then
!!$        write(*,*) "something is wrong here"
!!$        write(*,*) "temp_dM",dM
!!$        write(*,*) "masscom",mass_comp(1:4)
!!$        stop
!!$     end if
!!$
!!$  end subroutine dep_mass

!!$  subroutine dep_mass2(dM,mass_comp,left_mass,ierr,from)
!!$     ! assume that hydrometeor evaporate
!!$     !    1. aggregation mass com,or rime mass (keeping the same ratio)
!!$     !    2. crystal mass com.
!!$     implicit none
!!$     real(PS),intent(in) :: dM
!!$!tmp     real(PS),pointer,dimension(:)  :: mass_comp,left_mass
!!$     real(PS),dimension(:)  :: mass_comp,left_mass
!!$     real(PS) :: rat
!!$     integer,intent(inout) :: ierr
!!$     character*(*) from
!!$
!!$     ierr=0
!!$     if( mass_comp(ima)>1.0e-25_PS ) then
!!$        rat=mass_comp(imr)/mass_comp(ima)
!!$        left_mass(imr_m)=left_mass(imr_m)+dM*rat/(rat+1.0_PS)
!!$        left_mass(ima_m)=left_mass(ima_m)+dM/(rat+1.0_PS)
!!$        left_mass(imc_m)=left_mass(imc_m)+min(0.0_PS,left_mass(imr_m))+min(0.0_PS,left_mass(ima_m))
!!$        left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
!!$        left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))
!!$
!!$        if( left_mass(imc_m)<0.0_PS ) then
!!$           write(*,*) "everything is 0! (1)",from
!!$           write(*,*) "temp_dM",dM
!!$           write(*,*) "masscom",mass_comp
!!$           write(*,*) "rat",rat
!!$           write(*,*) "left_mass",left_mass
!!$!!c           stop
!!$           ierr=1
!!$        end if
!!$     else
!!$        left_mass(ima_m)=left_mass(ima_m)+dM
!!$        left_mass(imr_m)=left_mass(imr_m)+min(0.0_PS,left_mass(ima_m))
!!$        left_mass(imc_m)=left_mass(imc_m)+min(0.0_PS,left_mass(imr_m))
!!$        left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
!!$        left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))
!!$
!!$        if( left_mass(imc_m)<0.0_PS ) then
!!$           write(*,*) "everything is 0! (2)",from
!!$           write(*,*) "temp_dM",dM
!!$           write(*,*) "masscom",mass_comp
!!$           write(*,*) "left_mass",left_mass
!!$!!c           stop
!!$           ierr=2
!!$        end if
!!$     end if
!!$
!!$     if(left_mass(imc_m)<=0.0) then
!!$        write(*,*) "something is wrong here",from
!!$        write(*,*) "temp_dM",dM
!!$        write(*,*) "masscom",mass_comp(1:4)
!!$        write(*,*) "left_mass",left_mass
!!$!!c        stop
!!$        ierr=3
!!$     end if
!!$
!!$  end subroutine dep_mass2

  subroutine dep_mass3(dM,con,mass_comp,left_mass,ierr,from)
     ! assume that hydrometeor evaporate
     !    1. aggregation mass com,or rime mass (keeping the same ratio)
     !    2. crystal mass com.
     implicit none
     real(PS),intent(in) :: dM
!tmp     real(PS),pointer,dimension(:)  :: mass_comp,left_mass
     real(PS),dimension(:)  :: mass_comp,left_mass
     real(PS) :: rat
     real(PS) :: con
     ! fraction of crystal mass to the total aggregates
     real(PS) :: f_ice
     integer,intent(inout) :: ierr
     character*(*) from
     ! minimum mass of hexagonal ice crystal with 1 um radius
     real(PS),parameter :: m_icmin=4.763209003e-12


     ierr=0
     f_ice=mass_comp(imc)/(mass_comp(imc)+mass_comp(ima))
     rat=mass_comp(imr)/(mass_comp(imc)+mass_comp(ima)+mass_comp(imr))

     left_mass(imr_m)=left_mass(imr_m)+dM*rat
     left_mass(ima_m)=left_mass(ima_m)+dM*(1.0_PS-rat)*(1.0_PS-f_ice)
     left_mass(imc_m)=left_mass(imc_m)+dM*(1.0_PS-rat)*f_ice

     left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
     left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))

     if( left_mass(imc_m)-m_icmin*con<-1.0e-4*m_icmin*con ) then
!!c        write(*,*) "dep_mass3>ice crystal mass reached minimum",from
!!c        write(*,*) "temp_dM",dM
!!c        write(*,*) "masscom",mass_comp
!!c        write(*,*) "rat,f_ice",rat,f_ice
!!c        write(*,*) "left_mass",left_mass

        left_mass(imc_m)=m_icmin*con
        if(mass_comp(ima)+mass_comp(imr)>=1.0e-25_PS) then
           rat=max(1.0_PS,min(0.0_PS,mass_comp(imr)/(mass_comp(ima)+mass_comp(imr))))
           left_mass(imr_m)=left_mass(imr_m)+(dM+(mass_comp(imc)-left_mass(imc_m)))*rat
           left_mass(ima_m)=left_mass(ima_m)+(dM+(mass_comp(imc)-left_mass(imc_m)))*(1.0_PS-rat)

           left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
           left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))
        else
           left_mass(imr_m)=0.0_PS
           left_mass(ima_m)=0.0_PS
        endif

!!c        write(*,*) "left_mass 2",rat,left_mass
     end if

     if( left_mass(imr_m)<=1.0e-25_PS.and.left_mass(ima_m)<=1.0e-25_PS.and.&
         left_mass(imc_m)<=1.0e-25_PS.and.mass_comp(imt)>1.0e-22 ) then
        if ( debug ) then
           write(*,*) "dep_mass3,everything is 0! (1)",from
           write(*,*) "temp_dM",dM
           write(*,*) "masscom",mass_comp
           write(*,*) "rat,f_ice",rat,f_ice
           write(*,*) "left_mass",left_mass
        end if
!!c           stop
        ierr=1
     end if

  end subroutine dep_mass3

  subroutine dep_mass3_vec2(dM,con,mass_comp,left_mass,ierr)
     ! assume that hydrometeor evaporate
     !    1. aggregation mass com,or rime mass (keeping the same ratio)
     !    2. crystal mass com.
     implicit none
     real(PS),intent(in) :: dM
!tmp     real(PS),pointer,dimension(:)  :: mass_comp,left_mass
     real(PS),dimension(*)  :: mass_comp,left_mass
     real(PS) :: rat
     real(PS) :: con
     ! fraction of crystal mass to the total aggregates
     real(PS) :: f_ice
     integer,intent(inout) :: ierr
     ! minimum mass of hexagonal ice crystal with 1 um radius
     real(PS),parameter :: m_icmin=4.763209003e-12


     ierr=0
     f_ice=mass_comp(imc)/(mass_comp(imc)+mass_comp(ima))
     rat=mass_comp(imr)/(mass_comp(imc)+mass_comp(ima)+mass_comp(imr))

     left_mass(imr_m)=left_mass(imr_m)+dM*rat
     left_mass(ima_m)=left_mass(ima_m)+dM*(1.0_PS-rat)*(1.0_PS-f_ice)
     left_mass(imc_m)=left_mass(imc_m)+dM*(1.0_PS-rat)*f_ice

     left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
     left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))

     if( left_mass(imc_m)-m_icmin*con<-1.0e-4*m_icmin*con ) then
!!c        write(*,*) "dep_mass3>ice crystal mass reached minimum",from
!!c        write(*,*) "temp_dM",dM
!!c        write(*,*) "masscom",mass_comp
!!c        write(*,*) "rat,f_ice",rat,f_ice
!!c        write(*,*) "left_mass",left_mass

        left_mass(imc_m)=m_icmin*con
        if(mass_comp(ima)+mass_comp(imr)>=1.0e-25_PS) then
           rat=max(1.0_PS,min(0.0_PS,mass_comp(imr)/(mass_comp(ima)+mass_comp(imr))))
           left_mass(imr_m)=left_mass(imr_m)+(dM+(mass_comp(imc)-left_mass(imc_m)))*rat
           left_mass(ima_m)=left_mass(ima_m)+(dM+(mass_comp(imc)-left_mass(imc_m)))*(1.0_PS-rat)

           left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
           left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))
        else
           left_mass(imr_m)=0.0_PS
           left_mass(ima_m)=0.0_PS
        endif

!!c        write(*,*) "left_mass 2",rat,left_mass
     end if

     if( left_mass(imr_m)<=1.0e-25_PS.and.left_mass(ima_m)<=1.0e-25_PS.and.&
         left_mass(imc_m)<=1.0e-25_PS.and.mass_comp(imt)>1.0e-22 ) then
!org        write(*,*) "dep_mass3,everything is 0! (1)",from
!org        write(*,*) "temp_dM",dM
!org        write(*,*) "masscom",mass_comp
!org        write(*,*) "rat,f_ice",rat,f_ice
!org        write(*,*) "left_mass",left_mass
!!c           stop
        ierr=1
     end if

  end subroutine dep_mass3_vec2

!!$  subroutine dep_mass3_vec(dM,con,mass_comp,left_mass,ierr)
!!$     ! assume that hydrometeor evaporate
!!$     !    1. aggregation mass com,or rime mass (keeping the same ratio)
!!$     !    2. crystal mass com.
!!$     implicit none
!!$     real(PS),intent(in) :: dM
!!$!tmp     real(PS),pointer,dimension(:)  :: mass_comp,left_mass
!!$     real(PS),dimension(*)  :: mass_comp,left_mass
!!$     real(PS) :: rat
!!$     real(PS) :: con
!!$     ! fraction of crystal mass to the total aggregates
!!$     real(PS) :: f_ice
!!$     integer,intent(inout) :: ierr
!!$     ! minimum mass of hexagonal ice crystal with 1 um radius
!!$     real(PS),parameter :: m_icmin=4.763209003e-12
!!$     integer :: i_mar_ge1em25,i_lm_con
!!$
!!$     ierr=0
!!$     f_ice=mass_comp(imc)/(mass_comp(imc)+mass_comp(ima))
!!$     rat=mass_comp(imr)/(mass_comp(imc)+mass_comp(ima)+mass_comp(imr))
!!$
!!$     left_mass(imr_m)=left_mass(imr_m)+dM*rat
!!$     left_mass(ima_m)=left_mass(ima_m)+dM*(1.0_PS-rat)*(1.0_PS-f_ice)
!!$     left_mass(imc_m)=left_mass(imc_m)+dM*(1.0_PS-rat)*f_ice
!!$
!!$     left_mass(imr_m)=max(0.0_PS,left_mass(imr_m))
!!$     left_mass(ima_m)=max(0.0_PS,left_mass(ima_m))
!!$
!!$     i_lm_con=0.5*(1.0-sign(1.0_PS,left_mass(imc_m)-m_icmin*con-(-1.0e-4_PS*m_icmin*con )))
!!$
!!$     left_mass(imc_m)=real(i_lm_con,PS_KIND)*m_icmin*con &
!!$                    +(1.0-real(i_lm_con,PS_KIND))*left_mass(imc_m)
!!$
!!$     i_mar_ge1em25=0.5*(1.0+sign(1.0_PS,mass_comp(ima)+mass_comp(imr)-1.0e-25_PS))
!!$     rat=max(1.0_PS,min(0.0_PS,mass_comp(imr)/max(1.0e-25_PS,(mass_comp(ima)+mass_comp(imr)))))
!!$
!!$     left_mass(imr_m)=real(i_lm_con,PS_KIND)*( &
!!$             real(i_mar_ge1em25,PS_KIND)* &
!!$               max(0.0_PS,left_mass(imr_m)+(dM+(mass_comp(imc)-left_mass(imc_m)))*rat) &
!!$            +(1.0-real(i_mar_ge1em25,PS_KIND))*0.0_PS  &
!!$               ) &
!!$            +(1.0-real(i_lm_con,PS_KIND))*left_mass(imr_m)
!!$
!!$     left_mass(ima_m)=real(i_lm_con,PS_KIND)*( &
!!$             real(i_mar_ge1em25,PS_KIND)* &
!!$               max(0.0_PS,left_mass(ima_m)+(dM+(mass_comp(imc)-left_mass(imc_m)))*(1.0_PS-rat)) &
!!$            +(1.0-real(i_mar_ge1em25,PS_KIND))*0.0_PS &
!!$               ) &
!!$            +(1.0-real(i_lm_con,PS_KIND))*left_mass(ima_m)
!!$
!!$  end subroutine dep_mass3_vec

!!$  subroutine assign_tendency( g, process, n, &
!!$       nN, nM, nQ, nmtend, &
!!$       sg, sN, sM, srM)
!!$    ! assign to the tendency matrix
!!$    type (Group), intent(inout)        :: g
!!$    ! level of degeneration
!!$    !integer, intent(in)           :: level
!!$    integer,intent(in)            :: n!,kd,id,jd
!!$!tmp    real(PS), pointer, dimension(:)    :: nN
!!$!tmp    real(PS), pointer, dimension(:,:)  :: nM
!!$!tmp    real(PS), pointer, dimension(:,:)  :: nQ
!!$    real(PS),dimension(*)    :: nN
!!$    real(PS),dimension(1+mxnmasscomp,*)  :: nM
!!$    real(PS),dimension(mxnnonmc,*)  :: nQ
!!$    ! Tendency by each process for the bin, not for one particle
!!$    !
!!$    ! 1st argument for concentration variable, and
!!$    ! 2nd argument for mass and volume variables are the process number
!!$    !
!!$    !          1: vapor deposition
!!$    !             - case of aerosols, source by evaporation
!!$    !
!!$    !          2: collision between the same phases
!!$    !
!!$    !          3: collision between cloud and ice hydrometeors
!!$    !
!!$    !          4: collision between rain and ice hydrometeors
!!$    !
!!$    !          5: collision-breakup
!!$    !
!!$    !          6: hydrodynamic breakup
!!$    !
!!$    !          7: ice nucleation (sorption/deposition)
!!$    !             - case of cloud group (the 1st bin of rain),
!!$    !               this includes the production by
!!$    !               moist adiabatic process
!!$    !
!!$    !          8: ice nucleation (contact)
!!$    !             - case of cloud group (the 1st bin of rain),
!!$    !               this is a transfer by
!!$    !               contact nucleation
!!$    !
!!$    !          9: secondary nucleation
!!$    !             - case of cloud and rain group, this is a
!!$    !               transfer by accretion.
!!$    !
!!$    !         10: melting-shedding
!!$    !
!!$    !         11: ice nucleation (immersion freezing nucleation)
!!$    !
!!$    ! 1st argument for mass tendency
!!$    ! for aerosol particles
!!$    ! argument 1: total mass
!!$    !          2: mass of a soluble material of aerosols
!!$    !          3: mass of a insoluble material of aerosols
!!$    ! for liquid particles
!!$    ! argument 1: total mass
!!$    !          2: total mass of aerosols inside
!!$    !          3: mass of a soluble material of aerosols
!!$    !          4: mass of a insoluble material of aerosols
!!$    ! for solid particles
!!$    ! argument 1: total mass
!!$    !          2: total mass by riming in the bin
!!$    !          3: total mass by aggregation in the bin
!!$    !          4: mass of a mean ice crystal
!!$    !          5: total mass of aerosols inside
!!$    !          6: mass of a soluble material of aerosols
!!$    !          7: mass of a insoluble material of aerosols
!!$    !
!!$    ! 1st argument for volume tendency
!!$    !          1: V_cs
!!$    !          2: V_a
!!$    !          3: V_c
!!$    !          4: V_d
!!$    !          5: V_r
!!$    !          6: V_rime
!!$    !          7: V_agg
!!$    integer, intent(in)                :: process
!!$!tmp    real(PS), pointer, dimension(:)    :: nmtend
!!$    real(PS), dimension(*)    :: nmtend
!!$
!!$    ! spent group
!!$    type (Group), intent(inout)        :: sg
!!$    ! used concentration and mass
!!$!tmp    real(PS),  pointer, dimension(:)    :: sN, sM
!!$    real(PS),  dimension(*)    :: sN
!!$    real(PS),  dimension(*),optional    :: sM
!!$    ! mass ratio of caught rain drops
!!$!tmp    real(PS),  pointer, dimension(:,:)  :: srM
!!$    real(PS),  dimension(mxnbin,*),optional  :: srM
!!$
!!$    ! original total volume variables
!!$    real(PS),dimension(g%N_nonmass)  :: oQ
!!$    !         1. volume of circumscribing sphere (cm^3/g)
!!$    !         2. con. weighted a-axis length^3 (cm^3/g)
!!$    !         3. con. weighted c-axis length^3 (cm^3/g)
!!$    !         4. con. weighted d-axis length^3 (cm^3/g)
!!$    !         5. con. weighted r-axis length^3 (cm^3/g) (rosetta bulletes)
!!$    !         6. con. weighted e-axis length^3 (cm^3/g) (polycrystals)
!!$    !
!!$    ! sum of tendency
!!$    real(PS)  :: sum_dmdt_gain,sum_dmdt_loss,modc,sum_dmdt1,sum_dmdt2
!!$    integer  :: i, j,k,l, ibin
!!$    real(PS) :: sum_dmdtap_s
!!$
!!$    sum_dmdt_gain = 0.0_PS
!!$    sum_dmdt_loss = 0.0_PS
!!$    sum_dmdt1=0.0_PS
!!$
!!$    sum_dmdtap_s=0.0_PS
!!$
!!$!!c    if(g%token==1.and.process==1) then
!!$!!c       ibin=2
!!$!!c       g%MS(1,n)%dcondt(process) = nN(i)/g%dt
!!$!!c       g%MS(1,n)%dmassdt(1,process) = nM(j,i)/g%dt
!!$!!c    elseif(g%token==2) then
!!$    ibin=1
!!$!!c    end if
!!$
!!$    do i = ibin, g%N_BIN
!!$
!!$       g%MS(i,n)%dcondt(process) = (nN(i)-g%MS(i,n)%con)/g%dt
!!$       if( process == 1 ) then
!!$          if(nN(i)>1.0e-30_Ps) then
!!$            g%MS(i,n)%Ldmassdt(1)=nmtend(i)/nN(i)
!!$          else
!!$            g%MS(i,n)%Ldmassdt(1)=0.0
!!$          endif
!!$          if((g%MS(i,n)%Ldmassdt(1)>1.0.or.g%MS(i,n)%Ldmassdt(1)<-1.0).or.&
!!$             (g%MS(i,n)%Ldmassdt(1)>0.0.and.g%MS(i,n)%Ldmassdt(1)<=0.0)&
!!$            ) then
!!$             write(*,'("Ldmassdt1 is inf or NaN",2I4,5ES15.6)') i,n,g%MS(i,n)%Ldmassdt(1),nmtend(i),nN(i)
!!$          end if
!!$       elseif( process == 4 ) then
!!$          if(nN(i)>1.0e-30_Ps) then
!!$            g%MS(i,n)%Ldmassdt(2)=max(0.0_PS,nmtend(i)/nN(i))
!!$          else
!!$            g%MS(i,n)%Ldmassdt(2)=0.0
!!$          endif
!!$          if((g%MS(i,n)%Ldmassdt(2)>1.0.or.g%MS(i,n)%Ldmassdt(2)<-1.0).or.&
!!$             (g%MS(i,n)%Ldmassdt(2)>0.0.and.g%MS(i,n)%Ldmassdt(2)<=0.0)&
!!$            ) then
!!$             write(*,'("Ldmassdt2 is inf or NaN",2I4,5ES15.6)') i,n,g%MS(i,n)%Ldmassdt(2),nmtend(i),nN(i)
!!$          end if
!!$       end if
!!$
!!$       g%MS(i,n)%dmassdt(1,process) = (nM(1,i)-g%MS(i,n)%mass(1))/g%dt
!!$       if(g%MS(i,n)%dmassdt(1,process)>1.0e+5.or.g%MS(i,n)%dmassdt(1,process)<-1.0e+5)then
!!$          write(*,'("assign_tendency > dmdt is wrong:",4I5,10ES15.6)') i,n,1,process,&
!!$                 g%MS(i,n)%dmassdt(1,process)
!!$          write(*,*) "token",g%token
!!$          do k = 1, g%N_BIN
!!$             write(*,'(I5,10ES15.6)') k,g%MS(k,n)%con,g%MS(k,n)%mass(1),nN(k),nM(1,k)
!!$          enddo
!!$          stop
!!$       end if
!!$       do j = 2,(1+g%N_masscom)
!!$
!!$          g%MS(i,n)%dmassdt(j,process)=(nM(j,i)-g%MS(i,n)%mass(j))/g%dt
!!$          if(g%MS(i,n)%dmassdt(j,process)>1.0e+5.or.g%MS(i,n)%dmassdt(j,process)<-1.0e+5)then
!!$             write(*,*) "assign_tendency > dmdt is wrong:",i,n,j,process,g%MS(i,n)%dmassdt(j,process)
!!$             write(*,*) "token",g%token
!!$             stop
!!$          end if
!!$!!c          g%MS(i,n)%dmassdt(j,process)=&
!!$!!c               min(abs(g%MS(i,n)%dmassdt(1,process))&
!!$!!c               ,max(-abs(g%MS(i,n)%dmassdt(1,process)),g%MS(i,n)%dmassdt(j,process)))
!!$       end do
!!$!!c       if(g%token==2) then
!!$!!c          if(nM(3,i)>nM(4,i)) then
!!$!!c             write(*,*) "assign_tendency>process,grid,bin,nM",process,n,i,(nM(j,i),j=1,(1+g%N_masscom))
!!$!!c          end if
!!$!!c       end if
!!$!!c       if(g%token==2) then
!!$!!c          if(abs(g%MS(i,n)%dmassdt(1,1))>0.0_PS) then
!!$!!c             if((g%MS(i,n)%dmassdt(4,1)/g%MS(i,n)%dmassdt(1,1)<0.9999).or.&
!!$!!c                (g%MS(i,n)%dmassdt(4,1)/g%MS(i,n)%dmassdt(1,1)>1.0001)) then
!!$!!c                write(*,25) n,1,g%MS(i,n)%dmassdt(1,1),g%MS(i,n)%dmassdt(4,1)
!!$!!c25                format("ratcheck_assi>grid,process,dmassdt1,4",2I5,2ES15.6)
!!$!!c                write(*,*) "mass1:4",g%MS(i,n)%mass
!!$!!c                write(*,*) "nM", nM(1,i), nM(2,i), nM(3,i), nM(4,i)
!!$!!c                write(*,*) "con",g%MS(i,n)%con
!!$!!c                write(*,*) "nN", nN(i)
!!$!!c             end if
!!$!!c          end if
!!$!!c       end if
!!$
!!$       sum_dmdt_gain = sum_dmdt_gain + max(g%MS(i,n)%dmassdt(1,process),0.0_DS)
!!$       sum_dmdt_loss = sum_dmdt_loss + max(-g%MS(i,n)%dmassdt(1,process),0.0_DS)
!!$       sum_dmdt1=sum_dmdt1+g%MS(i,n)%dmassdt(1,process)
!!$
!!$!!c       sum_dmdtap_s=sum_dmdtap_s+g%MS(i,n)%dmassdt(5,process)
!!$    end do
!!$
!!$!    do i = 1, g%N_BIN
!!$!      write(*,'("tendency:",3I5,2(ES15.6))') i,n,process,g%MS(i,n)%dcondt(process)&
!!$!        ,g%MS(i,n)%dmassdt(1,process)
!!$!
!!$!    end do
!!$
!!$!!c    open(15,file="check_tendm.dat")
!!$!!c    do i = 1, g%N_BIN
!!$!!c       write(15,'(7(ES15.6))') g%MS(i,n)%dmassdt(1,process),g%MS(i,n)%dmassdt(2,process),g%MS(i,n)%dmassdt(3,process)
!!$!!c
!!$!!c    end do
!!$!!c    close(15)
!!$
!!$    if( g%token == 2 ) then
!!$!!c       if(process==1.and.n==38) then
!!$!!c          write(*,'("n,dmdt5",I5,ES15.6)') n,sum_dmdtap_s
!!$!!c          do i = 1, g%N_BIN
!!$!!c             write(*,'("bin,dmdt1,dmdt5",I5,2ES15.6') i,g%MS(i,n)%dmassdt(1,1),g%MS(i,n)%dmassdt(5,1)
!!$!!c          end do
!!$!!c       end if
!!$
!!$       do i = 1, g%N_BIN
!!$          oQ(1) = g%MS(i,n)%con*g%IS(i,n)%V_cs
!!$          oQ(2) = g%MS(i,n)%con*g%MS(i,n)%a_len**3.0
!!$          oQ(3) = g%MS(i,n)%con*g%MS(i,n)%c_len**3.0
!!$          oQ(4) = g%MS(i,n)%con*g%IS(i,n)%d**3.0
!!$          oQ(5) = g%MS(i,n)%con*g%IS(i,n)%ag**3.0
!!$          oQ(6) = g%MS(i,n)%con*g%IS(i,n)%cg**3.0
!!$          oQ(7) = g%MS(i,n)%con*g%IS(i,n)%n_exice
!!$
!!$          do j = 1, g%N_nonmass
!!$             g%MS(i,n)%dvoldt(j, process) = (nQ(j,i) - oQ(j))/g%dt
!!$
!!$             if(g%MS(i,n)%dvoldt(j,process)>1.0e+20.or.&
!!$                  g%MS(i,n)%dvoldt(j,process)<-1.0e+20)then
!!$                write(*,218) n,i,j,process,g%MS(i,n)%dvoldt(j,process)
!!$218             format("axis>grid,axis#,process,dvoldt",4I5,ES15.6)
!!$                write(*,219) g%IS(i,n)%V_cs,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d
!!$219             format("axis>V_cs,alen,clen,d",5ES15.6)
!!$                do k=1,g%N_BIN
!!$                   write(*,'("b#,nQ",I5,10ES15.6)') k,(nQ(l,k),l=1,7)
!!$                end do
!!$                write(*,'("oldQ",10ES15.6)') (oQ(k),k=1,7)
!!$                do k=1,g%N_BIN
!!$                   write(*,'("b#,con,mass",I5,10ES15.6)') k,g%MS(k,n)%con,g%MS(k,n)%mass
!!$                   write(*,'("b#,v,a,c,d,r,e",I5,10ES15.6)') k,g%IS(k,n)%V_cs,g%MS(k,n)%a_len,g%MS(k,n)%c_len,&
!!$                                g%IS(k,n)%d,g%IS(k,n)%e
!!$                end do
!!$                stop
!!$             end if
!!$          end do
!!$
!!$
!!$       end do
!!$    end if
!!$
!!$    if(g%token==2) then
!!$       do i=1,g%N_BIN
!!$          if(g%MS(i,n)%mass(imc)>g%MS(i,n)%mass(1)) then
!!$             write(*,*) "af2 mass1:4",g%MS(i,n)%mass(imt),g%MS(i,n)%mass(imc)
!!$             write(*,*) "af2 nM",nM(imt,i),nM(imc,i)
!!$             write(*,*) "dmassdt",g%MS(i,n)%dmassdt(imt,1),g%MS(i,n)%dmassdt(imc,1)
!!$          end if
!!$       end do
!!$    end if
!!$
!!$!!c    if(process==19) then
!!$    if(process==1) then
!!$       if(sN(1)>1.0e-30.and.sum_dmdt1>1.0e-30) then
!!$          modc=sN(1)/g%dt/sum_dmdt1
!!$!!c          write(*,'("tendency>modc",3I5,10ES15.6)') kd,id,jd,modc,sN(1),sum_dmdt1
!!$          do i = 1, g%N_BIN
!!$             g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc
!!$             do j = 1, (1+g%N_masscom)
!!$                g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc
!!$             end do
!!$             if(g%token==2) then
!!$                do j = 1, g%N_nonmass
!!$                   g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*modc
!!$                end do
!!$             end if
!!$          end do
!!$       end if
!!$    elseif(process==2) then
!!$       if(sum_dmdt_gain-sum_dmdt_loss>0.0_PS) then
!!$          modc=sum_dmdt_loss/sum_dmdt_gain
!!$!!c          write(*,*) "assign_tendency > Warning! sum_dmdt_gain is more than lost at."
!!$!!c          write(*,'("bin,grid,dmdt_g,dmdt_l,modc",2I5,3ES15.6)') i,n,sum_dmdt_gain,sum_dmdt_loss,modc
!!$!!c          write(*,*) "                > it is normalized."
!!$          do i = 1, g%N_BIN
!!$             if(g%MS(i,n)%dmassdt(1,process)>0.0_PS) then
!!$                g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc
!!$                do j = 1, (1+g%N_masscom)
!!$                   g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc
!!$                end do
!!$                if(g%token==2) then
!!$                   do j = 1, g%N_nonmass
!!$                      g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*modc
!!$                   end do
!!$                end if
!!$             end if
!!$          end do
!!$       else if(sum_dmdt_gain-sum_dmdt_loss<0.0_PS) then
!!$          modc=sum_dmdt_gain/sum_dmdt_loss
!!$!!c          write(*,*) "assign_tendency > Warning! sum_dmdt_loss is more than gain at."
!!$!!c          write(*,'("bin,grid,dmdt_g,dmdt_l,modc",2I5,3ES15.6)') i,n,sum_dmdt_gain,sum_dmdt_loss,modc
!!$!!c          write(*,*) "                > it is normalized."
!!$          do i = 1, g%N_BIN
!!$             if(g%MS(i,n)%dmassdt(1,process)<0.0_PS) then
!!$                g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc
!!$                do j = 1, (1+g%N_masscom)
!!$                   g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc
!!$                end do
!!$                if(g%token==2) then
!!$                   do j = 1, g%N_nonmass
!!$                      g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*modc
!!$                   end do
!!$                end if
!!$             end if
!!$          end do
!!$       end if
!!$    end if
!!$
!!$
!!$
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the tendency of spent object
!!$    !
!!$    ! - spent group can be only liquid hydrometeor.
!!$    !
!!$    if( sg%token /= g%token ) then
!!$       if( process == 1 ) then
!!$          ! --- In vapor deposition process, it takes excess water
!!$          !     from cloud group ---
!!$!!c          sg%MS(1,n)%dmassdt(1,process) = &
!!$!!c               max( sg%MS(1,n)%dmassdt(1,process)-sum_dmassdt, &
!!$!!c               -sg%MS(1,n)%mass(1)/sg%dt)
!!$       else
!!$          ! - rain catching cloud dropletes
!!$          ! - solid hydrometeor catching cloud droplets
!!$          ! - solid hydrometeor catching rain drops
!!$          sum_dmdt2=0.0_PS
!!$          do i = 1, sg%N_BIN
!!$             sg%MS(i,n)%dcondt(process) =  - sN(i)/sg%dt
!!$             sg%MS(i,n)%dmassdt(1,process) =  - sM(i)/sg%dt
!!$             do j=1,sg%N_masscom
!!$                sg%MS(i,n)%dmassdt(1+j,process)=sg%MS(i,n)%dmassdt(1,process)*srM(i,j)
!!$             end do
!!$             sum_dmdt2=sum_dmdt2+sg%MS(i,n)%dmassdt(1,process)
!!$          end do
!!$          if(sum_dmdt1==0.0_PS.and.sum_dmdt2==0.0_PS) return
!!$          if(sum_dmdt1<1.0e-30_PS.or.sum_dmdt2>-1.0e-30_PS) then
!!$!!c             write(*,*) "assign_tendency > Warning! sum_dmdt1 is negative."
!!$!!c             write(*,'("grid,dmdt_g,dmdt_l",I5,2ES15.6)') n,sum_dmdt1,sum_dmdt2
!!$!!c             write(*,*) "                > they will be 0 ."
!!$             do i = 1, g%N_BIN
!!$                g%MS(i,n)%dcondt(process)=0.0_PS
!!$                do j = 1, (1+g%N_masscom)
!!$                   g%MS(i,n)%dmassdt(j,process)=0.0_PS
!!$                end do
!!$                if(g%token==2) then
!!$                   do j = 1, g%N_nonmass
!!$                      g%MS(i,n)%dvoldt(j, process)=0.0_PS
!!$                   end do
!!$                end if
!!$             end do
!!$             do i = 1, sg%N_BIN
!!$                sg%MS(i,n)%dcondt(process)=0.0_PS
!!$                do j = 1, (1+sg%N_masscom)
!!$                   sg%MS(i,n)%dmassdt(j,process)=0.0_PS
!!$                end do
!!$             end do
!!$          else if(sum_dmdt1+sum_dmdt2>0.0_PS) then
!!$!!c             write(*,*) "assign_tendency > Warning! sum_dmdt1 is more than lost at."
!!$!!c             write(*,'("grid,dmdt_g,dmdt_l",I5,2ES15.6)') n,sum_dmdt1,sum_dmdt2
!!$ !!c            write(*,*) "                > it is normalized."
!!$             modc=abs(sum_dmdt2/sum_dmdt1)
!!$             do i = 1, g%N_BIN
!!$                g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc
!!$                do j = 1, (1+g%N_masscom)
!!$                   g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc
!!$                end do
!!$                if(g%token==2) then
!!$                   do j = 1, g%N_nonmass
!!$                      g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*modc
!!$                   end do
!!$                end if
!!$             end do
!!$          else if(sum_dmdt1+sum_dmdt2<0.0_PS) then
!!$!!c             write(*,*) "assign_tendency > Warning! sum_dmdt2 is more than gain at."
!!$!!c             write(*,'("grid,dmdt_g,dmdt_l",I5,2ES15.6)') n,sum_dmdt1,sum_dmdt2
!!$!!c             write(*,*) "                > it is normalized."
!!$             modc=abs(sum_dmdt1/sum_dmdt2)
!!$             do i = 1, sg%N_BIN
!!$                sg%MS(i,n)%dcondt(process)=sg%MS(i,n)%dcondt(process)*modc
!!$                do j = 1, (1+sg%N_masscom)
!!$                   sg%MS(i,n)%dmassdt(j,process)=sg%MS(i,n)%dmassdt(j,process)*modc
!!$                end do
!!$             end do
!!$          end if
!!$       end if
!!$    end if
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$  end subroutine assign_tendency

  subroutine assign_tendency_vec( g, process, &
       nN, nM, nQ, nmtend, &
       sg, sN, sM, srM)
    use scale_prc, only: &
       PRC_abort
    ! assign to the tendency matrix
    type (Group), intent(inout)        :: g
    ! level of degeneration
    !integer, intent(in)           :: level
    !integer,dimension(*),intent(in)            :: kd,id,jd
!tmp    real(PS), pointer, dimension(:)    :: nN
!tmp    real(PS), pointer, dimension(:,:)  :: nM
!tmp    real(PS), pointer, dimension(:,:)  :: nQ
    real(8),dimension(mxnbin,g%L)    :: nN
    real(8),dimension(mxnbin,g%L,1+mxnmasscomp)  :: nM
    real(8),dimension(mxnbin,g%L,mxnnonmc)  :: nQ
    ! Tendency by each process for the bin, not for one particle
    !
    ! 1st argument for concentration variable, and
    ! 2nd argument for mass and volume variables are the process number
    !
    !          1: vapor deposition
    !             - case of aerosols, source by evaporation
    !
    !          2: collision between the same phases
    !
    !          3: collision between cloud and ice hydrometeors
    !
    !          4: collision between rain and ice hydrometeors
    !
    !          5: collision-breakup
    !
    !          6: hydrodynamic breakup
    !
    !          7: ice nucleation (sorption/deposition)
    !             - case of cloud group (the 1st bin of rain),
    !               this includes the production by
    !               moist adiabatic process
    !
    !          8: ice nucleation (contact)
    !             - case of cloud group (the 1st bin of rain),
    !               this is a transfer by
    !               contact nucleation
    !
    !          9: secondary nucleation
    !             - case of cloud and rain group, this is a
    !               transfer by accretion.
    !
    !         10: melting-shedding
    !
    !         11: ice nucleation (immersion freezing nucleation)
    !
    ! 1st argument for mass tendency
    ! for aerosol particles
    ! argument 1: total mass
    !          2: mass of a soluble material of aerosols
    !          3: mass of a insoluble material of aerosols
    ! for liquid particles
    ! argument 1: total mass
    !          2: total mass of aerosols inside
    !          3: mass of a soluble material of aerosols
    !          4: mass of a insoluble material of aerosols
    ! for solid particles
    ! argument 1: total mass
    !          2: total mass by riming in the bin
    !          3: total mass by aggregation in the bin
    !          4: mass of a mean ice crystal
    !          5: total mass of aerosols inside
    !          6: mass of a soluble material of aerosols
    !          7: mass of a insoluble material of aerosols
    !
    ! 1st argument for volume tendency
    !          1: V_cs
    !          2: V_a
    !          3: V_c
    !          4: V_d
    !          5: V_r
    !          6: V_rime
    !          7: V_agg
    integer, intent(in)                :: process
!tmp    real(PS), pointer, dimension(:)    :: nmtend
    real(8), dimension(mxnbin,*)    :: nmtend

    ! spent group
    type (Group), intent(inout)        :: sg
    ! used concentration and mass
    real(8),  dimension(mxnbin,*)    :: sN
    real(8),  dimension(mxnbin,*),optional    :: sM
    ! mass ratio of caught rain drops
    real(PS),  dimension(mxnbin,1+mxnmasscomp,*),optional  :: srM
    !
    ! local variables
    !
    ! original total volume variables
    real(8),dimension(mxnbin,LMAX)  :: oQ
    !         1. volume of circumscribing sphere (cm^3/g)
    !         2. con. weighted a-axis length^3 (cm^3/g)
    !         3. con. weighted c-axis length^3 (cm^3/g)
    !         4. con. weighted d-axis length^3 (cm^3/g)
    !         5. con. weighted r-axis length^3 (cm^3/g) (rosetta bulletes)
    !         6. con. weighted e-axis length^3 (cm^3/g) (polycrystals)
    !
    ! sum of tendency
    real(PS),dimension(LMAX) :: sum_dmdt_gain,sum_dmdt_loss,sum_dmdt1,sum_dmdt2
    real(PS),dimension(LMAX) :: modc
    real(PS),dimension(mxnbin,LMAX) :: mod0
!    integer,dimension(mxnbin*LMAX) :: ierror1
    integer,dimension(LMAX) :: icond1


    real(8) :: aNd,aMd,dtd
    integer  :: i, j,k,l, n!, ibin



    dtd=g%dt

!    do in=1,g%N_BIN*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

      aNd=g%MS(i,n)%con
      aMd=g%MS(i,n)%mass(1)
      g%MS(i,n)%dcondt(process) = (nN(i,n)-aNd)/dtd
      g%MS(i,n)%dmassdt(1,process) = (nM(i,n,1)-aMd)/dtd

!dbg    if(aNd>1.0e-30.and.amd>1.0e-30) then
!dbg      write(*,*) "assign_tendency:",i,n,g%MS(i,n)%dcondt(process),&
!dbg        g%MS(i,n)%dmassdt(1,process),nN(i,n),and,nm(i,n,1),amd,dtd
!dbg    endif

!      ierror1(in)=0
      if ( debug ) then
         if(g%MS(i,n)%dmassdt(1,process)>1.0e+5.or.g%MS(i,n)%dmassdt(1,process)<-1.0e+5)then
            write(*,'("assign_tendency > dmdt is wrong:",4I5,10ES15.6)') i,n,1,process,&
                 g%MS(i,n)%dmassdt(1,process)
            write(*,*) "token",g%token
            do k = 1, g%N_BIN
               write(*,'(2I5,10ES15.6)') k,n,g%MS(k,n)%con,g%MS(k,n)%mass(1),nN(k,n),nM(k,n,1)
            enddo
         endif
      end if
    enddo
    enddo


!     do j=2,(1+g%N_masscom)
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN
       do j=2,(1+g%N_masscom)

        aMd=g%MS(i,n)%mass(j)
        g%MS(i,n)%dmassdt(j,process)=(nM(i,n,j)-aMd)/dtd

!        ierror1(in)=0
        if ( debug ) then
           if(g%MS(i,n)%dmassdt(j,process)>1.0e+5.or.g%MS(i,n)%dmassdt(j,process)<-1.0e+5)then
              write(*,*) "assign_tendency > dmdt is wrong:",i,n,j,process,g%MS(i,n)%dmassdt(j,process)
              write(*,*) "token",g%token
           endif
        end if
      enddo
    enddo
    enddo

    if( process == 1 ) then
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
        if(nN(i,n)>1.0e-30_Ps) then
          g%MS(i,n)%Ldmassdt(1)=nmtend(i,n)/nN(i,n)
        else
          g%MS(i,n)%Ldmassdt(1)=0.0
        endif
!        ierror1(in)=0
        if ( debug ) then
           if((g%MS(i,n)%Ldmassdt(1)>1.0.or.g%MS(i,n)%Ldmassdt(1)<-1.0).or.&
              (g%MS(i,n)%Ldmassdt(1)>0.0.and.g%MS(i,n)%Ldmassdt(1)<=0.0)&
              ) then
              write(*,'("Ldmassdt1 is inf or NaN",2I4,5ES15.6)') i,n,g%MS(i,n)%Ldmassdt(1),nmtend(i,n),nN(i,n)
           endif
        end if
      enddo
      enddo
    elseif( process == 4 ) then
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
        if(nN(i,n)>1.0e-30_Ps) then
          g%MS(i,n)%Ldmassdt(2)=max(0.0_DS,nmtend(i,n)/nN(i,n))
        else
          g%MS(i,n)%Ldmassdt(2)=0.0
        endif
        if ( debug ) then
           if((g%MS(i,n)%Ldmassdt(2)>1.0.or.g%MS(i,n)%Ldmassdt(2)<-1.0).or.&
              (g%MS(i,n)%Ldmassdt(2)>0.0.and.g%MS(i,n)%Ldmassdt(2)<=0.0)&
              ) then
              write(*,'("Ldmassdt2 is inf or NaN",2I4,5ES15.6)') i,n,g%MS(i,n)%Ldmassdt(2),nmtend(i,n),nN(i,n)
           endif
        end if
      enddo
      enddo
    endif

    do n=1,g%L
      sum_dmdt_gain(n) = 0.0_PS
      sum_dmdt_loss(n) = 0.0_PS
      sum_dmdt1(n)=0.0_PS
    enddo
    do i=1,g%N_BIN
      do n=1,g%L
        sum_dmdt_gain(n) = sum_dmdt_gain(n) + max(g%MS(i,n)%dmassdt(1,process),0.0_DS)
        sum_dmdt_loss(n) = sum_dmdt_loss(n) + max(-g%MS(i,n)%dmassdt(1,process),0.0_DS)
        sum_dmdt1(n)=sum_dmdt1(n)+g%MS(i,n)%dmassdt(1,process)
      enddo
    enddo

    if( g%token == 2 ) then

      nonmass_loop: do j=1,g%N_nonmass
        !      1. volume of circumscribing sphere (cm^3/g)
        !      2. con. weighted a-axis length^3 (cm^3/g)
        !      3. con. weighted c-axis length^3 (cm^3/g)
        !      4. con. weighted d-axis length^3 (cm^3/g)
        !      5. con. weighted r-axis length^3 (cm^3/g) (rosetta bulletes)
        !      6. con. weighted e-axis length^3 (cm^3/g) (polycrystals)

        if(j==ivcs) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
              oq(i,n)=g%MS(i,n)%con*g%IS(i,n)%v_cs
           enddo
           enddo
        elseif(j==iacr) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            oQ(i,n)=g%MS(i,n)%con*g%MS(i,n)%a_len*g%MS(i,n)%a_len*g%MS(i,n)%a_len
           enddo
           enddo
        elseif(j==iccr) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            oQ(i,n)=g%MS(i,n)%con*g%MS(i,n)%c_len*g%MS(i,n)%c_len*g%MS(i,n)%c_len
           enddo
           enddo
        elseif(j==idcr) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            oQ(i,n)=g%MS(i,n)%con*g%IS(i,n)%d*g%IS(i,n)%d*g%IS(i,n)%d
           enddo
           enddo
        elseif(j==iag) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            oQ(i,n)=g%MS(i,n)%con*g%IS(i,n)%ag*g%IS(i,n)%ag*g%IS(i,n)%ag
           enddo
           enddo
        elseif(j==icg) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            oQ(i,n)=g%MS(i,n)%con*g%IS(i,n)%cg*g%IS(i,n)%cg*g%IS(i,n)%cg
           enddo
           enddo
        elseif(j==inex) then
!          do in=1,g%n_bin*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            oQ(i,n)=g%MS(i,n)%con*g%IS(i,n)%n_exice
           enddo
           enddo
        endif

!        do in=1,g%n_bin*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
        do n = 1, g%L
        do i = 1, g%N_BIN
          g%MS(i,n)%dvoldt(j,process)=(nQ(i,n,j)-oQ(i,n))/dtd

!          ierror1(in)=0
          if(g%MS(i,n)%dvoldt(j,process)>1.0e+20.or.&
             g%MS(i,n)%dvoldt(j,process)<-1.0e+20)then
             LOG_ERROR("assign_tendency_vec",218) n,i,j,process,g%MS(i,n)%dvoldt(j,process)
218             format("axis>grid,axis#,process,dvoldt",4I5,ES15.6)
             LOG_ERROR_CONT(219) g%IS(i,n)%V_cs,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d
219             format("axis>V_cs,alen,clen,d",5ES15.6)
              do k=1,g%N_BIN
                 LOG_ERROR_CONT('("b#,nQ",2I5,7ES15.6)') k,n,(nQ(k,n,l),l=1,7)
              end do
              LOG_ERROR_CONT(*) "oldQ", oQ(i,n)
              do k=1,g%N_BIN
                 LOG_ERROR_CONT(*) "b#,con,mass", k,g%MS(k,n)%con,g%MS(k,n)%mass
                 LOG_ERROR_CONT('("b#,v,a,c,d,r,e",I5,5ES15.6)') k,g%IS(k,n)%V_cs,g%MS(k,n)%a_len,g%MS(k,n)%c_len,&
                                g%IS(k,n)%d,g%IS(k,n)%e
              end do
              call PRC_abort
          endif
        enddo
        enddo
      end do nonmass_loop
    endif

    ! check the ice crystal mass component
    if( debug .and. g%token==2) then
!      do in=1,g%n_bin*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
       do n = 1, g%L
       do i = 1, g%N_BIN
!        ierror1(in)=0
        if(g%MS(i,n)%mass(imc)>g%MS(i,n)%mass(1)) then
          write(*,*) "n,i",n,i
          write(*,*) "af2 mass1:4",g%MS(i,n)%mass(imt),g%MS(i,n)%mass(imc)
          write(*,*) "af2 nM",nM(i,n,imt),nM(i,n,imc)
          write(*,*) "dmassdt",g%MS(i,n)%dmassdt(imt,1),g%MS(i,n)%dmassdt(imc,1)
        endif
      enddo
      enddo
    endif

    if(process==1) then
      do n=1,g%L
        modc(n)=1.0_PS
!error        if(sN(1,n)>1.0e-30.and.sum_dmdt1(n)>1.0e-30) then
!error          modc(n)=sN(1,n)/dtd/sum_dmdt1(n)
!error        endif
!error        write(*,*) "ck modc",modc(n),sN(1,n),sum_dmdt1(n)
      enddo

!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc(n)
        if(abs(g%MS(i,n)%dcondt(process))<1.0e-30) then
          g%MS(i,n)%dcondt(process)=0.0_PS
          mod0(i,n)=0.0_PS
        else
          mod0(i,n)=1.0_PS
        endif
      enddo
      enddo
      do j = 1, (1+g%N_masscom)
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
          g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc(n)*mod0(i,n)
         enddo
         enddo
      enddo
      do j = 1, g%N_nonmass
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
          g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*modc(n)*mod0(i,n)
         enddo
         enddo
      enddo

    elseif(process==2) then
      do n=1,g%L
        modc(n)=1.0_PS
        icond1(n)=0
        if(sum_dmdt_gain(n)-sum_dmdt_loss(n)>0.0_PS) then
          modc(n)=sum_dmdt_loss(n)/sum_dmdt_gain(n)
          icond1(n)=1
        elseif(sum_dmdt_gain(n)-sum_dmdt_loss(n)<0.0_PS) then
          modc(n)=sum_dmdt_gain(n)/sum_dmdt_loss(n)
          icond1(n)=-1
        endif
      enddo
!      do in=1,g%N_BIN*g%L
!        n=(in-1)/g%N_BIN+1
!        i=in-(n-1)*g%N_BIN
      do n = 1, g%L
      do i = 1, g%N_BIN
        if(real(icond1(n),PS_KIND)*g%MS(i,n)%dmassdt(1,process)>0.0_PS) then
          g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc(n)
        endif

        if(abs(g%MS(i,n)%dcondt(process))<1.0e-30) then
          g%MS(i,n)%dcondt(process)=0.0_PS
          mod0(i,n)=0.0_PS
        else
          mod0(i,n)=1.0_PS
        endif
      enddo
      enddo
      do j = 1, (1+g%N_masscom)
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
          if(real(icond1(n),PS_KIND)*g%MS(i,n)%dmassdt(1,process)>0.0_PS) then
            g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc(n)
          endif
          g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*mod0(i,n)
         enddo
         enddo
      enddo

      do j = 1, g%N_nonmass
!        do in=1,g%N_BIN*g%L
!          n=(in-1)/g%N_BIN+1
!          i=in-(n-1)*g%N_BIN
         do n = 1, g%L
         do i = 1, g%N_BIN
          if(real(icond1(n),PS_KIND)*g%MS(i,n)%dmassdt(1,process)>0.0_PS) then
            g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*modc(n)
          endif
          g%MS(i,n)%dvoldt(j, process)=g%MS(i,n)%dvoldt(j, process)*mod0(i,n)
         enddo
         enddo
      enddo
    end if



    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate the tendency of spent object
    !
    ! - spent group can be only liquid hydrometeor.
    !
    if( sg%token /= g%token ) then
      if( process == 1 ) then
        ! --- In vapor deposition process, it takes excess water
        !     from cloud group ---
!!c          sg%MS(1,n)%dmassdt(1,process) = &
!!c               max( sg%MS(1,n)%dmassdt(1,process)-sum_dmassdt, &
!!c               -sg%MS(1,n)%mass(1)/sg%dt)
      else
        ! - rain catching cloud dropletes
        ! - solid hydrometeor catching cloud droplets
        ! - solid hydrometeor catching rain drops
!        do in=1,sg%N_BIN*sg%L
!          n=(in-1)/sg%N_BIN+1
!          i=in-(n-1)*sg%N_BIN
         do n = 1, sg%L
         do i = 1, sg%N_BIN
          sg%MS(i,n)%dcondt(process) =  - sN(i,n)/dtd
          sg%MS(i,n)%dmassdt(1,process) =  - sM(i,n)/dtd
         enddo
         enddo
        do j=1,sg%N_masscom
!          do in=1,sg%N_BIN*sg%L
!            n=(in-1)/sg%N_BIN+1
!            i=in-(n-1)*sg%N_BIN
           do n = 1, sg%L
           do i = 1, sg%N_BIN
            sg%MS(i,n)%dmassdt(1+j,process)=sg%MS(i,n)%dmassdt(1,process)*srM(i,j,n)
           enddo
           enddo
        end do
        do n=1,sg%L
          sum_dmdt2(n)=0.0_PS
        enddo
        do i=1,sg%N_BIN
          do n=1,sg%L
            sum_dmdt2(n)=sum_dmdt2(n)+sg%MS(i,n)%dmassdt(1,process)
          end do
        end do
        do n=1,g%L
          icond1(n)=0
          modc(n)=1.0_PS
          if(sum_dmdt1(n)==0.0_PS.and.sum_dmdt2(n)==0.0_PS) then

          elseif(sum_dmdt1(n)<1.0e-30_PS.or.sum_dmdt2(n)>-1.0e-30_PS) then
            icond1(n)=1
            modc(n)=0.0_PS
          elseif(sum_dmdt1(n)+sum_dmdt2(n)>0.0_PS) then
            icond1(n)=2
            !if (sum_dmdt1(n) < 1.0e-25) then ! CHIARUI
            !  write(fid_alog,*) "BBUG", sum_dmdt1(n), sum_dmdt2(n)
            !end if
            modc(n)=abs(sum_dmdt2(n)/sum_dmdt1(n))
          elseif(sum_dmdt1(n)+sum_dmdt2(n)<0.0_PS) then
            icond1(n)=3
            !if (sum_dmdt2(n) < 1.0e-25) then ! CHIARUI
            !  write(fid_alog,*) "BBUG", sum_dmdt2(n), sum_dmdt1(n)
            !end if
            modc(n)=abs(sum_dmdt1(n)/sum_dmdt2(n))
          end if
        enddo
!        if(any(icond1(1:g%L)>0)) then
!          do in=1,g%N_BIN*g%L
!            n=(in-1)/g%N_BIN+1
!            i=in-(n-1)*g%N_BIN
           do n = 1, g%L
           do i = 1, g%N_BIN
            if(icond1(n)==1.or.icond1(n)==2) then
              g%MS(i,n)%dcondt(process)=g%MS(i,n)%dcondt(process)*modc(n)
            endif
            if(abs(g%MS(i,n)%dcondt(process))<1.0e-30) then
              g%MS(i,n)%dcondt(process)=0.0_PS
              mod0(i,n)=0.0_PS
            else
              mod0(i,n)=1.0_PS
            endif
          enddo
          enddo
          do j = 1, (1+g%N_masscom)
!            do in=1,g%N_BIN*g%L
!              n=(in-1)/g%N_BIN+1
!              i=in-(n-1)*g%N_BIN
             do n = 1, g%L
             do i = 1, g%N_BIN
              if(icond1(n)==1.or.icond1(n)==2) then
                g%MS(i,n)%dmassdt(j,process)=g%MS(i,n)%dmassdt(j,process)*modc(n)*mod0(i,n)
              endif
             enddo
             enddo
          enddo

          do j = 1, g%N_nonmass
!            do in=1,g%N_BIN*g%L
!              n=(in-1)/g%N_BIN+1
!              i=in-(n-1)*g%N_BIN
             do n = 1, g%L
             do i = 1, g%N_BIN
              if(icond1(n)==1.or.icond1(n)==2) then
                g%MS(i,n)%dvoldt(j,process)=g%MS(i,n)%dvoldt(j,process)*modc(n)*mod0(i,n)
              endif
             enddo
             enddo
          enddo

!          do in=1,sg%N_BIN*sg%L
!            n=(in-1)/sg%N_BIN+1
!            i=in-(n-1)*sg%N_BIN
          do n = 1, sg%L
          do i = 1, sg%N_BIN
            if(icond1(n)==1.or.icond1(n)==3) then
              sg%MS(i,n)%dcondt(process)=sg%MS(i,n)%dcondt(process)*modc(n)
            endif
            if(abs(sg%MS(i,n)%dcondt(process))<1.0e-30) then
              sg%MS(i,n)%dcondt(process)=0.0_PS
              mod0(i,n)=0.0_PS
            else
              mod0(i,n)=1.0_PS
            endif
          enddo
          enddo
          do j = 1, (1+sg%N_masscom)
!            do in=1,sg%N_BIN*sg%L
!              n=(in-1)/sg%N_BIN+1
!              i=in-(n-1)*sg%N_BIN
             do n = 1, sg%L
             do i = 1, sg%N_BIN
              if(icond1(n)==1.or.icond1(n)==3) then
                sg%MS(i,n)%dmassdt(j,process)=sg%MS(i,n)%dmassdt(j,process)*modc(n)*mod0(i,n)
              endif
            enddo
            enddo
          enddo
!        endif
      endif
    endif
    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  end subroutine assign_tendency_vec

!!$  subroutine assign_tendency_ap(g,ga,ag,n,adN,adM)
!!$    ! Assumptions
!!$    !   - for now the mass and concentration transfer from rain group to
!!$    !     cloud group are assigned into cloud(1) and "rain(1)".
!!$    !     No information on where those came from rain group.
!!$    type (Group), intent(in)        :: g
!!$    !
!!$    !   for aerosol groups
!!$    type (Group), dimension(2)        :: ga
!!$    type (AirGroup), intent(in) :: ag
!!$    integer,intent(in)                 :: n
!!$    real(PS), intent(in)   :: adN, adM
!!$!!c    ! critical value for transfer of mass from hydromet category
!!$!!c    real(PS),parameter :: adM_crit=1.0e-30
!!$!!c    ! initial mass of cloud
!!$!!c    real(PS), parameter       :: ini_mcloud = (4.0_PS*PI/3.0_PS)*1.0e-9
!!$
!!$    ! --- case of linear distribution ---
!!$    if(g%token==2) return
!!$    ga(g%token)%MS(1,n)%dmassdt(amt,1) = adM/g%dt
!!$    ga(g%token)%MS(1,n)%dcondt(1) = adN/g%dt
!!$
!!$    if(ga(g%token)%MS(1,n)%dcondt(1)>0.5_PS) then
!!$       write(*,11) n,ga(g%token)%MS(1,n)%dcondt(1),ag%TV(n)%s_v(1),ag%TV(n)%s_v(2)
!!$       if(g%token==2) then
!!$          write(*,12) g%IS(1,n)%sh_type,g%IS(1,n)%habit,g%MS(1,n)%dcondt(1),g%MS(1,n)%dcondt(2)
!!$       end if
!!$11     format("ap1:n,dcondt2,sv1,sv2",I5,3ES15.6)
!!$12     format("ap1:shtype,habit,dcondt_vp,col",2I5,2ES15.6)
!!$    end if
!!$  end subroutine assign_tendency_ap

!!$  subroutine add_tendency_ap(level,g,ga,ag,i,n,ivp,adN,adM,from)
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! add tendencies of aerosol particles.
!!$    !
!!$    ! assume that the aerosols with fraction of soluble material >= 1.0e-6 are
!!$    ! act as CCN. The aerosols with less than the threshold is transferred into
!!$    ! ice nuclei. The fraction of activation with the threshold is around
!!$    ! 5% in case of Abdul-Razzak example.
!!$    ! This threshold seems reasonable, considering the numerical truncation, too.
!!$    !
!!$    !
!!$    ! This would tend to produce more CCN than IN after evaporation.
!!$    !
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! level of complexity
!!$    integer, intent(in)           :: level
!!$    type (Group)      :: g
!!$    !   for aerosol groups
!!$    type (Group), dimension(*)        :: ga
!!$    type (AirGroup), intent(inout) :: ag
!!$    integer,intent(in)                 :: i,n,ivp
!!$    real(PS), intent(in)   :: adN, adM
!!$    ! aerosol mass in the core of hydrometeors
!!$    real(PS)           :: ap_mass
!!$    ! minimum fraction of soluble mass for CCN
!!$    real(PS),parameter :: lmt_frac=0.99999e-5
!!$    integer :: icat,j
!!$    character (len=*) :: from
!!$
!!$    if(adN<1.0e-30_PS.or.adM<1.0e-30_PS) return
!!$    if(g%MS(i,n)%eps_map<lmt_frac) then
!!$       icat=2
!!$    else
!!$       icat=1
!!$    end if
!!$!!c    icat=g%token
!!$    g%MS(i,n)%inevp=icat
!!$
!!$    if(level<=3) then
!!$       ap_mass=4.188790205e-12*g%MS(i,n)%con
!!$    elseif(level>=4) then
!!$       if(g%token==1) then
!!$          ap_mass=g%MS(i,n)%mass(rmat)
!!$       elseif(g%token==2) then
!!$          ap_mass=g%MS(i,n)%mass(imat)
!!$       end if
!!$    end if
!!$
!!$    ga(icat)%MS(1,n)%dmassdt(amt,1)=&
!!$         ga(icat)%MS(1,n)%dmassdt(amt,1)+adM/g%dt*ap_mass/g%MS(i,n)%mass(1)
!!$    ga(icat)%MS(1,n)%dcondt(1)=ga(icat)%MS(1,n)%dcondt(1)+adN/g%dt
!!$
!!$    ga(icat)%MS(1,n)%dmassdt(ams,1)=ga(icat)%MS(1,n)%dmassdt(ams,1)&
!!$                  +g%MS(i,n)%eps_map*adM/g%dt*ap_mass/g%MS(i,n)%mass(1)
!!$    ga(icat)%MS(1,n)%dmassdt(ami,1)=ga(icat)%MS(1,n)%dmassdt(ami,1)&
!!$                  +(1.0_PS-g%MS(i,n)%eps_map)*adM/g%dt*ap_mass/g%MS(i,n)%mass(1)
!!$
!!$!!c    if(icat/=g%token) then
!!$!!c    if(ga(icat)%MS(1,n)%dcondt(1)>1.0e-04.or.ga(icat)%MS(1,n)%dcondt(1)<-1.0e-04) then
!!$!!c       if(ga(icat)%MS(1,n)%dcondt(1)>1.0e-05) then
!!$!!c       write(*,*) "From add_tendency_ap",from
!!$!!c       write(*,'("ica,gadcdt",I5,5ES15.6)') icat,ga(icat)%MS(1,n)%dcondt(1)
!!$!!c       write(*,*) "adm,adn,eps",adM,adN,g%MS(i,n)%eps_map
!!$!!c       write(*,*) "g mass",g%MS(i,n)%mass
!!$!!c       write(*,*) "g con,token,mark",g%MS(i,n)%con, g%token,g%MS(i,n)%mark
!!$!!c       write(*,*) "bin,grid",i,n
!!$!!c    end if
!!$!!c    end if
!!$    do j=1,3
!!$       if(ga(icat)%MS(1,n)%dmassdt(j,1)>1.0e+00.or.ga(icat)%MS(1,n)%dmassdt(j,1)<-1.0e+00) then
!!$          write(*,*) "From add_tendency_ap",from
!!$          write(*,'("ica,gadmdt",I5,5ES15.6)') icat,ga(icat)%MS(1,n)%dmassdt(1:3,1)
!!$          write(*,*) "adm,adn,eps",adM,adN,g%MS(i,n)%eps_map
!!$          write(*,*) "g mass",g%MS(i,n)%mass
!!$          write(*,*) "g con,token,mark",g%MS(i,n)%con, g%token,g%MS(i,n)%mark
!!$          write(*,*) "bin,grid",i,n
!!$       end if
!!$    end do
!!$
!!$    ! add to vapor
!!$    ag%TV(n)%dmassdt_v(ivp)=ag%TV(n)%dmassdt_v(ivp)+(adM/g%MS(i,n)%mass(1))*max(0.0_PS,(g%MS(i,n)%mass(1)-ap_mass))/g%dt
!!$!!c    ag%TV(n)%dmassdt_v(ivp)=ag%TV(n)%dmassdt_v(ivp)+adM/g%dt*max(0.0_PS,1.0_PS-ap_mass/g%MS(i,n)%mass(1))
!!$!!c    write(*,*) ag%TV(n)%s_v(1),ag%TV(n)%s_v(2)
!!$!!c    write(*,*) "n,ipv,dmdt",n,ivp,adM/g%dt*max(0.0_PS,1.0_PS-ap_mass/g%MS(i,n)%mass(1))
!!$  end subroutine add_tendency_ap

  subroutine add_tendency_ap_vec(ga,ag,ap_dN,ap_dM,ap_dMS,ap_dNI,ap_dMV,from)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! add tendencies of aerosol particles.
    !
    ! assume that the aerosols with fraction of soluble material >= 1.0e-6 are
    ! act as CCN or DHF. The aerosols with less than the threshold is transferred into
    ! insoluble ice nuclei category.
    ! The fraction of activation with the threshold is around
    ! 5% in case of Abdul-Razzak example.
    ! This threshold seems reasonable, considering the numerical truncation, too.
    !
    !
    ! NOTE
    !   The souble aerosols in hydrometeors will be transfered in category 1,
    !   which is assumed to be accumulation mode category.
    !   icat in the left below should be changed if you do not like it.
    !
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !   for aerosol groups
    type (Group), dimension(*),intent(inout)        :: ga
    type (AirGroup), intent(inout) :: ag
    real(8),dimension(LMAX,*),intent(in)   :: ap_dN, ap_dM, ap_dMS, ap_dNI &
                                ,ap_dMV

!    integer,dimension(LMAX*2) :: ierror
    integer :: icat,n!,jmat
    character (len=*) :: from

!    do in=1,ga(1)%L*2
!      icat=(in-1)/ga(1)%L+1
!      n=in-(icat-1)*ga(1)%L
    do icat = 1, 2
    do n = 1, ga(1)%L


      ga(icat)%MS(1,n)%dmassdt(amt,1)=ga(icat)%MS(1,n)%dmassdt(amt,1)+ &
                                ap_dM(n,icat)/ga(1)%dt
      ga(icat)%MS(1,n)%dcondt(1)=ga(icat)%MS(1,n)%dcondt(1)+&
                                ap_dN(n,icat)/ga(1)%dt
      ga(icat)%MS(1,n)%dmassdt(ams,1)=ga(icat)%MS(1,n)%dmassdt(ams,1)+ &
                                ap_dMS(n,icat)/ga(1)%dt
      ga(icat)%MS(1,n)%dmassdt(ami,1)=ga(icat)%MS(1,n)%dmassdt(ami,1)+ &
                                max(0.0d+0,ap_dM(n,icat)-ap_dMS(n,icat))/ga(1)%dt

      ag%TV(n)%dmassdt_v(icat)=ag%TV(n)%dmassdt_v(icat)+ &
                                ap_dMV(n,icat)/ga(1)%dt

 !     ierror(in)=0
      if ( debug ) then
         if(ga(icat)%MS(1,n)%dmassdt(amt,1)>1.0e+00.or.ga(icat)%MS(1,n)%dmassdt(amt,1)<-1.0e+00) then
            write(*,*) "From add_tendency_ap",from,icat,n
            write(*,*) "ica,gadmdt",icat,ga(icat)%MS(1,n)%dmassdt(1:3,1)
            write(*,*) "adm,adn",ap_dM(n,1:2),ap_dN(n,1:2)
            write(*,*) "adms,adni",ap_dMS(n,1:2),ap_dNI(n,1:2)
         endif
      end if
    enddo
    enddo

  end subroutine add_tendency_ap_vec

  subroutine contact_mode(gs,gr,ga,th_var,level,n)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! ALCULATE PHORETIC CONTACT NUCLEATION OF ICE CRYSTALS.
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! solid-hydrometeor and cloud-droplet groups
    type (Group), intent(inout)   :: gs, gr
    ! aerosol group
    type (Group), dimension(*)  :: ga
    type (Thermo_Var), intent(in) :: th_var
    ! level of complexity
    integer, intent(in)           :: level
    integer,intent(in)            :: n
    ! tendency of
    ! (1) mass (g/cm^3)
    ! (2) concentration (#/cm^3)
    ! (3) volume (cm^3/cm^3)
    real(PS), dimension(3)        :: tend

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
!tmp    real(PS), pointer, dimension(:)                     :: Qp
    real(PS), dimension(mxnnonmc+2)                     :: Qp

    ! the nucleated ice mass
    real(PS) :: PMAS
    ! circumscribing sphere volume a-axis and c-axis volume of ice particle
    ! when it is nucleated.
    !real(PS) :: NVCS,NVA,NVC,NVAG,NVCG,n_exice_p
    integer :: IBI
    !real(PS) :: min_dt
    !---------------------------------------------------------------------
    !     Contact nucleation of ice crystals
    !          PHVI.........Phoretic ice crystal mixing ratio and
    !                       concentration tendency
    !          PBVI.........Brownian ice crystal concentration tendency
    !          PTVI.........Thermo-phoretic ice crystal concentration tenden
    !          PDVI.........Diddusio-phoretic ice crystal concentration tend
    !---------------------------------------------------------------------
    real (PS)     :: PBVI, PTVI, PDVI
    real (PS)     :: F1, F2, FT
    real (PS)     :: ANA,AKN,AKA,DFAR
    ! mass of vapor and mass of saturated vapor over ice
!!c    real(PS), intent(in)             :: mass_v, mass_vis
    ! maximum possible nucleation by contact freezing
    !real (PS)  :: max_con
    real(PS), parameter           :: a = -2.80_PS
    real(PS), parameter           :: b = 0.262_PS

    ! limit for the nucleation
    real(PS),parameter :: anuc_lmt=1.0_PS

    !real(PS) :: phi
    !
    ! type of process
    integer,parameter :: pro_type=8

    integer              :: i,j

    !
    !       The existence of supercooled cloud water is rare so this
    !       whole routine will
    !       be conditional, i.e. only if cloud water exists.
    !

!tmp    call allocate_contact

!!c    if( gc%MS(1,n)%mass(1)/th_var%den > 1.0e-6_PS .and. &
    do i=1,gr%N_BIN
       if( gr%MS(i,n)%mass(rmt) > 1.0e-30_PS .and. &
            gr%MS(i,n)%tmp < 271.16_PS .and. th_var%T_n <= 273.16_PS ) then

          ! ------------------------------------------------------------------------------------
          PMAS=ga(2)%MS(1,n)%mean_mass+gr%MS(i,n)%mean_mass
          if(PMAS<gs%binb(1)) then
             ! assume that the mass reaches to gs%binb(1) quickly over the time step.
             PMAS=gs%binb(1)*1.1_PS
          end if

          Qp=0.0_PS
          call assign_Qp_v3p(level,pmas,gr%MS(i,n)%a_len,gr%MS(i,n)%c_len,th_var%T,th_var%nuc_gmode,Qp)


          ! find the ice bin that contain the PMAS.
          do j=1,gs%N_BIN
             if(gs%binb(j)<=PMAS.and.PMAS<gs%binb(j+1)) then
                IBI=j
                exit
             end if
          end do

          ! ------------------------------------------------------------------------------------
          !
          !         First compute aersol concentration:
          !
          call AERSTUFF(gr, th_var, ANA, AKN, AKA, DFAR)
          !
          !         F1,F2 and FT are partial calculations used more than once an
          !         are defined in Cotton et. al., 1987.
          !
          ! F1 (1/cm^5)
          F1 = 4.0*PI*(gr%MS(i,n)%len/2.0_PS)*gr%MS(i,n)%con*ANA
          ! F2 (cm^2/sec)
          F2 = th_var%k_a*( th_var%T_n- gr%MS(i,n)%tmp )/th_var%P
          ! FT
          FT = 0.4_PS*(1.0_PS+1.45_PS*AKN+0.4_PS*AKN*EXP(-1.0_PS/AKN))&
               *(th_var%k_a+2.5_PS*AKA*AKN)&
               /((1.0_PS+3.0_PS*AKN)*(AKA+2.0_PS*th_var%k_a+5.0_PS*AKA*AKN))
          !
          !         Now get brownian (PBVI), thermal (PTVI) and diffusio-phoreti
          !         crystal concentration tendency:
          !
          PBVI = F1 * DFAR
          PTVI = F1 * F2 * FT
          PDVI = - F1 * F2 * R_v * th_var%T_n/L_e
          !
          !         Now get crystal mixing ratio tendency by multiplying
          !         bounded tendency by assumed mass of each pristine crystal
          !         and normalizing by air density.  Note that we assumed a
          !         rapid growth to the PMAS size after nucleation.
          !
          !
          tend(2) = max( PBVI+PTVI+PDVI,0.0_PS)
          !
          !         These nucleation tendencies can easily become too
          !         large over a time-step interval.  So we find it best to
          !         limit the nucleation to a fraction of the amount of vapor
          !         available over the time interval.  We arbitrarily take the limit (anuc_lmt)
          !         for that purpose.
          !

!!c          tend(2) = min( tend(2), &
!!c               anuc_lmt* max(0.0_PS, &
!!c               (mass_v-mass_vis)/(gr%dt*PMAS)))
          tend(2)=min( tend(2), gr%MS(i,n)%con/gr%dt)
          tend(1)=tend(2)*PMAS


          if(tend(2)==0.0_PS) cycle

          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! rain droplets lose mass and concentration
          gr%MS(i,n)%dmassdt(rmt,pro_type) = - tend(2)*gr%MS(i,n)%mean_mass
          gr%MS(i,n)%dcondt(pro_type) = - tend(2)

          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          ! solid hydrometeor gains mass and concentration
          gs%MS(IBI,n)%dmassdt(imt,pro_type) = gs%MS(IBI,n)%dmassdt(imt,pro_type)+tend(1)
          gs%MS(IBI,n)%dmassdt(imc,pro_type) = gs%MS(IBI,n)%dmassdt(imc,pro_type)+tend(1)
          gs%MS(IBI,n)%dmassdt(imf,pro_type) = gs%MS(IBI,n)%dmassdt(imf,pro_type)+tend(1)

          gs%MS(IBI,n)%dcondt(pro_type) = gs%MS(IBI,n)%dcondt(pro_type)+tend(2)

          gs%MS(IBI,n)%dvoldt(ivcs,pro_type)=gs%MS(IBI,n)%dvoldt(ivcs,pro_type)+tend(2)*Qp(ivcs)
          gs%MS(IBI,n)%dvoldt(iacr,pro_type)=gs%MS(IBI,n)%dvoldt(iacr,pro_type)+tend(2)*Qp(iacr)**3.0
          gs%MS(IBI,n)%dvoldt(iccr,pro_type)=gs%MS(IBI,n)%dvoldt(iccr,pro_type)+tend(2)*Qp(iccr)**3.0
          gs%MS(IBI,n)%dvoldt(iag,pro_type)=gs%MS(IBI,n)%dvoldt(iag,pro_type)+tend(2)*Qp(iag)**3.0
          gs%MS(IBI,n)%dvoldt(icg,pro_type)=gs%MS(IBI,n)%dvoldt(icg,pro_type)+tend(2)*Qp(icg)**3.0
          gs%MS(IBI,n)%dvoldt(inex,pro_type)=gs%MS(IBI,n)%dvoldt(inex,pro_type)+tend(2)*Qp(inex)

          ! aerosol tendency
          ga(2)%MS(1,n)%dcondt(pro_type)=ga(2)%MS(1,n)%dcondt(pro_type)-tend(2)
          ga(2)%MS(1,n)%dmassdt(amt,pro_type)=&
               ga(2)%MS(1,n)%dmassdt(amt,pro_type)-tend(2)*ga(2)%MS(1,n)%mean_mass

          if(level>=4) then
             ga(2)%MS(1,n)%dmassdt(ams,pro_type)=&
                  ga(2)%MS(1,n)%dmassdt(ams,pro_type)-tend(2)*ga(2)%MS(1,n)%mean_mass*ga(2)%MS(1,n)%eps_map
             ga(2)%MS(1,n)%dmassdt(ami,pro_type)=&
                  ga(2)%MS(1,n)%dmassdt(amt,pro_type)-ga(2)%MS(1,n)%dmassdt(ams,pro_type)

             gr%MS(i,n)%dmassdt(rmat,pro_type)=gr%MS(i,n)%dmassdt(rmt,pro_type)*&
                  gr%MS(i,n)%mass(rmat)/gr%MS(i,n)%mass(rmt)
             gr%MS(i,n)%dmassdt(rmas,pro_type)=gr%MS(i,n)%dmassdt(rmat,pro_type)*&
                  gr%MS(i,n)%eps_map
             gr%MS(i,n)%dmassdt(rmai,pro_type)=gr%MS(i,n)%dmassdt(rmat,pro_type)-&
                  gr%MS(i,n)%dmassdt(rmas,pro_type)


             gs%MS(IBI,n)%dmassdt(imat,pro_type)=gs%MS(IBI,n)%dmassdt(imat,pro_type)&
                  +tend(2)*ga(2)%MS(1,n)%mean_mass&
                  -gr%MS(i,n)%dmassdt(rmat,pro_type)


             gs%MS(IBI,n)%dmassdt(imas,pro_type)=gs%MS(IBI,n)%dmassdt(imas,pro_type)&
                  +tend(2)*ga(2)%MS(1,n)%mean_mass*ga(2)%MS(1,n)%eps_map&
                  -gr%MS(i,n)%dmassdt(rmas,pro_type)

             gs%MS(IBI,n)%dmassdt(imai,pro_type)=&
                  gs%MS(IBI,n)%dmassdt(imat,pro_type)-gs%MS(IBI,n)%dmassdt(imas,pro_type)&
                  -gr%MS(i,n)%dmassdt(rmai,pro_type)

          end if
          ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       end if
    end do

!tmp    call deallocate_contact

  CONTAINS
    subroutine AERSTUFF(gr, th_var, ANA, AKN, AKA, DFAR)
      type (Group), intent(in)      :: gr
      type (Thermo_Var), intent(in) :: th_var
      !
      real (PS), intent(inout)   :: ANA, AKN, AKA, DFAR
      ! assumed aerosol radius
!!c      real (PS), parameter   :: RAROS=3.0e-5_PS
      real (PS) :: RAROS
      real (PS), parameter   :: AKA0=5.39e-4_PS

      AKA=AKA0
      RAROS=ga(2)%MS(1,n)%a_len
      !         calculate the maximum tendency based on Meyers et al (1992)
!!c      ANA=exp(a+b*(273.15-gc%MS(1,n)%tmp))*1.0e-3_PS
!      ANA=200.0e-3_PS*(270.16_PS-gc%MS(1,n)%tmp)**1.3
      ANA=ga(2)%MS(1,n)%con
      AKN=7.37_PS*th_var%T_n/(288.0_PS*th_var%P*RAROS)
      DFAR=7.32e-18_PS*gr%MS(i,n)%tmp/(RAROS*th_var%d_vis)*(1.0_PS+AKN)
    end subroutine AERSTUFF
!tmp    subroutine allocate_contact
!tmp      integer :: item(1)
!tmp      item=0
!tmp      allocate( Qp(gs%N_nonmass+2), stat = item(1))
!tmp      if(any(item/=0) ) Stop 'Allocatation failed at contact'
!tmp    end subroutine allocate_contact
!tmp    subroutine deallocate_contact
!tmp      integer :: item(1)
!tmp      item=0
!tmp      deallocate( Qp, stat = item(1))
!tmp      nullify(Qp)
!tmp      if(any(item/=0)) Stop 'Deallocatation failed at contact'
!tmp    end subroutine deallocate_contact
  end subroutine contact_mode

  subroutine secondary_nucleation( gs, gr, th_var, level,n, ID,JD,KD)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !     SPLINTERING OF ICE CRYSTALS
    !     based on Hallett-Mossop splinter mechanism (1974)
    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !
    ! solid hydrometeor group
    type (Group), intent(inout)   :: gs
    ! cloud droplets group
    type (Group), intent(inout)   :: gr
    type (Thermo_Var), intent(in) :: th_var
    ! level of complexity
    integer, intent(in)           :: level
    integer,intent(in)            :: n
    integer :: ID(*),JD(*),KD(*)
    !
    ! tendency of
    ! (1) mass (g/cm^3)
    ! (2) concentration (#/cm^3)
    ! (3) volume (cm^3/cm^3)
    ! (4) mass of mixed aerosol
    ! (5) mass of soluble aerosol
    real(PS), dimension(5)        :: tend
    ! +++ set up the nucleated ice mass and size +++
    ! a hexagonal ice mass is nucleated with a=2.5 um, c=2.5 um.
    ! axis ratio c/a of 1 is assumed.
    ! mass of splinter ice particle when it is nucleated.
    real(PS), parameter         :: SPLMAS=7.44251406694799e-11
    ! circumscribing volume, and a-axis and c-axis volume of ice particle
    ! when it is nucleated.
    real(PS), parameter             :: NVCS=8.11898816047911e-11
    real(PS), parameter             :: NVA=1.5625e-11
    real(PS), parameter             :: NVC=1.5625e-11
    ! +++++++++++++++++++++++++++++++++++++++++++++++
    ! mass of vapor and saturated vapor over ice
!!c    real(PS), intent(in)          :: mass_v, mass_vis
    real(PS)                      :: F1TI
    ! previous tendency and modification ratio
    !real(PS)                      :: pre_tend, mod_ratio
    real(PS), parameter           :: beta5 = 3.5e+5

    ! limit for the nucleation
    real(PS),parameter :: anuc_lmt=1.0_PS

    ! type of process
    integer                                    :: pro_type
    integer             :: i,IBI
    pro_type = 9
    !
    !
    if( gr%mark_cm(n) /= 3 ) then
!!c    if( gc%MS(1,n)%mass(1) > 1.0e-30_PS ) then
!!c    if( gc%MS(1,n)%mass(1)/th_var%den > 1.0e-6_PS ) then
       !
       !         Compute mass of cloud droplet
       !
       tend = 0.0_PS
       do i = 1, gs%N_BIN
!!c         if( gs%MS(i,n)%dmassdt(imt,4)/th_var%den > 1.0e-10_PS .and. &
         if( gs%MS(i,n)%Ldmassdt(2)*gs%MS(i,n)%con/th_var%den > 1.0e-20_PS .and. &
              gs%IS(i,n)%sh_type >= 5  ) then
             ! only for graupel and hail with fast riming rate.
             !
             !         Get efficiencies
             !
             if( gs%MS(i,n)%tmp > 270.16_PS .or. gs%MS(i,n)%tmp < 265.16_PS) then
                F1TI = 0.0_PS
             else if( gs%MS(i,n)%tmp >= 268.16_PS ) then
                F1TI = (270.16_PS-gs%MS(i,n)%tmp)/2.0_PS
             else
                F1TI = (gs%MS(i,n)%tmp-265.16_PS)/3.0_PS
             end if
             !
             !         Accumulate result in splitering tendency
             ! assume that ice crystals are not affected by splitting.
             !
             gs%MS(i,n)%dmassdt(imt,pro_type)=- BETA5*F1TI*max(0.0_PS,gs%MS(i,n)%Ldmassdt(2))*gs%MS(i,n)%con*SPLMAS

             tend(1) = tend(1) - gs%MS(i,n)%dmassdt(imt,pro_type)

             gs%MS(i,n)%dmassdt(imr,pro_type)=(gs%MS(i,n)%mass(imr)/gs%MS(i,n)%mass(imt))&
                  *gs%MS(i,n)%dmassdt(imt,pro_type)
             gs%MS(i,n)%dmassdt(ima,pro_type)=(gs%MS(i,n)%mass(ima)/gs%MS(i,n)%mass(imt))&
                  *gs%MS(i,n)%dmassdt(imt,pro_type)

             gs%MS(i,n)%dvoldt(ivcs,pro_type)=gs%MS(i,n)%dmassdt(imt,pro_type)/&
                  gs%MS(i,n)%den

             if(level>=4) then
                ! aerosols
                gs%MS(i,n)%dmassdt(imat,pro_type)=&
                     gs%MS(i,n)%dmassdt(imt,pro_type)*gs%MS(i,n)%mass(imat)/gs%MS(i,n)%mass(imt)
                gs%MS(i,n)%dmassdt(imas,pro_type)=&
                     gs%MS(i,n)%dmassdt(imt,pro_type)*gs%MS(i,n)%mass(imas)/gs%MS(i,n)%mass(imt)
                gs%MS(i,n)%dmassdt(imai,pro_type)=&
                     gs%MS(i,n)%dmassdt(imt,pro_type)*gs%MS(i,n)%mass(imai)/gs%MS(i,n)%mass(imt)
                tend(4)=tend(4)-gs%MS(i,n)%dmassdt(imat,pro_type)
                tend(5)=tend(5)-gs%MS(i,n)%dmassdt(imas,pro_type)
             end if
             if ( debug ) then
                if((gs%MS(i,n)%dmassdt(imat,pro_type)>1.0e+03.or.gs%MS(i,n)%dmassdt(imat,pro_type)<-1.0e+03).or.&
                   (gs%MS(i,n)%dmassdt(imat,pro_type)>0.0.and.gs%MS(i,n)%dmassdt(imat,pro_type)<=0.0) ) then

                   write(*,'("secondary nucleation>",5I4,20ES15.6)') KD(n),ID(n),JD(n),i,&
                        pro_type,tend(4),gs%MS(i,n)%dmassdt(imat,pro_type),&
                        gs%MS(i,n)%mass(imat),gs%MS(i,n)%mass(imt),gs%MS(i,n)%dmassdt(imt,pro_type),&
                        BETA5,F1TI,gs%MS(i,n)%Ldmassdt(2),gs%MS(i,n)%con,SPLMAS
                endif
             end if

             if(level>=6) then
                ! melt water
                gs%MS(i,n)%dmassdt(imw,pro_type)=(gs%MS(i,n)%mass(imw)/gs%MS(i,n)%mass(imt))&
                     *gs%MS(i,n)%dmassdt(imt,pro_type)
             end if
          end if
       end do
       !         These nucleation tendencies can easily become too
       !         large over a time-step interval.  So we find it best to
       !         limit the nucleation to a fraction of the amount of vapor
       !         available over the time interval.  We arbitrarily take limit (anuc_lmt)
       !         for that purpose.
       !
!!c       pre_tend = tend(1)
!!c       tend(1) = min( pre_tend, &
!!c            anuc_lmt* max(0.0_PS, &
!!c            (mass_v-mass_vis)/(gr%dt)))
       tend(2) = tend(1)/SPLMAS

!!c       if( pre_tend > 0.0_PS ) then
!!c          mod_ratio = tend(1)/pre_tend
!!c          do i = 1, gs%N_BIN
!!c             gs%MS(i,n)%dmassdt(imt,pro_type) = gs%MS(i,n)%dmassdt(imt,pro_type)*mod_ratio
!!c             gs%MS(i,n)%dmassdt(imr,pro_type) = gs%MS(i,n)%dmassdt(imr,pro_type)*mod_ratio
!!c             gs%MS(i,n)%dmassdt(ima,pro_type) = gs%MS(i,n)%dmassdt(ima,pro_type)*mod_ratio
!!c             gs%MS(i,n)%dvoldt(ivcs,pro_type) = gs%MS(i,n)%dvoldt(ivcs,pro_type)*mod_ratio
!!c
!!c             if(level>=4) then
!!c                gs%MS(i,n)%dmassdt(imat,pro_type) = gs%MS(i,n)%dmassdt(imat,pro_type)*mod_ratio
!!c                gs%MS(i,n)%dmassdt(imas,pro_type) = gs%MS(i,n)%dmassdt(imas,pro_type)*mod_ratio
!!c                gs%MS(i,n)%dmassdt(imai,pro_type) = gs%MS(i,n)%dmassdt(imai,pro_type)*mod_ratio
!!c             end if
!!c             if(level>=6) then
!!c                gs%MS(i,n)%dmassdt(imw,pro_type) = gs%MS(i,n)%dmassdt(imw,pro_type)*mod_ratio
!!c             end if
!!c          end do
!!c       end if

       tend(3) = tend(2)*NVCS

       ! find the ice bin that contain the PMAS.
       do i=1,gs%N_BIN
          if(gs%binb(i)<=SPLMAS.and.SPLMAS<gs%binb(i+1)) then
             IBI=i
             exit
          end if
       end do

       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ! put all the nucleated ices into the smallest bin.
       gs%MS(IBI,n)%dmassdt(imt,pro_type) = gs%MS(IBI,n)%dmassdt(imt,pro_type) + tend(1)
       gs%MS(IBI,n)%dmassdt(imc,pro_type) = gs%MS(IBI,n)%dmassdt(imt,pro_type)

       gs%MS(IBI,n)%dcondt(pro_type) = gs%MS(IBI,n)%dcondt(pro_type)+ tend(2)

       gs%MS(IBI,n)%dvoldt(ivcs,pro_type) = gs%MS(IBI,n)%dvoldt(ivcs,pro_type) + tend(3)
       gs%MS(IBI,n)%dvoldt(iacr,pro_type) = gs%MS(IBI,n)%dvoldt(iacr,pro_type) + &
            NVA*tend(2)
       gs%MS(IBI,n)%dvoldt(iccr,pro_type) = gs%MS(IBI,n)%dvoldt(iccr,pro_type) + &
            NVC*tend(2)

       if(level>=4) then
          gs%MS(IBI,n)%dmassdt(imat,pro_type) = gs%MS(IBI,n)%dmassdt(imat,pro_type) + tend(4)
          gs%MS(IBI,n)%dmassdt(imas,pro_type) = gs%MS(IBI,n)%dmassdt(imas,pro_type) + tend(5)
          gs%MS(IBI,n)%dmassdt(imai,pro_type) = gs%MS(IBI,n)%dmassdt(imai,pro_type) + &
               max(0.0_PS,tend(4)-tend(5))
       end if
       ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    end if
  end subroutine secondary_nucleation

!!$  subroutine cal_freez_dep2(T_f,mrat,p,iufz,APSNAME,nu_aps,m_aps)
!!$!!c    use com_amps
!!$    ! mrat: the ratio of soluble mass to water mass
!!$    real(PS),intent(in) :: mrat,p
!!$    !real(PS),intent(in) :: rad,con,m1,m2,m3,m4
!!$
!!$    integer,intent(inout) :: iufz
!!$    character (len=16) :: APSNAME(*)
!!$    ! aerosol variables
!!$    real(PS),dimension(*) :: nu_aps,m_aps
!!$    real(PS) :: T_f!,T_f_2
!!$
!!$
!!$    INTEGER,parameter :: JMAX=20
!!$    real(PS) :: rtnewt,x1,x2
!!$!!c    real(PS),parameter :: xacc=1.0e-8
!!$!!c    real(PS),parameter :: xacc=1.0e-3
!!$    real(PS),parameter :: xacc=1.0e-2
!!$    INTEGER :: j
!!$    real(PS) :: df,dx,f
!!$    real(PS) :: molality,aw0,pres
!!$    real(PS), parameter             :: M_w=18.0153
!!$
!!$
!!$    ! pressure in G Pa from g/s^2/cm (0.1Pa)
!!$    pres=p*1.0e-10
!!$
!!$    iufz=0
!!$
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! NOTE: category 1 is used for molality and activity cacluation.
!!$    !       Sometime, it has to be modified to use multiple ions in the
!!$    !       supercooled droplets.
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    molality=1.0e+3/M_aps(1)*mrat
!!$!!c    molality=1.0e+3*sm_s/M_s/sm_w
!!$    if(trim(APSNAME(1))=='NH42SO4') then
!!$       ! ammonium sulfate
!!$       aw0=exp(-nu_aps(1)*molality*M_w*1.0e-3*osm_ammsul(molality))
!!$
!!$!!c    aw0=exp(-nu*molality*M_w*1.0e-3*osm_amsol(molality))
!!$!!c    aw0=exp(-nu*molality*M_w*1.0e-3*osm_amsol2(molality))
!!$!!c    aw0=act_amsol3(molality)
!!$!!c    aw0=act_amsol2(mrat)
!!$    elseif(trim(APSNAME(1))=='NH4HSO4') then
!!$       ! ammonium bisulfate
!!$       aw0=exp(-nu_aps(1)*molality*M_w*1.0e-3*osm_ammsul(molality))
!!$
!!$    elseif(trim(APSNAME(1))=='NACL2') then
!!$       ! sodium chloride
!!$       aw0=exp(-nu_aps(1)*molality*M_w*1.0e-3*osm_sodchl(molality))
!!$    else
!!$       write(*,*) "cal_freez_dep2>osm is not defined for",APSNAME(1)
!!$       stop
!!$    end if
!!$!!c    write(*,'("APSNAME,aw0,molality,mrat: ",A10,A10,3ES15.6)') APSNAME(1),APSNAME(2),aw0,molality,mrat
!!$
!!$    x1=273.16
!!$    x2=173.16
!!$
!!$
!!$2222 continue
!!$
!!$    rtnewt=0.5*(x1+x2)
!!$!!c  rtnewt=x1
!!$    do j=1,JMAX
!!$       call funcd(rtnewt,f,df)
!!$       dx=f/df
!!$       rtnewt=rtnewt-dx
!!$       if((x1-rtnewt)*(rtnewt-x2).lt.0.0) then
!!$!!c          write(*,*) "rtnewt jumped out of branckets"
!!$!!c          write(*,'("j,f,df,dx,rtnewt,x1,x2",I5,10ES15.6)') j,f,df,dx,rtnewt,x1,x2
!!$!!c          write(*,'("aw0,molality,mrat,rad,con,m1,m2,m3,m4",10ES15.6)') aw0,molality,&
!!$!!c                           mrat,rad,con,m1,m2,m3,m4
!!$!!c          write(*,*) "assumed it wont freeze"
!!$          iufz=1
!!$          return
!!$
!!$!!c          if(rtnewt<x2) then
!!$!!c             x2=x2-50.0
!!$!!c          elseif(rtnewt>x1) then
!!$!!c             write(*,*) "rtnewt>x1:something is wrong"
!!$!!c             stop
!!$!!c          end if
!!$!!c          goto 2222
!!$!!c          stop
!!$       endif
!!$!!c       write(*,'("j,f,df,dx,rtnewt",I5,4ES15.6)') j,f,df,dx,rtnewt
!!$       if(abs(dx).lt.xacc) goto 1111
!!$
!!$    end do
!!$    write(*,'("cal_freez_dep2>iteration failed: ",I5,10ES15.6)') j,aw0,molality,mrat,rtnewt,pres,f,df,dx
!!$
!!$1111 continue
!!$
!!$    T_f=rtnewt
!!$
!!$!!c    write(*,*) "iteration for mrat",mrat,j-1
!!$
!!$    return
!!$
!!$  contains
!!$    subroutine funcd(x,f,df)
!!$      real(PS) :: x,f,df
!!$      real(PS) :: delta_aw,awi0,vw0,vi,c1
!!$      ! in J K-1 mol -1
!!$      real(PS), parameter             :: R_u = 8.314472
!!$
!!$      ! G Pa^-1
!!$      real(PS),parameter :: k0t=1.6, dk0tdp=-8.8, kit=0.22, dkitdp=-0.17
!!$
!!$      real(PS) :: dadt
!!$
!!$      real(PS), parameter  :: b1=210368.0,b2=131.438,b3=3.32373e+6,b4=41729.1
!!$
!!$      ! nucleation rate (cm^-3 s^-1)
!!$!!c    real(PS), parameter             :: AJ=3.0e+8
!!$      real(PS), parameter             :: AJ=1.0
!!$
!!$
!!$!!c      write(*,*) "aw0: ",aw0
!!$
!!$      awi0=exp((b1+b2*x-b3/x-b4*log(x))/R_u/x)
!!$
!!$      vw0=-230.76-0.1478*x+4099.2/x+48.8341*log(x)
!!$      vi=19.43-2.2e-3*x+1.08e-5*x**2.0
!!$      c1=vw0*(pres-0.5*k0t*pres**2.0-1.0/6.0*dk0tdp*pres**3.0)-vi*(pres-0.5*kit*pres**2.0-1.0/6.0*dkitdp*pres**3.0)
!!$
!!$      delta_aw=aw0*exp(c1/(R_u*1.0e-3)/x)-awi0
!!$
!!$      f=-906.7+8502.0*delta_aw-26924.0*delta_aw**2.0+29180.0*delta_aw**3.0-log10(AJ)
!!$
!!$
!!$      dadt=aw0*exp(c1/(R_u*1.0e-3)/x)*(-c1/(R_u*1.0e-3)/x**2.0)-&
!!$           awi0*(-b1+2.0*b3/x-b4+b4*log(x))/R_u/x**2.0
!!$      df=8502.0*dadt-26924.0*2.0*delta_aw*dadt+29180.0*3.0*delta_aw**2.0*dadt
!!$
!!$    end subroutine funcd
!!$
!!$  end subroutine cal_freez_dep2

  subroutine cal_freez_dep2_vec(T_f,nbin,L,ag,mrat,iufz,APSNAME,nu_aps,m_aps &
                               ,icond4,osm_nhs4,osm_sdch)
    use scale_prc, only: &
       PRC_abort
    use class_Mass_Bin, only: &
       data1d_lut
    type (AirGroup),intent(in)  :: ag
!!c    use com_amps
    integer,intent(in) :: nbin,L
    ! mrat: the ratio of soluble mass to water mass
    real(PS),dimension(nbin,L),intent(in) :: mrat
    real(PS),dimension(nbin,L),intent(inout) :: T_f

    integer,dimension(nbin,L),intent(inout) :: iufz
    character (len=16) :: APSNAME(4)
    type(data1d_lut),intent(in) :: osm_nhs4,osm_sdch
    integer,dimension(LMAX,*) :: icond4

    ! aerosol variables
    real(PS),dimension(*) :: nu_aps,m_aps

    !real(PS) :: p

    INTEGER,parameter :: JMAX=20
!!c    real(PS),parameter :: xacc=1.0e-8
!!c    real(PS),parameter :: xacc=1.0e-3
    real(PS),parameter :: xacc=1.0e-2
    real(PS) :: x1,x2
    real(PS) :: wx
    integer :: i1,iaps
    INTEGER :: i,n,j
    real(PS) :: df,dx,f
    integer,dimension(nbin,LMAX) :: icond1
    real(PS),dimension(nbin,LMAX) :: aw0,pres,rtnewt
    real(PS) :: osm,molality
    real(PS), parameter             :: M_w=18.0153

!!c    write(*,*) 'in freez_dep2:',osm_nhs4%n,osm_nhs4%dx,osm_nhs4%xs,&
!!c            M_aps(1)

    ! the following assignment is necessary for vectorization
    select case(trim(APSNAME(1)))
    case('NH42SO4','NH4HSO4')
      ! ammonium sulfate or ammonium bisulfate
      iaps=1
    case default
      ! sodium chloride
      iaps=2
    end select

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin

      ! pressure in G Pa from g/s^2/cm (0.1Pa)
      pres(i,n)=ag%TV(n)%P*1.0e-10

      iufz(i,n)=0

      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! NOTE: category 1 is used for molality and activity cacluation.
      !       Sometime, it has to be modified to use multiple ions in the
      !       supercooled droplets.
      ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      molality=1.0e+3/M_aps(1)*mrat(i,n)
!!c      write(*,*) "ck mol",i,n,molality,M_aps(1),mrat(i,n)
!!c    molality=1.0e+3*sm_s/M_s/sm_w
      if(iaps==1) then
        ! ammonium sulfate or ammonium bisulfate
        i1=max(1,min(osm_nhs4%n-1 &
            ,int((molality-osm_nhs4%xs)/osm_nhs4%dx)+1))
        x1=real(i1-1,PS_KIND)*osm_nhs4%dx+osm_nhs4%xs
        wx=min(1.0_RP,max(0.0_RP,(molality-x1)/osm_nhs4%dx))
        osm=min(1.0_RP,max(0.0_RP, &
                   (1.0_RP-wx)*osm_nhs4%y(i1)+ &
                         wx*osm_nhs4%y(i1+1) ))
      else
        ! sodium chloride
        i1=max(1,min(osm_sdch%n-1 &
            ,int((molality-osm_sdch%xs)/osm_sdch%dx)+1))
        x1=real(i1-1,PS_KIND)*osm_sdch%dx+osm_sdch%xs
        wx=min(1.0_RP,max(0.0_RP,(molality-x1)/osm_sdch%dx))
        osm=min(1.0_RP,max(0.0_RP, &
                   (1.0_RP-wx)*osm_sdch%y(i1)+ &
                         wx*osm_sdch%y(i1+1) ))

      endif
      aw0(i,n)=exp(-nu_aps(1)*molality*M_w*1.0e-3_RP*osm)

      x1=273.16_RP
      x2=173.16_RP

      rtnewt(i,n)=0.5_RP*(x1+x2)
      icond1(i,n)=1-icond4(n,i)
      T_f(i,n)=273.16
    enddo
    enddo

    do j=1,JMAX
!      do in=1,nbin*L
!        n=(in-1)/nbin+1
!        i=in-(n-1)*nbin
       do n = 1, L
       do i = 1, nbin

        if(icond1(i,n)==0) then

          call funcd(rtnewt(i,n),f,df,pres(i,n),aw0(i,n))
          dx=f/df
          rtnewt(i,n)=rtnewt(i,n)-dx
          if((x1-rtnewt(i,n))*(rtnewt(i,n)-x2).lt.0.0_RP) then
!!c          write(*,*) "rtnewt jumped out of branckets"
!!c          write(*,'("j,f,df,dx,rtnewt,x1,x2",I5,10ES15.6)') j,f,df,dx,rtnewt(i,n),x1,x2
!!c          write(*,'("aw0,molality,mrat,rad,con,m1,m2,m3,m4",10ES15.6)') aw0,molality,&
!!c                           mrat,rad,con,m1,m2,m3,m4
!!c          write(*,*) "assumed it wont freeze"
            iufz(i,n)=1
            icond1(i,n)=1
          endif
!!!       write(*,'("j,f,df,dx,rtnewt",I5,4ES15.6)') j,f,df,dx,rtnewt(i,n)
          if(abs(dx).lt.xacc) then
            T_f(i,n)=rtnewt(i,n)
            icond1(i,n)=1
          endif
        endif
      enddo
      enddo
    enddo
!    if(any(icond1(1:nbin*L)==0)) then
!      do in=1,nbin*L
!        n=(in-1)/nbin+1
!        i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin
       if(icond1(i,n)==0) then
          molality=1.0e+3/M_aps(1)*mrat(i,n)
          LOG_ERROR("cal_freez_dep2_vec",*) "cal_freez_dep2_vec>iteration failed: ",aw0(i,n),molality,mrat(i,n),rtnewt(i,n),pres(i,n)
          call PRC_abort
       endif
    enddo
    enddo
!    endif


!!c    write(*,*) "iteration for mrat",mrat,j-1

    return

  contains
    subroutine funcd(x,f,df,pr,aw0)
      real(PS) :: x,f,df,pr,aw0
      real(PS) :: delta_aw,awi0,vw0,vi,c1
      ! in J K-1 mol -1
      real(PS), parameter             :: R_u = 8.314472

      ! G Pa^-1
      real(PS),parameter :: k0t=1.6, dk0tdp=-8.8, kit=0.22, dkitdp=-0.17

      real(PS) :: dadt

      real(PS), parameter  :: b1=210368.0,b2=131.438,b3=3.32373e+6,b4=41729.1

      ! nucleation rate (cm^-3 s^-1)
!!c    real(PS), parameter             :: AJ=3.0e+8
      real(PS), parameter             :: AJ=1.0


!!c      write(*,*) "aw0: ",aw0

      awi0=exp((b1+b2*x-b3/x-b4*log(x))/R_u/x)

      vw0=-230.76-0.1478*x+4099.2/x+48.8341*log(x)
      vi=19.43-2.2e-3*x+1.08e-5*x**2.0
      c1=vw0*(pr-0.5*k0t*pr*pr-1.0/6.0*dk0tdp*pr*pr*pr)-vi*(pr-0.5*kit*pr*pr-1.0/6.0*dkitdp*pr*pr*pr)

      delta_aw=aw0*exp(c1/(R_u*1.0e-3)/x)-awi0

      f=-906.7+8502.0*delta_aw-26924.0*delta_aw*delta_aw+29180.0*delta_aw*delta_aw*delta_aw-log10(AJ)


      dadt=aw0*exp(c1/(R_u*1.0e-3)/x)*(-c1/(R_u*1.0e-3)/x**2.0)-&
           awi0*(-b1+2.0*b3/x-b4+b4*log(x))/R_u/x**2.0
      df=8502.0*dadt-26924.0*2.0*delta_aw*dadt+29180.0*3.0*delta_aw*delta_aw*dadt

    end subroutine funcd

  end subroutine cal_freez_dep2_vec

  subroutine cal_nucrat_koop_vec(AJ,nbin,L,ag,mrat,APSNAME,nu_aps,m_aps &
                            ,icycle_n,osm_nhs4,osm_sdch)
    use class_Mass_Bin, only: &
       data1d_lut

    integer,intent(in) :: nbin,L
    ! nucleation rate (cm^-3 s^-1)
    real(PS),dimension(nbin,L),intent(inout)    :: AJ
    ! air group
    type (AirGroup),intent(in)  :: ag
    ! mrat: the ratio of soluble mass to water mass
    real(PS),dimension(nbin,L),intent(in) :: mrat
    character (len=16) :: APSNAME(4)
    type(data1d_lut),intent(in) :: osm_nhs4,osm_sdch
    integer,dimension(LMAX) :: icycle_n
    ! aerosol variables
    real(PS),dimension(*) :: nu_aps,m_aps


    real(PS) :: molality,aw0,pres,osm
    real(PS), parameter             :: M_w=18.0153
    real(PS) :: x
    real(PS) :: delta_aw,awi0,vw0,vi,c1
    ! in J K-1 mol -1
    real(PS), parameter             :: R_u = 8.314472

    ! G Pa^-1
    real(PS),parameter :: k0t=1.6, dk0tdp=-8.8, kit=0.22, dkitdp=-0.17
    real(PS), parameter  :: b1=210368.0,b2=131.438,b3=3.32373e+6,b4=41729.1

    ! loop index
    integer :: i,n
    integer :: iaps,i1
    real(PS) :: x1,wx

    ! the following assignment is necessary for vectorization
    select case(trim(APSNAME(1)))
    case('NH42SO4','NH4HSO4')
      ! ammonium sulfate or ammonium bisulfate
      iaps=1
    case default
      ! sodium chloride
      iaps=2
    end select

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin

      if(icycle_n(n)==0) then

        ! pressure in G Pa from g/s^2/cm (0.1Pa)
        pres=ag%TV(n)%P*1.0e-10

        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        ! NOTE: category 1 is used for molality and activity cacluation.
        !       Sometime, it has to be modified to use multiple ions in the
        !       supercooled droplets.
        ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        molality=1.0e+3/M_aps(1)*mrat(i,n)
        if(iaps==1) then
          ! ammonium sulfate or ammonium bisulfate
          i1=max(1,min(osm_nhs4%n-1 &
              ,int((molality-osm_nhs4%xs)/osm_nhs4%dx)+1))
          x1=real(i1-1,PS_KIND)*osm_nhs4%dx+osm_nhs4%xs
          wx=min(1.0_RP,max(0.0_RP,(molality-x1)/osm_nhs4%dx))
          osm=min(1.0_RP,max(0.0_RP, &
                     (1.0_RP-wx)*osm_nhs4%y(i1)+ &
                           wx*osm_nhs4%y(i1+1) ))
        else
          ! sodium chloride
          i1=max(1,min(osm_sdch%n-1 &
              ,int((molality-osm_sdch%xs)/osm_sdch%dx)+1))
          x1=real(i1-1,PS_KIND)*osm_sdch%dx+osm_sdch%xs
          wx=min(1.0_RP,max(0.0_RP,(molality-x1)/osm_sdch%dx))
          osm=min(1.0_RP,max(0.0_RP, &
                 (1.0_RP-wx)*osm_sdch%y(i1)+ &
                      wx*osm_sdch%y(i1+1) ))

        endif
        aw0=exp(-nu_aps(1)*molality*M_w*1.0e-3_RP*osm)

        x=ag%TV(n)%T
        awi0=exp((b1+b2*x-b3/x-b4*log(x))/R_u/x)

        vw0=-230.76_RP-0.1478_RP*x+4099.2_RP/x+48.8341_RP*log(x)
        vi=19.43_RP-2.2e-3_RP*x+1.08e-5_RP*x**2
        c1=vw0*(pres-0.5_RP*k0t*pres**2-1.0_RP/6.0_RP*dk0tdp*pres**3) &
                -vi*(pres-0.5_RP*kit*pres**2-1.0_RP/6.0_RP*dkitdp*pres**3)

        delta_aw=aw0*exp(c1/(R_u*1.0e-3_RP)/x)-awi0

        AJ(i,n)=10.0_RP**max(-30.0_RP,(-906.7_RP+8502.0_RP*delta_aw-26924.0_RP*delta_aw**2+29180.0_RP*delta_aw**3))

!!c    write(*,'("APSNAME,aw0,molality,mrat: ",A10,A10,10ES15.6)') APSNAME(1),APSNAME(2),aw0,molality,mrat,&
!!c                     delta_aw,AJ
      endif
    enddo
    enddo

  end subroutine cal_nucrat_koop_vec

  subroutine assign_Qp_v3p(level,pmass,alen,clen,T,nuc_gmode,Qp)
    use class_Ice_Shape, only: &
       get_vcs, &
       cal_semiac_ip
    use mod_amps_utility, only: &
         get_len_s3, &
         get_len_s1, &
         get_len_c2a
    real(PS),intent(in) :: pmass,alen,clen,T
    integer,intent(in) :: level,nuc_gmode
    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
!tmp    real(PS), pointer, dimension(:)                     :: Qp
    real(PS), dimension(*)                     :: Qp


    real(PS) :: phi
    real(PS),parameter :: phi_ros=0.25,phi_sdpl=0.25,phi_s3=0.25

!!c    ! use Heymsfieeld and Iaquinta (2000)'s parameters for 5 branches
!!c    real(PS),parameter        :: rho_b=0.81,n_b=4.0,PL=0.5
!!c    real(PS) :: a_ros,b_ros
!!c    ! side plane crystal mass-length relation from Mitchel et al (1990)
!!c    real(PS),parameter :: a_sdpl=0.0041900509,b_sdpl=2.3,phi_sdpl=0.25,phi_sdpl2=0.1
!!c    ! S3 crystal mass-length relation from Mitchel et al (1990)
!!c    real(PS),parameter :: a_s3=0.0027696359,b_s3=2.1,phi_s3=0.25,phi_s32=0.1

    real(PS) :: max_rad

    Qp(iacr)=0.0
    Qp(iccr)=0.0
    Qp(idcr)=0.0_PS
    Qp(iag)=0.0_PS
    Qp(icg)=0.0_PS
    Qp(inex)=0.0_PS
    Qp(ivcs)=0.0_PS

    ! assume that
    !    if freezing droplets are less than 10 micron radius, polycrsytals may
    !    be created.
    if( (level==3.or.level==5.or.level==7)  .and. &
        (T<253.16_PS) ) then
!!c        (max(clen,alen)<10.0e-4.and.T<253.16_PS) ) then
       ! +++ axis lengths of hexagonal crystals are independent of polycrystals +++
       phi=clen/alen
       Qp(iacr)=(pmass/(den_i*coef3sq3*phi))**(1.0/3.0)
       Qp(iccr)=phi*Qp(iacr)
       if(nuc_gmode==4) then
          ! use rosette model by Chiruta and Wang (2003)
          ! V=0.3257N^0.5206 a^3 where N is # of lobes
          ! N=4 is used in this model
          max_rad=get_len_c2a(pmass)
!!c          max_rad=(pmass/den_i/0.67027063_PS)**(1.0/3.0)

          ! use Heymsfield and Iaquinta (2000)'s formula to estimate a axis growth
!!c          if(Qp(iccr)<0.0004_PS) then
!!c             a_ros=2.51_PS
!!c             b_ros=0.0_PS
!!c          elseif(Qp(iccr)<=0.0017_PS) then
!!c             a_ros=0.0020_PS
!!c             b_ros=-1.0_PS
!!c          else
!!c             a_ros=0.048_PS
!!c             b_ros=-0.442_PS
!!c          end if

          Qp(idcr)=0.0_PS
          Qp(iag)=0.0_PS
          Qp(icg)=Qp(iccr)
          Qp(inex)=3.0_PS
          phi=phi_ros

          ! assume the cylinder volume
          Qp(ivcs)=get_vcs(1,phi,max_rad)
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5)*max_rad**3.0

!!c          write(*,'("assignQpv3p:",I5,5ES15.6)') nuc_gmode,Qp(iacr),Qp(iccr),Qp(iccr)/Qp(iacr)
       elseif(nuc_gmode==1) then
          max_rad=get_len_s3(pmass)
          Qp(idcr)=0.0_PS
          Qp(iag)=Qp(iacr)*0.5_PS
          Qp(icg)=Qp(iccr)*0.5_PS
          Qp(inex)=3.0_PS
          phi=phi_s3
          ! assume the cylinder volume
          Qp(ivcs)=get_vcs(1,phi,max_rad)
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5)*max_rad**3.0


!!c          write(*,*) "I am in assignQpv3p",nuc_gmode,Qp


       elseif(nuc_gmode==5) then
          max_rad=get_len_s1(pmass)
          Qp(idcr)=0.0_PS
          Qp(iag)=Qp(iacr)
          Qp(icg)=0.0_PS
          Qp(inex)=3.0_PS

          phi=phi_sdpl

          ! assume the cylinder volume
          Qp(ivcs)=get_vcs(1,phi,max_rad)
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5)*max_rad**3.0

!!c          write(*,*) "I am in assignQpv3p",nuc_gmode,Qp
       else

          ! assume the cylinder volume
          Qp(ivcs)=get_vcs(1,phi,Qp(iacr))
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5)*Qp(iacr)**3.0

          Qp(idcr)=0.0_PS
          Qp(iag)=0.0_PS
          Qp(icg)=0.0_PS
          Qp(inex)=0.0_PS
!!c          write(*,*) "I am in assignQpv3p",nuc_gmode,Qp
       end if
    else
       phi=clen/alen
       Qp(iacr)=(pmass/(den_i*coef3sq3*phi))**(1.0/3.0)
       Qp(iccr)=phi*Qp(iacr)
       ! assume the cylinder volume
       Qp(ivcs)=get_vcs(1,phi,Qp(iacr))
!!c       Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5)*Qp(iacr)**3.0
       Qp(idcr)=0.0_PS
       Qp(iag)=0.0_PS
       Qp(icg)=0.0_PS
       Qp(inex)=0.0_PS
!!c       write(*,*) "I 2 assignQpv3p",nuc_gmode,Qp

    end if
    Qp(ivcs)=max(pmass/den_i,Qp(ivcs))


    ! assume the cylinder volume
!!c    Qp(8)=(Qp(ivcs)/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi**2.0)
!!c    Qp(9)=Qp(8)*phi
    call cal_semiac_ip(1,phi,Qp(ivcs),Qp(mxnnonmc+1),Qp(mxnnonmc+2))

  end subroutine assign_Qp_v3p

  subroutine assign_Qp_v3p_vec(Qp,level,g,ag,icond3)
    use class_Ice_Shape, only: &
       get_vcs, &
       cal_semiac_ip
    use mod_amps_utility, only: &
       get_len_s3, &
       get_len_s1, &
       get_len_c2a
    integer,intent(in) :: level
    ! mass (liquid or solid) group
    type (Group), intent(in)   :: g
    ! thermo variable object
    type (AirGroup), intent(in)  :: ag
    integer,dimension(mxnbin+1,*),intent(in) :: icond3

    ! non-mass variables of a representative particle in the shifted bin
    ! argument 1 : volume of circumscribing sphere
    !          2 : a-axis length
    !          3 : c-axis length
    !          4 : d-axis length
    !          5 : r-axis length
    !          6 : volume by riming
    !          7 : volume by aggregation
!tmp    real(PS), pointer, dimension(:)                     :: Qp
    real(PS), dimension(mxnbin+1,g%L,mxnnonmc+2)             :: Qp


    real(PS) :: phi
    real(PS),parameter :: phi_ros=0.25,phi_sdpl=0.25,phi_s3=0.25

!!c    ! use Heymsfieeld and Iaquinta (2000)'s parameters for 5 branches
!!c    real(PS),parameter        :: rho_b=0.81,n_b=4.0,PL=0.5
!!c    real(PS) :: a_ros,b_ros
!!c    ! side plane crystal mass-length relation from Mitchel et al (1990)
!!c    real(PS),parameter :: a_sdpl=0.0041900509,b_sdpl=2.3,phi_sdpl=0.25,phi_sdpl2=0.1
!!c    ! S3 crystal mass-length relation from Mitchel et al (1990)
!!c    real(PS),parameter :: a_s3=0.0027696359,b_s3=2.1,phi_s3=0.25,phi_s32=0.1
    real(PS) :: max_rad

    integer :: i,n
    real(PS) :: pmass,alen,clen,T
    integer :: nuc_gmode


!    do in=1,g%N_BIN*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

      Qp(i,n,iacr)=0.0_PS
      Qp(i,n,iccr)=0.0_PS
      Qp(i,n,idcr)=0.0_PS
      Qp(i,n,iag)=0.0_PS
      Qp(i,n,icg)=0.0_PS
      Qp(i,n,inex)=0.0_PS
      Qp(i,n,ivcs)=0.0_PS

      if(icond3(i,n)==1) then
        T=ag%TV(n)%T
        nuc_gmode=ag%TV(n)%nuc_gmode
!!c        write(*,*) "ck nuc_gmode",i,n,nuc_gmode,ag%TV(n)%T,ag%TV(n)%s_v(1),ag%TV(n)%s_v(2)

        pmass=g%MS(i,n)%mean_mass
        alen=g%MS(i,n)%a_len
        clen=g%MS(i,n)%c_len

        ! assume that
        !    if freezing droplets are less than 10 micron radius, polycrsytals may
        !    be created.
        if( (level==3.or.level==5.or.level==7)  .and. &
            (T<253.16_PS) ) then

! sense test Ong Chia Rui, original is false
!!if (.false.) then
!!           phi=clen/alen
!!          Qp(i,n,iacr)=(pmass/(den_i*coef3sq3*phi))**(1.0_PS/3.0_PS)
!!          Qp(i,n,iccr)=phi*Qp(i,n,iacr)
!!          ! assume the cylinder volume
!!          !Qp(i,n,ivcs)=get_vcs(1,phi,Qp(i,n,iacr))
!! !!c       Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5_PS)*Qp(iacr)**3
!!          !Qp(i,n,idcr)=0.0_PS
!!          !Qp(i,n,iag)=0.0_PS
!!          !Qp(i,n,icg)=0.0_PS
!!          !Qp(i,n,inex)=0.0_PS
!!
!!          ! sense test ros
!!          max_rad=get_len_c2a(pmass)
!!          max_rad=max_rad/phi_ros
!!          Qp(i,n,idcr)=0.0_PS
!!          Qp(i,n,iag)=0.0_PS
!!          Qp(i,n,icg)=Qp(i,n,iccr)
!!          Qp(i,n,inex)=1.0_PS
!!          phi=phi_ros
!!          ! assume the cylinder volume
!!          Qp(i,n,ivcs)=get_vcs(1,phi,max_rad)
!!
!!else

!!c        (max(clen,alen)<10.0e-4.and.T<253.16_PS) ) then
          ! +++ axis lengths of hexagonal crystals are independent of polycrystals +++
          phi=clen/alen
          Qp(i,n,iacr)=(pmass/(den_i*coef3sq3*phi))**(1.0_PS/3.0_PS)
          Qp(i,n,iccr)=phi*Qp(i,n,iacr)

          if(nuc_gmode==4) then
            ! use rosette model by Chiruta and Wang (2003)
            ! V=0.3257N^0.5206 a^3 where N is # of lobes
            ! N=4 is used in this model
            max_rad=get_len_c2a(pmass)
!!c          max_rad=(pmass/den_i/0.67027063_PS)**(1.0/3.0)

            ! use Heymsfield and Iaquinta (2000)'s formula to estimate a axis growth
!!c          if(Qp(iccr)<0.0004_PS) then
!!c             a_ros=2.51_PS
!!c             b_ros=0.0_PS
!!c          elseif(Qp(iccr)<=0.0017_PS) then
!!c             a_ros=0.0020_PS
!!c             b_ros=-1.0_PS
!!c          else
!!c             a_ros=0.048_PS
!!c             b_ros=-0.442_PS
!!c          end if

            Qp(i,n,idcr)=0.0_PS
            Qp(i,n,iag)=0.0_PS
            Qp(i,n,icg)=Qp(i,n,iccr)
            Qp(i,n,inex)=1.0_PS
            phi=phi_ros

            ! assume the cylinder volume
            Qp(i,n,ivcs)=get_vcs(1,phi,max_rad)
            !write(*,'(a,3es15.6)') "NUC 4 ERROR: ", ag%TV(n)%T, ag%TV(n)%s_v(:)
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2.0)**1.5)*max_rad**3.0

!!c          write(*,'("assignQpv3p:",I5,5ES15.6)') nuc_gmode,Qp(iacr),Qp(iccr),Qp(iccr)/Qp(iacr)
          elseif(nuc_gmode==1) then
            max_rad=get_len_s3(pmass)
            Qp(i,n,idcr)=0.0_PS
            Qp(i,n,iag)=sqrt(Qp(i,n,iacr))
            Qp(i,n,icg)=sqrt(Qp(i,n,iccr))
            Qp(i,n,inex)=1.0_PS
            phi=phi_s3
            ! assume the cylinder volume
            Qp(i,n,ivcs)=get_vcs(1,phi,max_rad)
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2)**1.5_PS)*max_rad**3


!!c          write(*,*) "I am in assignQpv3p",nuc_gmode,Qp


          elseif(nuc_gmode==5) then
            max_rad=get_len_s1(pmass)
            Qp(i,n,idcr)=0.0_PS
            Qp(i,n,iag)=Qp(i,n,iacr)
            Qp(i,n,icg)=0.0_PS
            Qp(i,n,inex)=1.0_PS

            phi=phi_sdpl

            ! assume the cylinder volume
            Qp(i,n,ivcs)=get_vcs(1,phi,max_rad)
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2)**1.5_PS)*max_rad**3

!!c          write(*,*) "I am in assignQpv3p",nuc_gmode,Qp
            !write(*,'(a,3es15.6)') "NUC 5 ERROR: ", ag%TV(n)%T, ag%TV(n)%s_v(:)
          else

            ! assume the cylinder volume
            Qp(i,n,ivcs)=get_vcs(1,phi,Qp(i,n,iacr))
!!c          Qp(ivcs)=coef4pi3*((1.0_PS+phi**2)**1.5_PS)*Qp(iacr)**3

            Qp(i,n,idcr)=0.0_PS
            Qp(i,n,iag)=0.0_PS
            Qp(i,n,icg)=0.0_PS
            Qp(i,n,inex)=0.0_PS
!!c          write(*,*) "I am in assignQpv3p",nuc_gmode,Qp
            !write(*,'(a,3es15.6)') "NUC 6 ERROR: ", ag%TV(n)%T, ag%TV(n)%s_v(:)
          end if

!!endif

        else

! sense test Ong Chia Rui, original is false
!!if (.false.) then
!!          phi=clen/alen
!!          Qp(i,n,iacr)=(pmass/(den_i*coef3sq3*phi))**(1.0_PS/3.0_PS)
!!          Qp(i,n,iccr)=phi*Qp(i,n,iacr)
!!          ! sense test ros
!!          max_rad=get_len_c2a(pmass)
!!          max_rad=max_rad/phi_ros
!!          Qp(i,n,idcr)=0.0_PS
!!          Qp(i,n,iag)=0.0_PS
!!          Qp(i,n,icg)=Qp(i,n,iccr)
!!          Qp(i,n,inex)=1.0_PS
!!          phi=phi_ros
!!          ! assume the cylinder volume
!!          Qp(i,n,ivcs)=get_vcs(1,phi,max_rad)
!!
!!else

          phi=clen/alen
          Qp(i,n,iacr)=(pmass/(den_i*coef3sq3*phi))**(1.0_PS/3.0_PS)
          Qp(i,n,iccr)=phi*Qp(i,n,iacr)
          ! assume the cylinder volume
          Qp(i,n,ivcs)=get_vcs(1,phi,Qp(i,n,iacr))
!!c       Qp(ivcs)=coef4pi3*((1.0_PS+phi**2)**1.5_PS)*Qp(iacr)**3
          Qp(i,n,idcr)=0.0_PS
          Qp(i,n,iag)=0.0_PS
          Qp(i,n,icg)=0.0_PS
          Qp(i,n,inex)=0.0_PS
!!c       write(*,*) "I 2 assignQpv3p",nuc_gmode,Qp

!!endif

        end if


        Qp(i,n,ivcs)=max(pmass/den_i,Qp(i,n,ivcs))

        ! assume the cylinder volume
!!c    Qp(8)=(Qp(ivcs)/coef4pi3)**(1.0_PS/3.0_PS)/sqrt(1.0_PS+phi**2)
!!c    Qp(9)=Qp(8)*phi
        call cal_semiac_ip(1,phi,Qp(i,n,ivcs),Qp(i,n,mxnnonmc+1),Qp(i,n,mxnnonmc+2))
      endif
    enddo
    enddo

  end subroutine assign_Qp_v3p_vec

!!$  subroutine cal_xxx_p_v5(level, mmass_p, Qp,ratio_Mp,&
!!$       den_ip_p,asr_p,type_p,&
!!$       den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
!!$       from)
!!$    use mod_amps_utility, only: get_len_s1,get_len_c2a,get_len_s3
!!$
!!$    !type (group), intent(in)       :: g
!!$    integer,intent(in)   :: level!,clctr,ngrid
!!$    ! mean mass in shifted bins
!!$    real(ps)                                   :: mmass_p
!!$    ! axis change in shifted bins
!!$!tmp    real(ps), pointer, dimension(:)            :: d_axis_len
!!$    !real(ps), dimension(*)            :: d_axis_len
!!$    ! quality variable for a particle
!!$!tmp    real(ps), pointer, dimension(:)                     :: Qp
!!$    real(ps), dimension(*)                     :: Qp
!!$    ! bulk sphere density of whole ice particle, dry ice particle, and of ice crystal
!!$    real(ps)  :: den_p,den_ip_p,den_ic_p
!!$    ! axis ratio for ice crystals in the shifted bin
!!$    ! 1: c/a
!!$    ! 2: d/a
!!$    ! 3: r/a
!!$    ! 4: e/a
!!$!tmp    real(ps),pointer,dimension(:)  :: axr_p
!!$    real(ps),dimension(*)  :: axr_p
!!$    ! habit in shifted bin
!!$    integer               :: habit_p
!!$    ! type in shifted bin
!!$    integer               :: type_p
!!$    ! ice shape model in shifted bin
!!$!tmp    integer,pointer,dimension(:)     :: is_mod_p
!!$    integer,dimension(2)     :: is_mod_p
!!$
!!$    ! ratio of ag^3 to a^3
!!$    real(ps)              :: rag_p,rcg_p
!!$    ! number of extra ice crystals
!!$    real(PS) :: n_exice_p
!!$
!!$    ! aspect ratio of ice particle
!!$    real(PS),intent(inout) :: asr_p
!!$
!!$    ! ratio of each component mass to the total mass in the shifted bin
!!$    ! ratio_mp(1) : rime
!!$    ! ratio_mp(2) : aggregation
!!$    ! ratio_mp(3) : ice crystal
!!$    ! ratio_Mp(imw_m) : melt mass
!!$!tmp    real(ps), pointer, dimension(:)      :: ratio_Mp
!!$    real(ps), dimension(*)      :: ratio_Mp
!!$    character (len=*) :: from
!!$
!!$    integer :: i
!!$!!c    ! volume of circumbscribing sphere
!!$!!c    real(ps) :: v_cs_p
!!$
!!$    ! maximum possible semi axis lengths of ice particle
!!$    real(PS),parameter :: len_csmax=10.0
!!$    ! maximum and minimum aspect ratio
!!$    real(PS),parameter  :: phi_max=2.0e+1,phi_min=5.0e-3
!!$    ! min and max possible length of ice crystal
!!$    real(PS),parameter :: min_len=1.0e-4,max_len=5.0
!!$    ! max for ice particle
!!$    real(PS),parameter :: max_len2=5.0
!!$
!!$    real(PS),parameter :: frac=0.1_PS
!!$
!!$    !real(PS) :: dum,max_rad,rat
!!$    ! semi majour and minor lengths of ice crystals, and ice particles
!!$    real(PS) :: semi_a_i,semi_c_i,semi_aip_p,semi_cip_p
!!$    ! semi majour and minor lengths of whole ice particles (with water)
!!$    real(PS) :: semi_a_p,semi_c_p,v_csw_p
!!$    ! r-axis and e-axis lengths, volume of ice
!!$    real(PS) :: rlen_p,elen_p,v_ic_p
!!$    ! length of s1, c2a, s3
!!$    real(PS) :: xlen_s1,xlen_c2a,xlen_s3
!!$    ! axis ratio of polycrystals
!!$    real(PS) :: gam_p,eta_p
!!$    integer :: habit_p2
!!$    ! error message
!!$    !integer :: em
!!$
!!$    ! limit to be dealt as ice particle
!!$!!c    real(PS),parameter :: fmice_lmt=0.9995
!!$
!!$
!!$    !integer   :: item(1)
!!$
!!$!tmp    allocate( is_mod_p(2), stat = item(1))
!!$!tmp    if(any(item /= 0) ) stop "memory not available in cal_xxx_p_v5"
!!$
!!$
!!$    ! reality check of growing ice particles
!!$    Qp(iacr)=min(max(Qp(iacr),min_len),max_len)
!!$    Qp(iccr)=min(max(Qp(iccr),min_len),max_len)
!!$    if(Qp(iccr)>phi_max*Qp(iacr)) then
!!$       Qp(iccr)=Qp(iacr)*phi_max
!!$    elseif(Qp(iccr)<phi_min*Qp(iacr)) then
!!$       Qp(iacr)=Qp(iccr)/phi_min
!!$    end if
!!$
!!$    Qp(idcr)=min(max(Qp(idcr),0.0_PS),0.9_PS*Qp(iacr))
!!$    Qp(iag)=min(max(Qp(iag),0.0_PS),5.0_PS)
!!$    Qp(icg)=min(max(Qp(icg),0.0_PS),5.0_PS)
!!$    Qp(inex)=min(max(Qp(inex),0.0_PS),1.0_PS)
!!$
!!$
!!$    do i=1,2
!!$       axr_p(i) = Qp(iacr+i)/Qp(iacr)
!!$    end do
!!$
!!$    rag_p=(Qp(iag)/Qp(iacr))**3.0
!!$    rcg_p=(Qp(icg)/Qp(iccr))**3.0
!!$    n_exice_p=Qp(inex)
!!$
!!$
!!$    if(axr_p(1)>30.0)then
!!$       continue
!!$    end if
!!$
!!$    ! pristine crystal
!!$    ! hexagonal crystals
!!$    habit_p=1
!!$
!!$    axr_p(3)=0.0_PS
!!$    axr_p(4)=0.0_PS
!!$
!!$
!!$    Qp(mxnnonmc+1)=min(max(Qp(mxnnonmc+1),Qp(iacr)),max_len2)
!!$    Qp(mxnnonmc+2)=min(max(Qp(mxnnonmc+2),Qp(iccr)),max_len2)
!!$    asr_p=Qp(mxnnonmc+2)/Qp(mxnnonmc+1)
!!$    if(asr_p>phi_max) then
!!$!!c       write(*,*) "cal_xxx_p_v5: asr too large",asr_p
!!$       asr_p=phi_max
!!$       Qp(mxnnonmc+2)=Qp(mxnnonmc+1)*phi_max
!!$    elseif(asr_p<phi_min) then
!!$!!c       write(*,*) "cal_xxx_p_v5: asr too small",asr_p
!!$       asr_p=phi_min
!!$       Qp(mxnnonmc+1)=Qp(mxnnonmc+2)/phi_min
!!$    end if
!!$
!!$!!c    ! set up the maximum melt water possible to keep density of dry ice finite.
!!$!!c    if(fmice_lmt<=ratio_Mp(imw_m)) then
!!$!!c       write(*,*) from
!!$!!c       write(*,'("cal_xxx_p_v5>ratMp7 mod",10ES15.6)') ratio_Mp
!!$!!c       ratio_Mp(imw_m)=fmice_lmt
!!$!!c       ratio_Mp(imr_m)=max(0.0_PS,1.0_PS-ratio_Mp(ima_m)-ratio_Mp(imc_m)-ratio_Mp(imw_m))
!!$!!c    end if
!!$
!!$    xlen_s1=get_len_s1(mmass_p*ratio_Mp(imc_m))
!!$    xlen_c2a=get_len_c2a(mmass_p*ratio_Mp(imc_m))
!!$    xlen_s3=get_len_s3(mmass_p*ratio_Mp(imc_m))
!!$
!!$    ! calculate the property of ice particle in the shifted bin
!!$    ! diagnose habit in the shifted bin
!!$    call diag_habit_v4(level,Qp(iacr),Qp(iccr),Qp(idcr),Qp(iag),Qp(icg),Qp(inex),&
!!$         xlen_s1,xlen_c2a,xlen_s3,rlen_p,elen_p,gam_p,eta_p,v_ic_p,&
!!$         semi_a_i,semi_c_i,habit_p2)
!!$
!!$!!c    call diag_sh_type_v4(level,ratio_Mp, type_p)
!!$    call diag_sh_type_v6(level,ratio_Mp, mmass_p*ratio_Mp(imf_m),type_p, is_mod_p)
!!$!!c    type_p=g%IS(clctr,ngrid)%sh_type
!!$!!c    is_mod_p=g%IS(clctr,ngrid)%is_mod
!!$
!!$!!c    call diag_is_mod(habit_p2,type_p,is_mod_p)
!!$!!c    is_mod_p=g%IS(clctr,ngrid)%is_mod
!!$
!!$!!c    call cal_cs_spheroid(level,Qp(iacr),Qp(iccr),rlen_p,elen_p,v_ic_p,&
!!$!!c         semi_a_i,semi_c_i,habit_p2,&
!!$!!c         type_p,semi_a_p,semi_c_p,asr_p,Qp(ivcs),&
!!$!!c         mmass_p,mmass_p*ratio_Mp(imc_m),mmass_p*ratio_Mp(ima_m))
!!$!!c
!!$    call cal_cs_spheroid3(level,Qp(iacr),Qp(iccr),rlen_p,elen_p,v_ic_p,&
!!$         semi_a_i,semi_c_i,habit_p2,&
!!$         type_p,semi_aip_p,semi_cip_p,asr_p,Qp(ivcs),&
!!$         semi_a_p,semi_c_p,v_csw_p,&
!!$         mmass_p,mmass_p*ratio_Mp(imc_m),mmass_p*ratio_Mp(ima_m),&
!!$         mmass_p*ratio_Mp(imr_m),mmass_p*ratio_Mp(imw_m),&
!!$         is_mod_p,0)
!!$
!!$
!!$
!!$
!!$!!c    call cal_bulk_density(level,2,mmass_p,den_ip_p,&
!!$!!c         mmass_p*ratio_Mp(imc_m),den_ic_p,&
!!$!!c         habit_p2,Qp(iacr),Qp(iccr),Qp(idcr),rlen_p,elen_p,axr_p(1),axr_p(2),v_ic_p,&
!!$!!c         type_p,semi_a_p,semi_c_p,asr_p,Qp(ivcs),&
!!$!!c         mmass_p*ratio_Mp(imw_m),&
!!$!!c         'from cal_xxx_p')
!!$
!!$
!!$    call cal_bulk_density3(level,2,mmass_p,den_p,&
!!$         mmass_p*ratio_Mp(imc_m),den_ic_p,&
!!$         habit_p2,Qp(iacr),Qp(iccr),Qp(idcr),rlen_p,elen_p,axr_p(1),axr_p(2),v_ic_p,&
!!$         type_p,semi_aip_p,semi_cip_p,asr_p,Qp(ivcs),den_ip_p,&
!!$         semi_a_p,semi_c_p,v_csw_p,&
!!$         mmass_p*ratio_Mp(imr_m),mmass_p*ratio_Mp(ima_m),mmass_p*ratio_Mp(imw_m),&
!!$         is_mod_p,1,0,&
!!$         0,0,0,'from cal_xxx_p'//from)
!!$
!!$
!!$!tmp    deallocate (is_mod_p, stat = item(1))
!!$!tmp    nullify(is_mod_p)
!!$!tmp    if(any(item /= 0 )) stop "memory not deallocated in cal_xxx_p_v5"
!!$
!!$
!!$  end subroutine cal_xxx_p_v5

  subroutine cal_xxx_p_v5_vec(level,L, icond3, n_all, Mp,Np,&
       Qp,ratio_Mp,&
       den_ip_p,asr_p,type_p,&
       den_ic_p,axr_p,habit_p,rag_p,rcg_p,n_exice_p,&
       from)
    use class_Ice_Shape, only: &
       diag_habit_v4
    use class_Mass_Bin, only: &
       diag_sh_type_v6
    use mod_amps_utility, only: &
       get_len_s1, &
       get_len_c2a, &
       get_len_s3

    integer, intent(in)       :: L
    integer,intent(in)   :: level!,clctr
    integer,intent(in),dimension(mxnbin+1,*) :: icond3
    ! total number of sub-bins in a clctr bin
    integer,dimension(*),intent(in)         :: n_all
    ! total concentration in the shifted bin
    real(PS), dimension(mxnbin+1,*),intent(in)           :: Np
    ! total mass in the shifted bin
    real(PS), dimension(mxnbin+1,*),intent(in)           :: Mp
    ! quality variable for a particle
    real(ps), dimension(mxnbin+1,L,mxnnonmc+2),intent(inout)        :: Qp
    ! bulk sphere density of dry ice particle, and of ice crystal
    real(PS), dimension(mxnbin+1,*),intent(inout)  :: den_ip_p,den_ic_p
    ! axis ratio for ice crystals in the shifted bin
    ! 1: c/a
    ! 2: d/a
    ! 3: r/a
    ! 4: e/a
!tmp    real(ps),pointer,dimension(:)  :: axr_p
    real(PS),dimension(mxnbin+1,L,mxnaxis-1), intent(inout)  :: axr_p
    ! habit in shifted bin
    integer, dimension(mxnbin+1,*), intent(inout)            :: habit_p
    ! type in shifted bin
    integer, dimension(mxnbin+1,*), intent(inout)            :: type_p

    ! ratio of ag^3 to a^3
    real(PS), dimension(mxnbin+1,*), intent(inout)           :: rag_p,rcg_p
    ! number of extra ice crystals
    real(PS), dimension(mxnbin+1,*), intent(inout)           :: n_exice_p

    ! aspect ratio of ice particle
    real(PS), dimension(mxnbin+1,*), intent(inout)           :: asr_p

    ! activated IN fraction
    !real(PS), dimension(mxnbin+1,*), intent(inout)           :: actINF_p

    ! ratio of each component mass to the total mass in the shifted bin
    ! ratio_mp(1) : rime
    ! ratio_mp(2) : aggregation
    ! ratio_mp(3) : ice crystal
    ! ratio_Mp(imw_m) : melt mass
    real(ps), dimension(mxnbin+1,L,mxnmasscomp),intent(in)   :: ratio_Mp
    character (len=*) :: from
    !
    ! new space
    !
    ! a-axis, c-axis, and dendritic axis lengths
    real(PS), dimension(mxnbin+1,LMAX)   :: alen,clen,dlen
    ! r-axis and e-axis lengths, volume of ice
    real(PS), dimension(mxnbin+1,LMAX)   :: rlen,elen,v_ic
    real(PS), dimension(mxnbin+1,LMAX)   :: phi_ic,psi_ic
    ! semi majour and minor lengths of ice crystals, and ice particles
    real(PS), dimension(mxnbin+1,LMAX) :: semi_a_i,semi_c_i,semi_aip,semi_cip
    ! volume of circumbscribing sphere, aspect ratio of it.
    real(PS), dimension(mxnbin+1,LMAX) :: v_cs!,phi_cs
    ! semi majour and minor lengths of whole ice particles (with water)
    real(PS), dimension(mxnbin+1,LMAX) :: semi_a,semi_c,v_csw
    real(PS), dimension(mxnbin+1,LMAX)   :: mean_mass,m_ic,m_rm,m_ag,m_mlt
    integer, dimension(mxnbin+1,LMAX)   :: habit_p2
    ! ice shape model in shifted bin
    integer,dimension(2,mxnbin+1,LMAX)     :: is_mod
    ! bulk sphere density of whole ice particle
    real(ps), dimension(mxnbin+1,LMAX) :: den

    ! length of s1, c2a, s3
    real(PS) :: xlen_s1,xlen_c2a,xlen_s3
    ! axis ratio of polycrystals
    real(PS) :: gam_p,eta_p
    ! error message
    !integer :: em
!    integer,dimension((mxnbin+1)*LMAX) :: ierror1

    integer :: j,n!,i

    ! maximum possible semi axis lengths of ice particle
    real(PS),parameter :: len_csmax=10.0
    ! maximum and minimum aspect ratio
    real(PS),parameter  :: phi_max=2.0e+1,phi_min=5.0e-3
    ! min and max possible length of ice crystal
    real(PS),parameter :: min_len=1.0e-4,max_len=5.0
    ! max for ice particle
    real(PS),parameter :: max_len2=5.0

    real(PS),parameter :: frac=0.1_PS

    ! limit to be dealt as ice particle
!!c    real(PS),parameter :: fmice_lmt=0.9995


    integer   :: n_all_max



    n_all_max=maxval(n_all(1:L))


!    do jn=1,n_all_max*L
!      n=(jn-1)/n_all_max+1
!      j=jn-(n-1)*n_all_max
    do n = 1, L
    do j = 1, n_all_max
      if(icond3(j,n)==1.and.j<=n_all(n)) then

        ! reality check of growing ice particles
        Qp(j,n,iacr)=min(max(Qp(j,n,iacr),min_len),max_len)
        Qp(j,n,iccr)=min(max(Qp(j,n,iccr),min_len),max_len)
        if(Qp(j,n,iccr)>phi_max*Qp(j,n,iacr)) then
          Qp(j,n,iccr)=Qp(j,n,iacr)*phi_max
        elseif(Qp(j,n,iccr)<phi_min*Qp(j,n,iacr)) then
          Qp(j,n,iacr)=Qp(j,n,iccr)/phi_min
        end if

        Qp(j,n,idcr)=min(max(Qp(j,n,idcr),0.0_PS),0.9_PS*Qp(j,n,iacr))
        Qp(j,n,iag)=min(max(Qp(j,n,iag),0.0_PS),5.0_PS)
        Qp(j,n,icg)=min(max(Qp(j,n,icg),0.0_PS),5.0_PS)
        Qp(j,n,inex)=min(max(Qp(j,n,inex),0.0_PS),1.0_PS)

        axr_p(j,n,1) = Qp(j,n,iacr+1)/Qp(j,n,iacr)
        axr_p(j,n,2) = Qp(j,n,iacr+2)/Qp(j,n,iacr)

        rag_p(j,n)=(Qp(j,n,iag)/Qp(j,n,iacr))**3
        rcg_p(j,n)=(Qp(j,n,icg)/Qp(j,n,iccr))**3
        n_exice_p(j,n)=Qp(j,n,inex)


        ! pristine crystal
        ! hexagonal crystals
        habit_p(j,n)=1

        axr_p(j,n,3)=0.0_PS
        axr_p(j,n,4)=0.0_PS


        Qp(j,n,mxnnonmc+1)=min(max(Qp(j,n,mxnnonmc+1),Qp(j,n,iacr)),max_len2)
        Qp(j,n,mxnnonmc+2)=min(max(Qp(j,n,mxnnonmc+2),Qp(j,n,iccr)),max_len2)
        asr_p(j,n)=Qp(j,n,mxnnonmc+2)/Qp(j,n,mxnnonmc+1)
        if(asr_p(j,n)>phi_max) then
          asr_p(j,n)=phi_max
          Qp(j,n,mxnnonmc+2)=Qp(j,n,mxnnonmc+1)*phi_max
        elseif(asr_p(j,n)<phi_min) then
          asr_p(j,n)=phi_min
          Qp(j,n,mxnnonmc+1)=Qp(j,n,mxnnonmc+2)/phi_min
        end if

!!c    ! set up the maximum melt water possible to keep density of dry ice finite.
!!c    if(fmice_lmt<=ratio_Mp(imw_m)) then
!!c       write(*,*) from
!!c       write(*,'("cal_xxx_p_v5>ratMp7 mod",10ES15.6)') ratio_Mp
!!c       ratio_Mp(imw_m)=fmice_lmt
!!c       ratio_Mp(imr_m)=max(0.0_PS,1.0_PS-ratio_Mp(ima_m)-ratio_Mp(imc_m)-ratio_Mp(imw_m))
!!c    end if

        mean_mass(j,n)=Mp(j,n)/Np(j,n)
        m_ic(j,n)=mean_mass(j,n)*ratio_Mp(j,n,imc_m)
        m_rm(j,n)=mean_mass(j,n)*ratio_Mp(j,n,imr_m)
        m_ag(j,n)=mean_mass(j,n)*ratio_Mp(j,n,ima_m)
        m_mlt(j,n)=mean_mass(j,n)*ratio_Mp(j,n,imw_m)

        xlen_s1=get_len_s1(m_ic(j,n))
        xlen_c2a=get_len_c2a(m_ic(j,n))
        xlen_s3=get_len_s3(m_ic(j,n))

        ! calculate the property of ice particle in the shifted bin
        ! diagnose habit in the shifted bin
        call diag_habit_v4(level,&
             Qp(j,n,iacr),Qp(j,n,iccr),Qp(j,n,idcr),Qp(j,n,iag),Qp(j,n,icg),Qp(j,n,inex),&
             xlen_s1,xlen_c2a,xlen_s3,rlen(j,n),elen(j,n),gam_p,eta_p,v_ic(j,n),&
             semi_a_i(j,n),semi_c_i(j,n),habit_p2(j,n))

        call diag_sh_type_v6(level,ratio_Mp(j,n,1), mean_mass(j,n)*ratio_Mp(j,n,imf_m)&
                            ,type_p(j,n), is_mod(1,j,n))

      endif
    enddo
    enddo

    ! initialize
!    do jn=1,n_all_max*L
!      n=(jn-1)/n_all_max+1
!      j=jn-(n-1)*n_all_max
    do n = 1, L
    do j = 1, n_all_max
      if(icond3(j,n)==1.and.j<=n_all(n)) then
        alen(j,n)=Qp(j,n,iacr)
        clen(j,n)=Qp(j,n,iccr)
        dlen(j,n)=Qp(j,n,idcr)
        v_cs(j,n)=Qp(j,n,ivcs)
        phi_ic(j,n)=axr_p(j,n,1)
        psi_ic(j,n)=axr_p(j,n,2)
      else
        alen(j,n)=0.0_PS
        clen(j,n)=0.0_PS
        dlen(j,n)=0.0_PS
        v_cs(j,n)=0.0_PS
        phi_ic(j,n)=0.0_PS
        psi_ic(j,n)=0.0_PS
      endif
    enddo
    enddo

    call cal_cs_spheroid3_vec2( &
                semi_aip,semi_cip,asr_p,V_cs,semi_a,semi_c,V_csw, &
                n_all_max,L,icond3,habit_p2,type_p, &
                alen,clen,semi_a_i,semi_c_i,V_ic,&
                mean_mass,m_ic,m_rm,m_ag,m_mlt,&
                is_mod,0)

    if ( debug ) then
!    do jn=1,n_all_max*L
!      n=(jn-1)/n_all_max+1
!      j=jn-(n-1)*n_all_max
       do n = 1, L
       do j = 1, n_all_max
!      ierror1(jn)=0
          if(icond3(j,n)==1.and.j<=n_all(n).and.v_cs(j,n)<1.0e-30) then
             write(*,*) "ck vcs0: ",trim(from),j,n,habit_p2(j,n),type_p(j,n),is_mod(1:2,j,n),&
                  mean_mass(j,n),v_cs(j,n),v_ic(j,n),&
                  alen(j,n),clen(j,n)
             write(*,*) "Np,Mp",Np(j,n),Mp(j,n)
             write(*,*) "ratio_Mp",ratio_Mp(j,n,:)
          endif
       enddo
       enddo
    end if

    call cal_bulk_density3_vec2( &
                den,den_ip_p,den_ic_p, &
                alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
                semi_aip,semi_cip,asr_p,v_cs,semi_a,semi_c,v_csw, &
                n_all_max,L,icond3,habit_p2,type_p, &
                mean_mass,m_ic,m_rm,m_ag,m_mlt,&
                is_mod,1,0)!,'from cal_xxx_p'//from

!    do jn=1,n_all_max*L
!      n=(jn-1)/n_all_max+1
!      j=jn-(n-1)*n_all_max
!      if(icond3(j,n)==1.and.j<=n_all(n)) then
!        write(*,*) "ck vcs1: ",j,n,type_p(j,n),mean_mass(j,n),v_cs(j,n)
!      endif
!    enddo

    ! output
!    do jn=1,n_all_max*L
!      n=(jn-1)/n_all_max+1
!      j=jn-(n-1)*n_all_max
    do n = 1, L
    do j = 1, n_all_max
      if(icond3(j,n)==1.and.j<=n_all(n)) then
        Qp(j,n,iacr)=alen(j,n)
        Qp(j,n,iccr)=clen(j,n)
        Qp(j,n,idcr)=dlen(j,n)
        Qp(j,n,ivcs)=v_cs(j,n)
        axr_p(j,n,1)=phi_ic(j,n)
        axr_p(j,n,2)=psi_ic(j,n)
      endif
    enddo
    enddo

  end subroutine cal_xxx_p_v5_vec

  subroutine cal_cs_spheroid3_vec(g,icond1,semi_a_i,semi_c_i,iswitch)
    use scale_prc, only: &
       PRC_abort
    use class_Ice_Shape, only: &
       get_vip, &
       get_vcs, &
       cal_semiac_ip
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate
    ! 1. semi-axis lengths of circumscribing sphere
    ! 2. axis ratio of it.
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !integer, intent(in)  :: level
    type (Group), intent(inout)  :: g
    real(PS),dimension(g%N_BIN,g%L),intent(in) :: semi_a_i,semi_c_i
    integer,dimension(g%N_BIN,g%L),intent(in)    ::  icond1
    integer, intent(in)    ::  iswitch

    ! assumption on aspect ratio
!!c    real(PS),parameter :: phi_agg=0.25_PS,mass_phi_agg=1.0e-4_PS
!!c    real(PS),parameter :: phi_agg=0.33333333333_PS,mass_phi_agg=1.0e-4_PS
    real(PS),parameter :: phi_agg=1.0/3.0, mrat_agg=10.0_PS
!!c    real(PS),parameter :: phi_grp=1.0_PS,mrat_grp=10.0_PS
    real(PS),parameter :: phi_grp=0.8_PS,mrat_grp=10.0_PS
    real(PS) :: mass_phi_agg,mass_phi_grp
    ! assumption for planar and irregular polycrystals
    real(PS),parameter :: spx_p=0.25

    real(PS), parameter         :: den_w = 1.0

    ! minimum (maximum) volume of circumscribing sphere corresponds to 1 um (10cm) radius
    real(PS),parameter :: V_csmin=4.18879020478639e-12,V_csmax=4.18879020478639e+3

    real(PS) :: m_ic,m_ag,m_rm,m_mlt,phi,V_ip,V_space,ak3!,dia
    real(PS),dimension(g%N_bin,g%L) :: mass1,phi_ic

!    integer,dimension(g%N_bin*g%L) :: ierror
    integer :: i,n

!    do in=1,g%n_bin*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

!      ierror(in)=0

 non_zero_if: if(icond1(i,n)==0) then

      m_ic=g%MS(i,n)%mass(imc)/g%MS(i,n)%con
      m_ag=g%MS(i,n)%mass(ima)/g%MS(i,n)%con
      m_rm=g%MS(i,n)%mass(imr)/g%MS(i,n)%con
      m_mlt=g%MS(i,n)%mass(imw)/g%MS(i,n)%con

      select case(g%IS(i,n)%sh_type)
      case (1)
        ! pristine crystal
        if(g%IS(i,n)%is_mod(2)==1) then
          ! assume the axis ratio is kept the same as pristine crystal inside.
          g%IS(i,n)%semi_aip=semi_a_i(i,n)
          g%IS(i,n)%semi_cip=semi_c_i(i,n)
          g%IS(i,n)%phi_cs=g%IS(i,n)%semi_cip/g%IS(i,n)%semi_aip
          g%IS(i,n)%V_cs=g%IS(i,n)%V_ic
        else
          ! ice sphere
          g%IS(i,n)%phi_cs=1.0_PS
          g%IS(i,n)%V_cs=max(V_csmin,(g%MS(i,n)%mean_mass-m_mlt)/den_i)
          call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs &
                            ,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
        endif

        V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
        V_space=max(0.0_PS,V_ip-(g%MS(i,n)%mean_mass-m_mlt)/den_i)
        ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
        g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
        g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
        g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs

      case (2)
        ! rimed crystal
        !
        if(g%IS(i,n)%habit<=3) then
          phi_ic(i,n)=g%MS(i,n)%c_len/g%MS(i,n)%a_len
        else
          phi_ic(i,n)=spx_p
        end if

        g%IS(i,n)%V_cs=max(g%IS(i,n)%V_cs,g%IS(i,n)%V_ic)

        if(iswitch==0) then

          call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,&
                             g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)

          ! this is the case of large rimed amount
          !    it is assumed that the riming increases the density hereafter
          if(phi_ic(i,n)<1.0.and.g%IS(i,n)%phi_cs>1.0) then
            g%IS(i,n)%phi_cs=1.0_PS
            g%IS(i,n)%semi_aip=semi_a_i(i,n)
            g%IS(i,n)%semi_cip=g%IS(i,n)%semi_aip

          elseif(phi_ic(i,n)>1.0.and.g%IS(i,n)%phi_cs<1.0) then
            g%IS(i,n)%phi_cs=1.0_PS
            g%IS(i,n)%semi_cip=semi_c_i(i,n)
            g%IS(i,n)%semi_aip=g%IS(i,n)%semi_cip
          endif

        else
          ! assume the same growth as in riming scheme.
          if(g%IS(i,n)%is_mod(2)==1) then
            ! cyclinder ice particle model
            if(semi_a_i(i,n)>semi_c_i(i,n)) then
              g%IS(i,n)%phi_cs=sqrt((g%IS(i,n)%V_cs/g%IS(i,n)%V_ic)**(2.0/3.0)*(1.0_PS+phi_ic(i,n)**2)-1.0_PS)
              g%IS(i,n)%semi_aip=semi_a_i(i,n)
              g%IS(i,n)%semi_cip=g%IS(i,n)%semi_aip*g%IS(i,n)%phi_cs
            elseif(semi_a_i(i,n)<semi_c_i(i,n)) then
              g%IS(i,n)%phi_cs=1.0/sqrt((g%IS(i,n)%V_cs/g%IS(i,n)%V_ic)**(2.0/3.0)&
                              *(1.0_PS+phi_ic(i,n)**(-2))-1.0_PS)
              g%IS(i,n)%semi_cip=semi_c_i(i,n)
              g%IS(i,n)%semi_aip=g%IS(i,n)%semi_cip/g%IS(i,n)%phi_cs
            else
              g%IS(i,n)%phi_cs=phi_ic(i,n)
              call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,g%IS(i,n)%semi_aip,&
                                 g%IS(i,n)%semi_cip)
            end if

            ! this is the case of large rimed amount
            !    it is assumed that the riming increases the density hereafter
            if(phi_ic(i,n)<1.0.and.g%IS(i,n)%phi_cs>1.0) then
              g%IS(i,n)%phi_cs=1.0_PS
              g%IS(i,n)%semi_aip=semi_a_i(i,n)
              g%IS(i,n)%semi_cip=g%IS(i,n)%semi_aip

            elseif(phi_ic(i,n)>1.0.and.g%IS(i,n)%phi_cs<1.0) then
              g%IS(i,n)%phi_cs=1.0_PS
              g%IS(i,n)%semi_cip=semi_c_i(i,n)
              g%IS(i,n)%semi_aip=g%IS(i,n)%semi_cip
            endif
          else
            ! ice sphere
            g%IS(i,n)%phi_cs=1.0_PS
            g%IS(i,n)%V_cs=max(V_csmin,(g%MS(i,n)%mean_mass-m_mlt)/den_i)
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,&
                               g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
          endif
        end if
        g%IS(i,n)%phi_cs=g%IS(i,n)%semi_cip/g%IS(i,n)%semi_aip

        g%IS(i,n)%V_cs=get_vcs(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)


        V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
        V_space=max(0.0_PS,V_ip-(g%MS(i,n)%mean_mass-m_mlt)/den_i)
        ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
        g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
        g%MS(i,n)%semi_a=ak3**(1.0_PS/3.0_PS)*g%IS(i,n)%semi_aip
        g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs

      case (3)
        ! 3. unrimed aggregates
        !
        g%IS(i,n)%V_cs=max(g%IS(i,n)%V_cs,g%IS(i,n)%V_ic)
        if(iswitch==1) then
          mass_phi_agg=m_ic*mrat_agg

          mass1(i,n)=m_ic+m_ag

          if(mass1(i,n)<mass_phi_agg) then
            if(g%IS(i,n)%habit<=3) then
              phi_ic(i,n)=g%MS(i,n)%c_len/g%MS(i,n)%a_len
            else
              phi_ic(i,n)=spx_p
            end if
            if(phi_agg<=0.0.or.phi_ic(i,n)<=0.0.or.m_ic<=0.0.or.&
               mass1(i,n)<=0.0_PS) then
               LOG_ERROR("cal_cs_spheroid3_vec",15) n,i,g%IS(i,n)%habit,phi_ic(i,n),m_ic,mass1(i,n)
15             format("Something is wrong in cs_spheroid_vec:",3I5,3ES15.6)
               LOG_ERROR_CONT('("alen,clen,V_cs",3ES15.6)') g%MS(i,n)%a_len,g%MS(i,n)%c_len,&
                    g%IS(i,n)%V_cs
               call PRC_abort
            end if



            phi=phi_agg*(mass1(i,n)/mass_phi_agg)**(log10(phi_agg/phi_ic(i,n))/log10(mass_phi_agg/m_ic))

          else
            phi=phi_agg
          end if
          g%IS(i,n)%phi_cs=phi
        end if

        ! assume the cylinder volume
        call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs, &
                           g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
        g%IS(i,n)%phi_cs=g%IS(i,n)%semi_cip/g%IS(i,n)%semi_aip

        ! assume the cylinder volume
        g%IS(i,n)%V_cs=get_vcs(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)


        V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
        V_space=max(0.0_PS,V_ip-(g%MS(i,n)%mean_mass-m_mlt)/den_i)
        ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
        g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
        g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
        g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs

      case (4)
        ! 4. rimed aggregates
        !
        !  assume cylinder
        !
        !  assume cylinder

        g%IS(i,n)%V_cs=max(g%IS(i,n)%V_cs,g%IS(i,n)%V_ic)
        if(iswitch==1) then
          mass_phi_agg=m_ic*mrat_agg

          mass1(i,n)=m_ic+m_ag

          if(mass1(i,n)<mass_phi_agg) then
            if(g%IS(i,n)%habit<=3) then
              phi_ic(i,n)=g%MS(i,n)%c_len/g%MS(i,n)%a_len
            else
              phi_ic(i,n)=spx_p
            end if
            if(phi_agg<=0.0_PS.or.phi_ic(i,n)<=0.0_PS.or.m_ic<=0.0_PS.or.&
               mass1(i,n)<=0.0_PS) then
               LOG_ERROR("cal_cs_spheroid3_vec",15) n,i,g%IS(i,n)%habit,phi_ic(i,n),m_ic,mass1(i,n)
               LOG_ERROR_CONT('("alen,clen,V_cs",3ES15.6)') g%MS(i,n)%a_len,g%MS(i,n)%c_len,&
                    g%IS(i,n)%V_cs
               call PRC_abort
            end if

            phi=phi_agg*(mass1(i,n)/mass_phi_agg)**(log10(phi_agg/phi_ic(i,n))/log10(mass_phi_agg/m_ic))
          else
            phi=phi_agg
          end if
          g%IS(i,n)%phi_cs=phi
        end if

        ! assume the cylinder volume
        call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,&
                           g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)

        g%IS(i,n)%phi_cs=g%IS(i,n)%semi_cip/g%IS(i,n)%semi_aip

        ! assume the cylinder volume
        g%IS(i,n)%V_cs=get_vcs(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)

        V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
        V_space=max(0.0_PS,V_ip-(g%MS(i,n)%mean_mass-m_mlt)/den_i)
        ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
        g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
        g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
        g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs

      case (5)
        ! graupel
        !
        !    assume that a spheroid is the shape of rimed aggregates.
        !

        g%IS(i,n)%V_cs=max(g%IS(i,n)%V_cs,g%IS(i,n)%V_ic)

        if(iswitch==1) then
          mass_phi_grp=(m_ic+m_ag)*mrat_grp
          mass1(i,n)=m_ic+m_ag+m_rm

          if(mass1(i,n)<mass_phi_grp) then
            if(g%IS(i,n)%habit<=3) then
              phi_ic(i,n)=g%MS(i,n)%c_len/g%MS(i,n)%a_len
            else
              phi_ic(i,n)=spx_p
            end if

            if(phi_grp<=0.0_PS.or.phi_ic(i,n)<=0.0_PS.or.m_ic<=0.0_PS.or.&
                  mass1(i,n)<=0.0_PS) then
               LOG_ERROR("cal_cs_spheroid3_vec",15) n,i,g%IS(i,n)%habit,phi_ic(i,n),m_ic,mass1(i,n)
               LOG_ERROR_CONT('("alen,clen,V_cs",3ES15.6)') g%MS(i,n)%a_len,g%MS(i,n)%c_len,&
                    g%IS(i,n)%V_cs
               call PRC_abort
            end if

            phi=phi_grp*(mass1(i,n)/mass_phi_grp)**(log10(phi_grp/phi_ic(i,n))/log10(mass_phi_grp/m_ic))
          else
            phi=phi_grp
          end if

          g%IS(i,n)%phi_cs=phi

        end if

        ! assume the spheroidal volume
        call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,&
                           g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)

        g%IS(i,n)%phi_cs=g%IS(i,n)%semi_cip/g%IS(i,n)%semi_aip

        g%IS(i,n)%V_cs=get_vcs(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)


        V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
        V_space=max(0.0_PS,V_ip-(g%MS(i,n)%mean_mass-m_mlt)/den_i)
        ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
        g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
        g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
        g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs

      case default
         LOG_ERROR("cal_cs_spheroid3_vec",*) "cal_cs_spheroid_vec: No such particle type defined",g%IS(i,n)%sh_type
         call PRC_abort
      end select

     endif non_zero_if

    enddo
    enddo

  end subroutine cal_cs_spheroid3_vec

  subroutine cal_cs_spheroid3_vec2( &
                semi_aip,semi_cip,phi_cs,V_cs,semi_a,semi_c,V_csw, &
                nbin,L,icond3,habit,sh_type, &
                alen,clen,semi_a_i,semi_c_i,V_ic,&
                mean_mass,m_ic,m_rm,m_ag,m_mlt,&
                is_mod,iswitch)
    use class_Ice_Shape, only: &
       get_vip, &
       get_vcs, &
       cal_semiac_ip
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ! calculate
    ! 1. semi-axis lengths of circumscribing sphere
    ! 2. axis ratio of it.
    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !
    integer, intent(in)    ::  nbin,L,iswitch
    integer,intent(in),dimension(mxnbin+1,*) :: icond3
    integer,dimension(mxnbin+1,*), intent(in)    ::  habit,sh_type
    real(PS),dimension(mxnbin+1,*), intent(in) :: alen,clen,V_ic,semi_a_i,semi_c_i
    real(PS),dimension(mxnbin+1,*), intent(in) :: m_ic,m_ag,m_rm,m_mlt,mean_mass
    integer,dimension(2,mxnbin+1,*), intent(in)  :: is_mod
    !
    real(PS),dimension(mxnbin+1,*), intent(inout) :: semi_aip,semi_cip,phi_cs,V_cs,semi_a,semi_c,V_csw
    !
    ! assumption on aspect ratio
!!c    real(PS),parameter :: phi_agg=0.25_PS,mass_phi_agg=1.0e-4_PS
!!c    real(PS),parameter :: phi_agg=0.33333333333_PS,mass_phi_agg=1.0e-4_PS
    real(PS),parameter :: phi_agg=1.0/3.0, mrat_agg=10.0_PS
!!c    real(PS),parameter :: phi_grp=1.0_PS,mrat_grp=10.0_PS
    real(PS),parameter :: phi_grp=0.8_PS,mrat_grp=10.0_PS
    real(PS) :: mass_phi_agg,mass_phi_grp,mass1
    ! assumption for planar and irregular polycrystals
    real(PS),parameter :: spx_p=0.25

    ! minimum (maximum) volume of circumscribing sphere corresponds to 1 um (10cm) radius
    real(PS),parameter :: V_csmin=4.18879020478639e-12,V_csmax=4.18879020478639e+3

    real(PS) :: phi_ic,phi,V_ip,V_space,ak3!,dia

!    integer, dimension((mxnbin+1)*LMAX) :: ierror

    integer :: i,n

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin

!      ierror(in)=0

 non_zero_if: if(icond3(i,n)==1) then

      select case(sh_type(i,n))
      case (1)
        ! pristine crystal
        if(is_mod(2,i,n)==1) then
          ! assume the axis ratio is kept the same as pristine crystal inside.
          semi_aip(i,n)=semi_a_i(i,n)
          semi_cip(i,n)=semi_c_i(i,n)
          phi_cs(i,n)=semi_cip(i,n)/semi_aip(i,n)
          V_cs(i,n)=V_ic(i,n)
        else
          ! ice sphere
          phi_cs(i,n)=1.0_PS
          V_cs(i,n)=max(V_csmin,(mean_mass(i,n)-m_mlt(i,n))/den_i)
          call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
        endif
        if(debug .and. V_cs(i,n)<1.0e-30_PS) then
          write(*,*) "cal_cs_spheroid_vec: v_cs error",i,n,is_mod(2,i,n),V_cs(i,n) &
            ,semi_a_i(i,n),semi_c_i(i,n),phi_cs(i,n)
        endif

        V_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
        V_space=max(0.0_PS,v_ip-(mean_mass(i,n)-m_mlt(i,n))/den_i)
        ak3=1.0_PS+max(m_mlt(i,n)/den_w-V_space,0.0_PS)/v_ip
        V_csw(i,n)=ak3*V_cs(i,n)
        semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
        semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)
      case (2)
        ! rimed crystal
        !
        if(habit(i,n)<=3) then
          phi_ic=clen(i,n)/alen(i,n)
        else
          phi_ic=spx_p
        end if

        V_cs(i,n)=max(V_cs(i,n),V_ic(i,n))

        if(iswitch==0) then
          call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))

          ! this is the case of large rimed amount
          !    it is assumed that the riming increases the density hereafter
          if(phi_ic<1.0.and.phi_cs(i,n)>1.0) then
            phi_cs(i,n)=1.0_PS
            semi_aip(i,n)=semi_a_i(i,n)
            semi_cip(i,n)=semi_aip(i,n)

          elseif(phi_ic>1.0.and.phi_cs(i,n)<1.0) then
            phi_cs(i,n)=1.0_PS
            semi_cip(i,n)=semi_c_i(i,n)
            semi_aip(i,n)=semi_cip(i,n)
          endif

        elseif(iswitch==1) then
          ! assume the same growth as in riming scheme.
          if(is_mod(2,i,n)==1) then
            ! cyclinder ice particle model
            if(semi_a_i(i,n)>semi_c_i(i,n)) then
              phi_cs(i,n)=sqrt((V_cs(i,n)/V_ic(i,n))**(2.0/3.0)*(1.0_PS+phi_ic**2)-1.0_PS)
              semi_aip(i,n)=semi_a_i(i,n)
              semi_cip(i,n)=semi_aip(i,n)*phi_cs(i,n)
            elseif(semi_a_i(i,n)<semi_c_i(i,n)) then
              phi_cs(i,n)=1.0/sqrt((V_cs(i,n)/V_ic(i,n))**(2.0/3.0)*(1.0_PS+phi_ic**(-2))-1.0_PS)
              semi_cip(i,n)=semi_c_i(i,n)
              semi_aip(i,n)=semi_cip(i,n)/phi_cs(i,n)
            else
              phi_cs(i,n)=phi_ic
              call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
            end if

            ! this is the case of large rimed amount
            !    it is assumed that the riming increases the density hereafter
            if(phi_ic<1.0.and.phi_cs(i,n)>1.0) then
              phi_cs(i,n)=1.0_PS
              semi_aip(i,n)=semi_a_i(i,n)
              semi_cip(i,n)=semi_aip(i,n)

            elseif(phi_ic>1.0.and.phi_cs(i,n)<1.0) then
              phi_cs(i,n)=1.0_PS
              semi_cip(i,n)=semi_c_i(i,n)
              semi_aip(i,n)=semi_cip(i,n)
            endif

          else
            ! ice sphere
            phi_cs(i,n)=1.0_PS
            call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
          endif
        end if
        phi_cs(i,n)=semi_cip(i,n)/semi_aip(i,n)

        V_cs(i,n)=get_vcs(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))


        v_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
        V_space=max(0.0_PS,v_ip-(mean_mass(i,n)-m_mlt(i,n))/den_i)
        ak3=1.0_PS+max(m_mlt(i,n)/den_w-V_space,0.0_PS)/v_ip
        V_csw(i,n)=ak3*V_cs(i,n)
        semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
        semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)
      case (3)
        ! 3. unrimed aggregates
        !
        V_cs(i,n)=max(V_cs(i,n),V_ic(i,n))
        if(iswitch==1) then
          mass_phi_agg=m_ic(i,n)*mrat_agg

          mass1=m_ic(i,n)+m_ag(i,n)

          if(mass1<mass_phi_agg) then
            if(habit(i,n)<=3) then
              phi_ic=clen(i,n)/alen(i,n)
            else
              phi_ic=spx_p
            end if
            if ( debug ) then
               if(phi_agg<=0.0_PS.or.phi_ic<=0.0_PS.or.m_ic(i,n)<=0.0_PS.or.&
                  mass1<=0.0_PS) then
                  write(*,15) habit(i,n),sh_type(i,n)
15                format("Something is wrong in cs_spheroid for agg:",4ES15.6)
                  write(*,'("mass1,m_ic,m_ag",8ES15.6)') mass1,m_ic(i,n),m_ag(i,n)
                  write(*,'("alen,clen,V_cs",8ES15.6)') alen(i,n),clen(i,n),v_cs(i,n)
               end if
            end if
            phi=phi_agg*(mass1/mass_phi_agg)**(log10(phi_agg/phi_ic)/log10(mass_phi_agg/m_ic(i,n)))
          else
            phi=phi_agg
          end if
          phi_cs(i,n)=phi
        end if

        ! assume the cylinder volume
        call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
        phi_cs(i,n)=semi_cip(i,n)/semi_aip(i,n)

        ! assume the cylinder volume
        V_cs(i,n)=get_vcs(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))

        v_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
        V_space=max(0.0_PS,v_ip-(mean_mass(i,n)-m_mlt(i,n))/den_i)
        ak3=1.0_PS+max(m_mlt(i,n)/den_w-V_space,0.0_PS)/v_ip
        V_csw(i,n)=ak3*V_cs(i,n)
        semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
        semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)

      case (4)
        ! 4. rimed aggregates
        !
        !  assume cylinder
        !
        !  assume cylinder

        V_cs(i,n)=max(V_cs(i,n),V_ic(i,n))
        if(iswitch==1) then
          mass_phi_agg=m_ic(i,n)*mrat_agg

          mass1=m_ic(i,n)+m_ag(i,n)

          if(mass1<mass_phi_agg) then
            if(habit(i,n)<=3) then
              phi_ic=clen(i,n)/alen(i,n)
            else
              phi_ic=spx_p
            end if
            if ( debug ) then
               if(phi_agg<=0.0_PS.or.phi_ic<=0.0_PS.or.m_ic(i,n)<=0.0_PS.or.&
                  mass1<=0.0_PS) then
                  write(*,16) habit(i,n),sh_type(i,n)
16                format("Something is wrong in cs_spheroid for rimed agg:",4ES15.6)
                  write(*,'("mass1,m_ic,m_ag",8ES15.6)') mass1,m_ic(i,n),m_ag(i,n)
                  write(*,'("alen,clen,V_cs",8ES15.6)') alen(i,n),clen(i,n),v_cs(i,n)
               end if
            end if

            phi=phi_agg*(mass1/mass_phi_agg)**(log10(phi_agg/phi_ic)/log10(mass_phi_agg/m_ic(i,n)))
          else
            phi=phi_agg
          end if
          phi_cs(i,n)=phi
        end if
        ! assume the cylinder volume
        call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))

        phi_cs(i,n)=semi_cip(i,n)/semi_aip(i,n)

        ! assume the cylinder volume
        V_cs(i,n)=get_vcs(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))

        v_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
        V_space=max(0.0_PS,v_ip-(mean_mass(i,n)-m_mlt(i,n))/den_i)
        ak3=1.0_PS+max(m_mlt(i,n)/den_w-V_space,0.0_PS)/v_ip
        V_csw(i,n)=ak3*V_cs(i,n)
        semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
        semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)

      case (5)
        ! graupel
        !
        !    assume that a spheroid is the shape of rimed aggregates.
        !
        V_cs(i,n)=max(V_cs(i,n),V_ic(i,n))

        if(iswitch==1) then
          mass_phi_grp=(m_ic(i,n)+m_ag(i,n))*mrat_grp
          mass1=m_ic(i,n)+m_ag(i,n)+m_rm(i,n)

          if(mass1<mass_phi_grp) then
            if(habit(i,n)<=3) then
              phi_ic=clen(i,n)/alen(i,n)
            else
              phi_ic=spx_p
            end if

            if ( debug ) then
               if(phi_grp<=0.0_PS.or.phi_ic<=0.0_PS.or.m_ic(i,n)<=0.0_PS.or.&
                  mass1<=0.0_PS) then
                  write(*,17) habit(i,n),sh_type(i,n)
17                format("Something is wrong in cs_spheroid for graupel:",4ES15.6)
                  write(*,'("mass1,m_ic,m_ag",8ES15.6)') mass1,m_ic(i,n),m_ag(i,n),m_rm(i,n)
                  write(*,'("alen,clen,V_cs",8ES15.6)') alen(i,n),clen(i,n),v_cs(i,n)
               end if
            end if

            phi=phi_grp*(mass1/mass_phi_grp)**(log10(phi_grp/phi_ic)/log10(mass_phi_grp/m_ic(i,n)))
          else
            phi=phi_grp
          end if

          phi_cs(i,n)=phi

        end if

        ! assume the spheroidal volume
        call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
        phi_cs(i,n)=semi_cip(i,n)/semi_aip(i,n)
        V_cs(i,n)=get_vcs(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))

        v_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
        V_space=max(0.0_PS,v_ip-(mean_mass(i,n)-m_mlt(i,n))/den_i)
        ak3=1.0_PS+max(m_mlt(i,n)/den_w-V_space,0.0_PS)/v_ip
        V_csw(i,n)=ak3*V_cs(i,n)
        semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
        semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)

      case default
         if(debug) write(*,*) "cal_cs_spheroid_vec: No such particle type defined",sh_type(i,n)
      end select

     endif non_zero_if

    enddo
    enddo

  end subroutine cal_cs_spheroid3_vec2

!!$  subroutine cal_cs_spheroid(level,alen,clen,rlen,elen,V_ic,semi_a_i,semi_c_i,habit,&
!!$       sh_type,semi_a,semi_c,phi_cs,V_cs,&
!!$       mean_mass,m_ic,m_ag)
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate 
!!$    ! 1. semi-axis lengths of circumscribing sphere
!!$    ! 2. axis ratio of it.
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    integer, intent(in)    ::  level,habit,sh_type
!!$    real(PS),intent(in) :: alen,clen,rlen,elen,V_ic,semi_a_i,semi_c_i,m_ic,m_ag,mean_mass
!!$    real(PS),intent(inout) :: semi_a,semi_c,phi_cs,V_cs
!!$    ! 4 pi /3, pi/6
!!$    real(PS),parameter :: coef4pi3=4.188790205_PS,coefpi6=0.523598776
!!$
!!$    ! assumption on aspect ratio
!!$!!c    real(PS),parameter :: phi_agg=0.25_PS,mass_phi_agg=1.0e-4_PS
!!$!!c    real(PS),parameter :: phi_agg=0.33333333333_PS,mass_phi_agg=1.0e-4_PS
!!$    real(PS),parameter :: phi_agg=0.35_PS, mrat_agg=10.0_PS
!!$!!c    real(PS),parameter :: phi_grp=1.0_PS,mrat_grp=10.0_PS
!!$    real(PS),parameter :: phi_grp=0.8_PS,mrat_grp=10.0_PS ! sense test grp=10
!!$    real(PS) :: mass_phi_agg,mass_phi_grp,mass1
!!$    ! assumption for planar and irregular polycrystals
!!$    real(PS),parameter :: spx_p=0.25
!!$
!!$
!!$    real(PS) :: phi_ic,phi,dia
!!$
!!$    select case(sh_type)
!!$    case (1)
!!$       ! pristine crystal
!!$       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$       semi_a=semi_a_i
!!$       semi_c=semi_c_i
!!$       phi_cs=semi_c/semi_a
!!$
!!$       V_cs=V_ic
!!$
!!$
!!$    case (2)
!!$       ! rimed crystal
!!$       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$       semi_a=semi_a_i
!!$       semi_c=semi_c_i
!!$       phi_cs=semi_c/semi_a
!!$
!!$       V_cs=V_ic
!!$
!!$
!!$
!!$    case (3)
!!$       ! 3. unrimed aggregates
!!$       !
!!$       !  assume cylinder
!!$
!!$       dia=10.0_PS*(V_cs/coefpi6)**(1.0/3.0)
!!$       mass_phi_agg=m_ic*mrat_agg
!!$
!!$       mass1=m_ic+m_ag
!!$
!!$       if(mass1<mass_phi_agg) then
!!$          if(habit<=3) then
!!$             phi_ic=clen/alen
!!$          else
!!$             phi_ic=spx_p
!!$          end if
!!$          if(phi_agg<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$               mass1<=0.0) then
!!$             write(*,15) phi_ic,m_ic,mass1
!!$15           format("Something is wrong in cs_spheroid for agg:",4ES15.6)
!!$             write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic
!!$             write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$             stop
!!$          end if
!!$
!!$
!!$          phi=(log10(phi_agg)-log10(phi_ic))/(log10(mass_phi_agg)-log10(m_ic))*&
!!$               (log10(mass1)-log10(mass_phi_agg))+log10(phi_agg)
!!$          phi=10.0**phi
!!$       else
!!$          phi=phi_agg
!!$       end if
!!$       phi_cs=phi
!!$
!!$       semi_a=max(dia/20.0_PS/sqrt(1.0_PS+phi_cs**2.0),semi_a_i)
!!$       semi_c=max(phi_cs*semi_a,semi_c_i)
!!$       V_cs=coef4pi3*(semi_a**2.0+semi_c**2.0)**1.5
!!$       phi_cs=semi_c/semi_a
!!$
!!$    case (4)
!!$       ! 4. rimed aggregates
!!$       !
!!$       !  assume cylinder
!!$       !
!!$       !  assume cylinder
!!$
!!$       dia=10.0_PS*(V_cs/coefpi6)**(1.0/3.0)
!!$
!!$       mass_phi_agg=m_ic*mrat_agg
!!$
!!$       mass1=m_ic+m_ag
!!$
!!$       if(mass1<mass_phi_agg) then
!!$          if(habit<=3) then
!!$             phi_ic=clen/alen
!!$          else
!!$             phi_ic=spx_p
!!$          end if
!!$          if(phi_agg<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$               mass1<=0.0) then
!!$             write(*,16) phi_ic,m_ic,mass1
!!$16           format("Something is wrong in cs_spheroid for rimed agg:",4ES15.6)
!!$             write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic
!!$             write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$             stop
!!$          end if
!!$
!!$
!!$          phi=(log10(phi_agg)-log10(phi_ic))/(log10(mass_phi_agg)-log10(m_ic))*&
!!$               (log10(mass1)-log10(mass_phi_agg))+log10(phi_agg)
!!$          phi=10.0**phi
!!$       else
!!$          phi=phi_agg
!!$       end if
!!$       phi_cs=phi
!!$
!!$       semi_a=max(dia/20.0_PS/sqrt(1.0_PS+phi_cs**2.0),semi_a_i)
!!$       semi_c=max(phi_cs*semi_a,semi_c_i)
!!$       V_cs=coef4pi3*(semi_a**2.0+semi_c**2.0)**1.5
!!$       phi_cs=semi_c/semi_a
!!$
!!$    case (5)
!!$       ! graupel
!!$       !
!!$       !    assume that a spheroid is the shape of rimed aggregates.
!!$       !
!!$       dia=10.0_PS*(V_cs/coefpi6)**(1.0/3.0) ! in mm
!!$!!c       write(*,*) "bef get phi 5"
!!$
!!$       mass_phi_grp=(m_ic+m_ag)*mrat_grp
!!$
!!$       if(mean_mass<mass_phi_grp) then
!!$          if(habit<=3) then
!!$             phi_ic=clen/alen
!!$          else
!!$             phi_ic=spx_p
!!$          end if
!!$
!!$          if(phi_grp<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$               mean_mass<=0.0) then
!!$             write(*,17) phi_ic,m_ic,mean_mass
!!$17           format("Something is wrong in cs_spheroid at graupels:",4ES15.6)
!!$             write(*,'("mean_mass,m_ic",8ES15.6)') mean_mass,m_ic
!!$             write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$             stop
!!$          end if
!!$
!!$          phi=(log10(phi_grp)-log10(phi_ic))/(log10(mass_phi_grp)-log10(m_ic))*&
!!$               (log10(mean_mass)-log10(mass_phi_grp))+log10(phi_grp)
!!$          phi=10.0**phi
!!$       else
!!$          phi=phi_grp
!!$       end if
!!$!!c       write(*,*) "aft get phi 5"
!!$
!!$       phi_cs=phi
!!$       if(phi_cs<=1.0) then
!!$          ! maximum dimension corresponds to the semi-a length
!!$          semi_a=max(dia/20.0_PS,semi_a_i)
!!$          semi_c=max(phi_cs*semi_a,semi_c_i)
!!$       else
!!$          ! maximum dimension corresponds to the semi-c length
!!$          semi_c=max(dia/20.0_PS,semi_c_i)
!!$          semi_a=max(semi_c/phi_cs,semi_a_i)
!!$       end if
!!$       V_cs=coef4pi3*max(semi_a,semi_c)**3.0
!!$       phi_cs=semi_c/semi_a
!!$
!!$    case default
!!$       write(*,*) "ERROR! cal_cs_sheroid."
!!$       stop
!!$    end select
!!$  end subroutine cal_cs_spheroid
!!$
!!$  subroutine cal_cs_spheroid2(level,alen,clen,rlen,elen,V_ic,semi_a_i,semi_c_i,habit,&
!!$       sh_type,semi_aip,semi_cip,phi_cs,V_cs,&
!!$       semi_a,semi_c,V_csw,&
!!$       mean_mass,m_ic,m_ag,m_mlt,&
!!$       is_mod,iswitch)
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate 
!!$    ! 1. semi-axis lengths of circumscribing sphere
!!$    ! 2. axis ratio of it.
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    integer, intent(in)    ::  level,habit,sh_type,iswitch
!!$    real(PS),intent(in) :: alen,clen,rlen,elen,V_ic,semi_a_i,semi_c_i,m_ic,m_ag,m_mlt,mean_mass
!!$    real(PS),intent(inout) :: semi_aip,semi_cip,phi_cs,V_cs,semi_a,semi_c,V_csw
!!$    integer,dimension(2) :: is_mod
!!$
!!$    ! assumption on aspect ratio
!!$!!c    real(PS),parameter :: phi_agg=0.25_PS,mass_phi_agg=1.0e-4_PS
!!$!!c    real(PS),parameter :: phi_agg=0.33333333333_PS,mass_phi_agg=1.0e-4_PS
!!$    real(PS),parameter :: phi_agg=0.35_PS, mrat_agg=10.0_PS
!!$!!c    real(PS),parameter :: phi_grp=1.0_PS,mrat_grp=10.0_PS
!!$    real(PS),parameter :: phi_grp=0.8_PS,mrat_grp=10.0_PS ! sense test grp=10
!!$    real(PS) :: mass_phi_agg,mass_phi_grp,mass1
!!$    ! assumption for planar and irregular polycrystals
!!$    real(PS),parameter :: spx_p=0.25
!!$
!!$    real(PS) :: phi_ic,phi,dia,V_ip,V_space,ak3
!!$
!!$    select case(sh_type)
!!$    case (1)
!!$       ! pristine crystal
!!$       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$       semi_aip=semi_a_i
!!$       semi_cip=semi_c_i
!!$       phi_cs=semi_cip/semi_aip
!!$       V_cs=V_ic
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (2)
!!$       ! rimed crystal
!!$       !
!!$       V_cs=max(V_cs,V_ic)
!!$       if(iswitch==0) then
!!$          ! assume the cylinder volume
!!$!!c          semi_aip=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0)
!!$!!c          semi_cip=semi_aip*phi_cs
!!$          call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$       elseif(iswitch==1) then
!!$          ! assume the same growth as in riming scheme.
!!$          if(habit<=3) then
!!$             phi_ic=clen/alen
!!$          else
!!$             phi_ic=spx_p
!!$          end if
!!$
!!$          if(semi_a_i>semi_c_i) then
!!$             if(is_mod(2)==1) then
!!$                phi_cs=sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**2)-1.0_PS)
!!$             elseif(is_mod(2)==2) then
!!$                phi_cs=phi_ic*(V_cs/V_ic)
!!$             end if
!!$             semi_aip=semi_a_i
!!$             semi_cip=semi_aip*phi_cs
!!$          elseif(semi_a_i<semi_c_i) then
!!$             if(is_mod(2)==1) then
!!$                phi_cs=1.0/sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**(-2))-1.0_PS)
!!$             elseif(is_mod(2)==2) then
!!$                phi_cs=phi_ic*sqrt(V_ic/V_cs)
!!$             end if
!!$             semi_cip=semi_c_i
!!$             semi_aip=semi_cip/phi_cs
!!$          else
!!$             phi_cs=phi_ic
!!$             call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$          end if
!!$
!!$!!c          if(semi_a_i>semi_c_i) then
!!$!!c             phi_cs=sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**2)-1.0_PS)
!!$!!c             semi_aip=semi_a_i
!!$!!c             semi_cip=semi_aip*phi_cs
!!$!!c          elseif(semi_a_i<semi_c_i) then
!!$!!c             phi_cs=1.0/sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**(-2))-1.0_PS)
!!$!!c             semi_cip=semi_c_i
!!$!!c             semi_aip=semi_cip/phi_cs
!!$!!c          else
!!$!!c             phi_cs=phi_ic
!!$!!c             ! assume the cylinder volume
!!$!!c             semi_aip=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0)
!!$!!c             semi_cip=semi_aip*phi_cs
!!$!!c          end if
!!$
!!$!!c
!!$!!c       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$!!c       semi_aip=semi_a_i
!!$!!c       semi_cip=semi_c_i
!!$!!c       phi_cs=semi_cip/semi_aip
!!$!!c       V_cs=V_ic
!!$       end if
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$       ! assume the cylinder volume
!!$!!c       v_cs=coef4pi3*semi_aip**3.0*(1.0_PS+phi_cs**2.0)**1.5
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (3)
!!$       ! 3. unrimed aggregates
!!$       !
!!$       V_cs=max(V_cs,V_ic)
!!$       if(iswitch==1) then
!!$          mass_phi_agg=m_ic*mrat_agg
!!$          
!!$          mass1=m_ic+m_ag
!!$          
!!$          if(mass1<mass_phi_agg) then
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             if(phi_agg<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$                  mass1<=0.0) then
!!$                write(*,15) phi_ic,m_ic,mass1
!!$15              format("Something is wrong in cs_spheroid for agg:",4ES15.6)
!!$                write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic
!!$                write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$                stop
!!$             end if
!!$             
!!$             
!!$             phi=(log10(phi_agg)-log10(phi_ic))/(log10(mass_phi_agg)-log10(m_ic))*&
!!$                  (log10(mass1)-log10(mass_phi_agg))+log10(phi_agg)
!!$             phi=10.0**phi
!!$          else
!!$             phi=phi_agg
!!$          end if
!!$          phi_cs=phi
!!$       end if
!!$
!!$       ! assume the cylinder volume
!!$!!c       semi_aip=max(semi_a_i,(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0))
!!$!!c       semi_cip=max(semi_c_i,semi_aip*phi_cs)
!!$       call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$       ! assume the cylinder volume
!!$!!c       v_cs=coef4pi3*semi_aip**3.0*(1.0_PS+phi_cs**2.0)**1.5
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (4)
!!$       ! 4. rimed aggregates
!!$       !
!!$       !  assume cylinder
!!$       !
!!$       !  assume cylinder
!!$
!!$       V_cs=max(V_cs,V_ic)
!!$       if(iswitch==1) then
!!$          mass_phi_agg=m_ic*mrat_agg
!!$          
!!$          mass1=m_ic+m_ag
!!$          
!!$          if(mass1<mass_phi_agg) then
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             if(phi_agg<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$                  mass1<=0.0) then
!!$                write(*,16) phi_ic,m_ic,mass1
!!$16              format("Something is wrong in cs_spheroid for rimed agg:",4ES15.6)
!!$                write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic
!!$                write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$                stop
!!$             end if
!!$             
!!$             
!!$             phi=(log10(phi_agg)-log10(phi_ic))/(log10(mass_phi_agg)-log10(m_ic))*&
!!$                  (log10(mass1)-log10(mass_phi_agg))+log10(phi_agg)
!!$             phi=10.0**phi
!!$          else
!!$             phi=phi_agg
!!$          end if
!!$          phi_cs=phi
!!$       end if
!!$
!!$       ! assume the cylinder volume
!!$!!c       semi_aip=max(semi_a_i,(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0))
!!$!!c       semi_cip=max(semi_c_i,semi_aip*phi_cs)
!!$
!!$       call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$       ! assume the cylinder volume
!!$!!c       v_cs=coef4pi3*semi_aip**3.0*(1.0_PS+phi_cs**2.0)**1.5
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (5)
!!$       ! graupel
!!$       !
!!$       !    assume that a spheroid is the shape of rimed aggregates.
!!$       !
!!$
!!$       V_cs=max(V_cs,V_ic)
!!$!!c       write(*,*) "bef get phi 5"
!!$
!!$       if(iswitch==1) then          
!!$          mass_phi_grp=(m_ic+m_ag)*mrat_grp
!!$          
!!$          if(mean_mass<mass_phi_grp) then
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             
!!$             if(phi_grp<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$                  mean_mass<=0.0) then
!!$                write(*,17) phi_ic,m_ic,mean_mass
!!$17              format("Something is wrong in cs_spheroid at graupels:",4ES15.6)
!!$                write(*,'("mean_mass,m_ic",8ES15.6)') mean_mass,m_ic
!!$                write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$                stop
!!$             end if
!!$             
!!$             phi=(log10(phi_grp)-log10(phi_ic))/(log10(mass_phi_grp)-log10(m_ic))*&
!!$                  (log10(mean_mass)-log10(mass_phi_grp))+log10(phi_grp)
!!$             phi=10.0**phi
!!$          else
!!$             phi=phi_grp
!!$          end if
!!$!!c       write(*,*) "aft get phi 5"
!!$
!!$          phi_cs=phi
!!$
!!$       end if
!!$
!!$       ! assume the spheroidal volume
!!$!!c       if(phi_cs<1.0) then
!!$!!c          semi_aip=max(semi_a_i,(V_cs/coef4pi3)**(1.0/3.0))
!!$!!c          semi_cip=max(semi_c_i,semi_aip*phi_cs)
!!$!!c       else
!!$!!c          semi_cip=max(semi_c_i,(V_cs/coef4pi3)**(1.0/3.0))
!!$!!c          semi_aip=max(semi_a_i,semi_cip/phi_cs)
!!$!!c       end if
!!$
!!$       call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$!!c       ! assume the spheroidal volume
!!$!!c       if(phi_cs<1.0_PS) then
!!$!!c          v_cs=coef4pi3*semi_aip**3.0
!!$!!c       else
!!$!!c          v_cs=coef4pi3*(semi_aip*phi_cs)**3.0
!!$!!c       end if
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$!!c       V_ip=coef4pi3*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$
!!$
!!$    case default
!!$       write(*,*) "ERROR! cal_cs_sheroid."
!!$       stop
!!$    end select
!!$  end subroutine cal_cs_spheroid2
!!$
!!$  subroutine cal_cs_spheroid3(level,alen,clen,rlen,elen,V_ic,&
!!$       semi_a_i,semi_c_i,habit,&
!!$       sh_type,semi_aip,semi_cip,phi_cs,V_cs,&
!!$       semi_a,semi_c,V_csw,&
!!$       mean_mass,m_ic,m_ag,&
!!$       m_rm,m_mlt,&
!!$       is_mod,iswitch)
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate 
!!$    ! 1. semi-axis lengths of circumscribing sphere
!!$    ! 2. axis ratio of it.
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    integer, intent(in)    ::  level,habit,sh_type,iswitch
!!$    real(PS),intent(in) :: alen,clen,rlen,elen,V_ic,semi_a_i,semi_c_i,m_ic,m_ag,m_rm,m_mlt,mean_mass
!!$    real(PS),intent(inout) :: semi_aip,semi_cip,phi_cs,V_cs,semi_a,semi_c,V_csw
!!$    integer,dimension(2) :: is_mod
!!$
!!$    ! assumption on aspect ratio
!!$!!c    real(PS),parameter :: phi_agg=0.25_PS,mass_phi_agg=1.0e-4_PS
!!$!!c    real(PS),parameter :: phi_agg=0.33333333333_PS,mass_phi_agg=1.0e-4_PS
!!$    real(PS),parameter :: phi_agg=1.0/3.0, mrat_agg=10.0_PS
!!$!!c    real(PS),parameter :: phi_grp=1.0_PS,mrat_grp=10.0_PS
!!$    real(PS),parameter :: phi_grp=0.8_PS,mrat_grp=10.0_PS ! sense test grp=10
!!$    real(PS) :: mass_phi_agg,mass_phi_grp,mass1
!!$    ! assumption for planar and irregular polycrystals
!!$    real(PS),parameter :: spx_p=0.25
!!$
!!$    ! minimum (maximum) volume of circumscribing sphere corresponds to 1 um (10cm) radius
!!$    real(PS),parameter :: V_csmin=4.18879020478639e-12,V_csmax=4.18879020478639e+3
!!$
!!$    real(PS) :: phi_ic,phi,dia,V_ip,V_space,ak3
!!$
!!$    select case(sh_type)
!!$    case (1)
!!$       ! pristine crystal
!!$       if(is_mod(2)==1) then
!!$          ! assume the axis ratio is kept the same as pristine crystal inside.
!!$          semi_aip=semi_a_i
!!$          semi_cip=semi_c_i
!!$          phi_cs=semi_cip/semi_aip
!!$          V_cs=V_ic
!!$       else
!!$          ! ice sphere
!!$          phi_cs=1.0_PS
!!$          V_cs=max(V_csmin,(mean_mass-m_mlt)/den_i)
!!$          call cal_semiac_ip(is_mod(2),phi_cs,V_cs,semi_aip,semi_cip)
!!$       endif
!!$
!!$!!c          V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (2)
!!$       ! rimed crystal
!!$       !
!!$       V_cs=max(V_cs,V_ic)
!!$       if(iswitch==0) then
!!$          ! assume the cylinder volume
!!$!!c          semi_aip=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0)
!!$!!c          semi_cip=semi_aip*phi_cs
!!$          call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$       elseif(iswitch==1) then
!!$          ! assume the same growth as in riming scheme.
!!$          if(is_mod(2)==1) then
!!$             ! cyclinder ice particle model
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             if(semi_a_i>semi_c_i) then
!!$                phi_cs=sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**2)-1.0_PS)
!!$                semi_aip=semi_a_i
!!$                semi_cip=semi_aip*phi_cs
!!$             elseif(semi_a_i<semi_c_i) then
!!$                phi_cs=1.0/sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**(-2))-1.0_PS)
!!$                semi_cip=semi_c_i
!!$                semi_aip=semi_cip/phi_cs
!!$             else
!!$                phi_cs=phi_ic
!!$                call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$             end if
!!$          else
!!$             ! ice sphere
!!$             phi_cs=1.0_PS
!!$             call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$          endif
!!$!!c          if(semi_a_i>semi_c_i) then
!!$!!c             phi_cs=sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**2)-1.0_PS)
!!$!!c             semi_aip=semi_a_i
!!$!!c             semi_cip=semi_aip*phi_cs
!!$!!c          elseif(semi_a_i<semi_c_i) then
!!$!!c             phi_cs=1.0/sqrt((V_cs/V_ic)**(2.0/3.0)*(1.0_PS+phi_ic**(-2))-1.0_PS)
!!$!!c             semi_cip=semi_c_i
!!$!!c             semi_aip=semi_cip/phi_cs
!!$!!c          else
!!$!!c             phi_cs=phi_ic
!!$!!c             ! assume the cylinder volume
!!$!!c             semi_aip=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0)
!!$!!c             semi_cip=semi_aip*phi_cs
!!$!!c          end if
!!$
!!$!!c
!!$!!c       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$!!c       semi_aip=semi_a_i
!!$!!c       semi_cip=semi_c_i
!!$!!c       phi_cs=semi_cip/semi_aip
!!$!!c       V_cs=V_ic
!!$       end if
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$       ! assume the cylinder volume
!!$!!c       v_cs=coef4pi3*semi_aip**3.0*(1.0_PS+phi_cs**2.0)**1.5
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (3)
!!$       ! 3. unrimed aggregates
!!$       !
!!$       V_cs=max(V_cs,V_ic)
!!$       if(iswitch==1) then
!!$          mass_phi_agg=m_ic*mrat_agg
!!$          
!!$          mass1=m_ic+m_ag
!!$          
!!$          if(mass1<mass_phi_agg) then
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             if(phi_agg<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$                  mass1<=0.0) then
!!$                write(*,15) phi_ic,m_ic,mass1
!!$15              format("Something is wrong in cs_spheroid for agg:",4ES15.6)
!!$                write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic
!!$                write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$                stop
!!$             end if
!!$             
!!$             
!!$!!c             phi=(log10(phi_agg)-log10(phi_ic))/(log10(mass_phi_agg)-log10(m_ic))*&
!!$!!c                  (log10(mass1)-log10(mass_phi_agg))+log10(phi_agg)
!!$!!c             phi=10.0**phi
!!$
!!$             phi=phi_agg*(mass1/mass_phi_agg)**(log10(phi_agg/phi_ic)/log10(mass_phi_agg/m_ic))
!!$
!!$          else
!!$             phi=phi_agg
!!$          end if
!!$          phi_cs=phi
!!$       end if
!!$
!!$       ! assume the cylinder volume
!!$!!c       semi_aip=max(semi_a_i,(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0))
!!$!!c       semi_cip=max(semi_c_i,semi_aip*phi_cs)
!!$       call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$       ! assume the cylinder volume
!!$!!c       v_cs=coef4pi3*semi_aip**3.0*(1.0_PS+phi_cs**2.0)**1.5
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (4)
!!$       ! 4. rimed aggregates
!!$       !
!!$       !  assume cylinder
!!$       !
!!$       !  assume cylinder
!!$
!!$       V_cs=max(V_cs,V_ic)
!!$       if(iswitch==1) then
!!$          mass_phi_agg=m_ic*mrat_agg
!!$          
!!$          mass1=m_ic+m_ag
!!$          
!!$          if(mass1<mass_phi_agg) then
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             if(phi_agg<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$                  mass1<=0.0) then
!!$                write(*,16) phi_ic,m_ic,mass1
!!$16              format("Something is wrong in cs_spheroid for rimed agg:",4ES15.6)
!!$                write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic
!!$                write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$                stop
!!$             end if
!!$             
!!$             
!!$!!c             phi=(log10(phi_agg)-log10(phi_ic))/(log10(mass_phi_agg)-log10(m_ic))*&
!!$!!c                  (log10(mass1)-log10(mass_phi_agg))+log10(phi_agg)
!!$!!c             phi=10.0**phi
!!$
!!$             phi=phi_agg*(mass1/mass_phi_agg)**(log10(phi_agg/phi_ic)/log10(mass_phi_agg/m_ic))
!!$          else
!!$             phi=phi_agg
!!$          end if
!!$          phi_cs=phi
!!$       end if
!!$
!!$       ! assume the cylinder volume
!!$!!c       semi_aip=max(semi_a_i,(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0))
!!$!!c       semi_cip=max(semi_c_i,semi_aip*phi_cs)
!!$
!!$       call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$       ! assume the cylinder volume
!!$!!c       v_cs=coef4pi3*semi_aip**3.0*(1.0_PS+phi_cs**2.0)**1.5
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$
!!$!!c       V_ip=coef2p*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$    case (5)
!!$       ! graupel
!!$       !
!!$       !    assume that a spheroid is the shape of rimed aggregates.
!!$       !
!!$
!!$       V_cs=max(V_cs,V_ic)
!!$!!c       write(*,*) "bef get phi 5"
!!$
!!$       if(iswitch==1) then          
!!$          mass_phi_grp=(m_ic+m_ag)*mrat_grp
!!$          mass1=m_ic+m_ag+m_rm
!!$          
!!$          if(mass1<mass_phi_grp) then
!!$             if(habit<=3) then
!!$                phi_ic=clen/alen
!!$             else
!!$                phi_ic=spx_p
!!$             end if
!!$             
!!$             if(phi_grp<=0.0.or.phi_ic<=0.0.or.m_ic<=0.0.or.&
!!$                  mass1<=0.0) then
!!$                write(*,17) phi_ic,m_ic,mass1
!!$17              format("Something is wrong in cs_spheroid at graupels:",4ES15.6)
!!$                write(*,'("mass1,m_ic",8ES15.6)') mass1,m_ic,m_ag,m_rm
!!$                write(*,'("alen,clen,v_cs",8ES15.6)') alen,clen
!!$                stop
!!$             end if
!!$             
!!$!!c             phi=(log10(phi_grp)-log10(phi_ic))/(log10(mass_phi_grp)-log10(m_ic))*&
!!$!!c                  (log10(mass1)-log10(mass_phi_grp))+log10(phi_grp)
!!$!!c             phi=10.0**phi
!!$             phi=phi_grp*(mass1/mass_phi_grp)**(log10(phi_grp/phi_ic)/log10(mass_phi_grp/m_ic))
!!$          else
!!$             phi=phi_grp
!!$          end if
!!$!!c       write(*,*) "aft get phi 5"
!!$
!!$          phi_cs=phi
!!$
!!$       end if
!!$
!!$       ! assume the spheroidal volume
!!$!!c       if(phi_cs<1.0) then
!!$!!c          semi_aip=max(semi_a_i,(V_cs/coef4pi3)**(1.0/3.0))
!!$!!c          semi_cip=max(semi_c_i,semi_aip*phi_cs)
!!$!!c       else
!!$!!c          semi_cip=max(semi_c_i,(V_cs/coef4pi3)**(1.0/3.0))
!!$!!c          semi_aip=max(semi_a_i,semi_cip/phi_cs)
!!$!!c       end if
!!$
!!$       call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$!!c       semi_aip=max(semi_aip,semi_a_i)
!!$!!c       semi_cip=max(semi_cip,semi_c_i)
!!$
!!$       phi_cs=semi_cip/semi_aip
!!$
!!$!!c       ! assume the spheroidal volume
!!$!!c       if(phi_cs<1.0_PS) then
!!$!!c          v_cs=coef4pi3*semi_aip**3.0
!!$!!c       else
!!$!!c          v_cs=coef4pi3*(semi_aip*phi_cs)**3.0
!!$!!c       end if
!!$       V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$
!!$
!!$!!c       V_ip=coef4pi3*phi_cs*semi_aip**3.0
!!$       V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$       V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$       ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$       V_csw=ak3*V_cs
!!$       semi_a=ak3**(1.0/3.0)*semi_aip
!!$       semi_c=semi_a*phi_cs
!!$!!c
!!$!!c       semi_a=semi_aip
!!$!!c       semi_c=semi_cip
!!$!!c       V_csw=V_cs
!!$
!!$
!!$
!!$    case default
!!$       write(*,*) "ERROR! cal_cs_sheroid."
!!$       stop
!!$    end select
!!$  end subroutine cal_cs_spheroid3
!!$
!!$
!!$  subroutine cal_cs_sphere(ms, is, level)
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate 
!!$    ! 1. semi-axis lengths of circumscribing sphere
!!$    ! 2. axis ratio of it.
!!$    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    type (Mass_Bin), intent(inout)   :: ms
!!$    type (Ice_Shape), intent(inout)    :: is
!!$    integer, intent(in)    ::  level
!!$    real(PS)               :: dia
!!$    !     m = a * dia^b
!!$    ! mass in mg, diameter in mm
!!$    real(PS)               :: a, b
!!$    real(PS)               :: phi,max_ice,min_ice,phi_ic
!!$    ! minimum mass for fragments to be aggregates or rimed aggrates
!!$    real(PS),parameter :: min_mass=1.0e-5_PS,den_max=0.758088258_PS
!!$
!!$    real(PS),parameter :: phi_agg=0.25_PS,mass_phi_agg=1.0e-4_PS
!!$    real(PS),parameter :: phi_grp=0.7_PS,mass_phi_grp=1.0e-3_PS
!!$    ! Matson and Huggins (1980)'s meadian of hail stones
!!$!!c    real(PS),parameter :: phi_grp=0.77_PS,mass_phi_grp=0.479972525615449
!!$
!!$
!!$    real(PS),parameter :: phi_re=0.25_PS
!!$    real(PS),parameter :: den_a=0.3_PS
!!$
!!$
!!$    select case(is%sh_type)
!!$    case (1)
!!$       ! pristine crystal
!!$       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$       if(is%habit<=3) then
!!$          ms%semi_a=ms%a_len
!!$          ms%semi_c=ms%c_len
!!$          is%phi_cs = ms%semi_c/ms%semi_a
!!$       elseif(is%habit>=4) then
!!$          ms%semi_a=max(is%r,is%e)
!!$          is%phi_cs=0.25_PS
!!$          ms%semi_c=ms%semi_a*is%phi_cs
!!$       end if
!!$    case (2)
!!$       ! rimed crystal
!!$       ! assume the axis ratio is kept the same as pristine crystal inside.
!!$       if(is%habit<=3) then
!!$          ms%semi_a=ms%a_len
!!$          ms%semi_c=ms%c_len
!!$          is%phi_cs = ms%semi_c/ms%semi_a
!!$       elseif(is%habit>=4) then
!!$          ms%semi_a=max(is%r,is%e)
!!$          is%phi_cs=0.25_PS
!!$          ms%semi_c=ms%semi_a*is%phi_cs
!!$       end if
!!$
!!$    case (3)
!!$       ! 3. unrimed aggregates
!!$       !
!!$       !    assume that a cylinder is the shape of aggregates.
!!$       !
!!$       dia=(is%V_cs/coefpi6)**(1.0/3.0)
!!$       is%phi_cs=1.0_PS
!!$
!!$       ms%semi_a=dia/2.0_PS
!!$       ms%semi_c=ms%semi_a
!!$    case (4)
!!$       ! 4. rimed aggregates
!!$       !
!!$       !    assume that a spheroid is the shape of rimed aggregates.
!!$       !
!!$       dia=(is%V_cs/coefpi6)**(1.0/3.0)
!!$       is%phi_cs=1.0_PS
!!$
!!$       ms%semi_a=dia/2.0_PS
!!$       ms%semi_c=ms%semi_a
!!$    case (5)
!!$       ! graupel
!!$       !
!!$       !    assume that a spheroid is the shape of rimed aggregates.
!!$       !
!!$       dia=(is%V_cs/coefpi6)**(1.0/3.0)
!!$       is%phi_cs=1.0_PS
!!$
!!$       ms%semi_a=dia/2.0_PS
!!$       ms%semi_c=ms%semi_a
!!$    case (6)
!!$       ! hail
!!$       ! assume that the axis ratio is 1.
!!$       dia=(is%V_cs/coefpi6)**(1.0/3.0)
!!$       is%phi_cs=1.0_PS
!!$
!!$       ms%semi_a=dia/2.0_PS
!!$       ms%semi_c=ms%semi_a
!!$    case default
!!$       write(*,*) "ERROR! cal_cs_sheroid."
!!$       stop
!!$    end select
!!$
!!$    ! +++ bound the semi_a, and semi_c estimates +++
!!$!!c    if(is%habit<=3) then
!!$!!c       min_ice=min(ms%a_len,ms%c_len)
!!$!!c       max_ice=max(ms%a_len,ms%c_len)
!!$!!c    else
!!$!!c       min_ice=max(is%r,is%e)
!!$!!c       max_ice=max(is%r,is%e)
!!$!!c    end if
!!$!!c    if(ms%semi_a>=ms%semi_c) then
!!$!!c       ms%semi_a=max(max_ice,ms%semi_a)
!!$!!c       ms%semi_c=max(min_ice,ms%semi_c)
!!$!!c    else
!!$!!c       ms%semi_c=max(max_ice,ms%semi_c)
!!$!!c       ms%semi_a=max(min_ice,ms%semi_a)
!!$!!c    end if
!!$!!c    is%phi_cs=ms%semi_c/ms%semi_a
!!$!!c
!!$!!c    is%V_cs=4.188790205_PS*((1.0+is%phi_cs**2.0)**1.5)*ms%semi_a**3.0
!!$
!!$  end subroutine cal_cs_sphere

  subroutine cal_bulk_density3_vec(g,icond1,iswitch,iswitch_grp)
    use class_Ice_Shape, only: &
       get_vip, &
       cal_semiac_ip, &
       cal_halfmaxdim_ip
    !integer, intent(in)  :: level
    type (Group), intent(inout)  :: g
    integer, intent(in)    ::  iswitch,iswitch_grp
    integer,dimension(g%N_BIN,g%L),intent(in)    ::  icond1
    !character (len=*) :: from

    real(PS) :: den_max,v_ic_hex,v_space,v_ip,ak3,m_dry!, phi_cs_max

    ! assume that the possible minimum density is 1.0e-4
    real(PS),parameter :: den_min=1.0e-4
    ! assume that the possible minimum density of hex ice crystal is 1.0e-4
    ! The hex column with dendritic arms (phi=20, psi=0.9) can reach
    ! 0.0002832.
    real(PS),parameter :: den_min_hex=1.0e-4

    ! fraction of maximum possible ice-water mixture
    real(PS),parameter :: fdenmx=0.9999

    real(PS) :: m_ic,m_rim,m_agg,m_mlt

    ! assumption for planar and irregular polycrystals
    real(PS),parameter :: spx_p=0.25
    real(PS) :: phi_ic1,xlen
    real(PS) :: V_cs_c1,semi_aip_c1,semi_cip_c1
    real(PS) :: V_cs_c2,semi_aip_c2,semi_cip_c2

    integer :: ierror,ierror2
!    integer,dimension(g%N_bin,g%L) :: ierror,ierror2,ierror3
    integer :: i_denip_gt_denmax,i_den_gt_denmax,i_denip_lt_denmin
    integer :: i,n,em

!    do in=1,g%n_bin*g%L
!      n=(in-1)/g%N_BIN+1
!      i=in-(n-1)*g%N_BIN
    do n = 1, g%L
    do i = 1, g%N_BIN

      ierror=0
      ierror2=0
!      ierror3(i,n)=0

 non_zero_if: if(icond1(i,n)==0) then

      m_ic=g%MS(i,n)%mass(imc)/g%MS(i,n)%con
      m_rim=g%MS(i,n)%mass(imr)/g%MS(i,n)%con
      m_agg=g%MS(i,n)%mass(ima)/g%MS(i,n)%con
      m_mlt=g%MS(i,n)%mass(imw)/g%MS(i,n)%con



      ! 1. calculate bulk crystal density
      ! pristine crystal and rimed crystals
      v_ic_hex=coef4pi3*(g%MS(i,n)%a_len**2+g%MS(i,n)%c_len**2)**1.5_PS
      g%IS(i,n)%den_ic=m_ic/v_ic_hex

      ! maximum possible bulk sphere density of pristine hexagonal crystal
      den_max=coef3sq3*g%IS(i,n)%phi_ic*den_i*(1.0-g%IS(i,n)%psi_ic)/&
            (coef4pi3*(1.0_PS+g%IS(i,n)%phi_ic**2.0_PS)**1.5_PS)

      if(debug .and. den_max<1.0e-30_PS) then
         write(*,*) "bulk_density3_vec: small density:",i,n,den_max,g%IS(i,n)%phi_ic,g%IS(i,n)%psi_ic,g%MS(i,n)%a_len,&
             g%MS(i,n)%c_len,g%MS(I,n)%con,g%MS(i,n)%mass(1:4)
      endif
      if(g%IS(i,n)%den_ic/den_max-1.0>0.1_PS) then

        g%IS(i,n)%den_ic=den_max
        V_ic_hex=m_ic/den_max

        g%MS(i,n)%a_len=(V_ic_hex/coef4pi3)**(1.0_PS/3.0_PS)/sqrt(1.0+g%IS(i,n)%phi_ic**2)
        g%MS(i,n)%c_len=g%MS(i,n)%a_len*g%IS(i,n)%phi_ic
        g%IS(i,n)%d=g%MS(i,n)%a_len*g%IS(i,n)%psi_ic

        ierror=1
      end if
      if(g%IS(i,n)%den_ic<den_min_hex) then
        g%IS(i,n)%den_ic=den_min_hex
        V_ic_hex=m_ic/den_min_hex

        g%MS(i,n)%a_len=(V_ic_hex/coef4pi3)**(1.0_PS/3.0_PS)/sqrt(1.0_PS+g%IS(i,n)%phi_ic**2)
        g%MS(i,n)%c_len=g%MS(i,n)%a_len*g%IS(i,n)%phi_ic
        g%IS(i,n)%d=g%MS(i,n)%a_len*g%IS(i,n)%psi_ic

        ierror=1
      end if

      ! 2. calculate bulk sphere density for dry ice particle and wet ice particle
      ierror2=0
      m_dry=m_ic+m_agg+m_rim
      select case(g%IS(i,n)%sh_type)
      case(1,2)

        g%IS(i,n)%den_ip=m_dry/g%IS(i,n)%V_cs

        if(g%IS(i,n)%is_mod(2)==1) then
          if(g%IS(i,n)%habit<=3) then

            if(ierror==1) then
              g%IS(i,n)%semi_aip=g%MS(i,n)%a_len
              g%IS(i,n)%semi_cip=g%MS(i,n)%c_len
              g%IS(i,n)%phi_cs=g%IS(i,n)%semi_cip/g%IS(i,n)%semi_aip
              g%IS(i,n)%V_ic=V_ic_hex
              g%IS(i,n)%V_cs=V_ic_hex

              g%IS(i,n)%den_ip=m_dry/g%IS(i,n)%V_cs

              V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
              V_space=max(0.0_PS,V_ip-(g%MS(i,n)%mean_mass-m_mlt)/den_i)
              ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
              g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs

            end if
          else

            if(g%IS(i,n)%den_ip>=den_i) then
              !
              ! assume it is sphere
              ! this may happen because the empirical equation used for these g%IS(i,n)%habits
              ! can produce density more than den_i in small range.
              !
              g%IS(i,n)%V_ic=m_dry/den_i
              g%IS(i,n)%V_cs=g%IS(i,n)%V_ic
              g%IS(i,n)%den_ip=den_i

              g%IS(i,n)%semi_aip=(g%IS(i,n)%V_cs/coef4pi3)**(1.0/3.0)
              g%IS(i,n)%semi_cip=g%IS(i,n)%semi_aip
              g%IS(i,n)%phi_cs=1.0_PS

              if(g%IS(i,n)%habit==4) then
                g%IS(i,n)%r=g%IS(i,n)%semi_aip
              elseif(g%IS(i,n)%habit==5) then
                g%IS(i,n)%e=g%IS(i,n)%semi_aip
              elseif(g%IS(i,n)%habit==6) then
                g%IS(i,n)%e=g%IS(i,n)%semi_aip
                g%IS(i,n)%r=g%IS(i,n)%e
              end if

!tmp              write(*,'("cal_bulk_density:error 1_2, a_len,c_len,g%IS(i,n)%d,m_ic,m_mlt",10ES15.6)') &
!tmp                         g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%d,m_ic,m_mlt,g%MS(i,n)%mean_mass,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip
              g%IS(i,n)%is_mod(1)=2
              g%IS(i,n)%is_mod(2)=2
            endif
          endif
        elseif(g%IS(i,n)%is_mod(2)==2) then
          if(g%IS(i,n)%den_ip*0.9999>den_i) then
            !
            ! assume it is sphere
            !
            g%IS(i,n)%V_cs=m_dry/den_i
            g%IS(i,n)%den_ip=den_i

            g%IS(i,n)%semi_aip=(g%IS(i,n)%V_cs/coef4pi3)**(1.0/3.0)
            g%IS(i,n)%semi_cip=g%IS(i,n)%semi_aip
            g%IS(i,n)%phi_cs=1.0_PS

          endif
        endif

        if(g%IS(i,n)%habit<=3) then
          phi_ic1=g%IS(i,n)%phi_ic
        else
          phi_ic1=spx_p
        endif

        if(g%IS(i,n)%is_mod(2)==1) then
          den_max=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_i
        elseif(g%IS(i,n)%is_mod(2)==2) then
          den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_i
        end if
        V_cs_c1=m_dry/den_max
        V_cs_c2=m_dry/den_min

        call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,V_cs_c1,semi_aip_c1,semi_cip_c1)
        call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,V_cs_c2,semi_aip_c2,semi_cip_c2)

        g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw

        if(iswitch==1) then

          ! check if the density is larger than the maximum value
          i_denip_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(g%IS(i,n)%den_ip-den_max)))

          ! check if the density is smaller than the minimum value
          i_denip_lt_denmin=0.5*(1.0-sign(1.0_PS,(g%IS(i,n)%den_ip-den_min)-(-1.0e-4_PS*den_min)))

          em=1*i_denip_gt_denmax+&
             2*(1-i_denip_gt_denmax)*i_denip_lt_denmin
          ! note: the minimum value condition was previously only applied for rimed particles

          ierror2=max(ierror2,em)

          if(em==1) then
            g%IS(i,n)%V_cs=V_cs_c1
            g%IS(i,n)%semi_aip=semi_aip_c1
            g%IS(i,n)%semi_cip=semi_cip_c1
            g%IS(i,n)%den_ip=den_max

          elseif(em==2) then
            g%IS(i,n)%V_cs=V_cs_c2
            g%IS(i,n)%semi_aip=semi_aip_c2
            g%IS(i,n)%semi_cip=semi_cip_c2
            g%IS(i,n)%den_ip=den_min

          endif

          if(em>0) then
            if(g%IS(i,n)%sh_type==2) then
              ! case of rimed crystals
              if(phi_ic1<1.0) then
                g%IS(i,n)%V_ic=g%IS(i,n)%V_cs*((1.0_PS+phi_ic1*phi_ic1)/(1.0_PS+g%IS(i,n)%phi_cs*g%IS(i,n)%phi_cs))**1.5
              else
                g%IS(i,n)%V_ic=g%IS(i,n)%V_cs*((1.0_PS+1.0_PS/phi_ic1/phi_ic1)/&
                    (1.0_PS+1.0_PS/g%IS(i,n)%phi_cs/g%IS(i,n)%phi_cs))**1.5
              endif
              xlen=(g%IS(i,n)%V_ic/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic1*phi_ic1)

              select case(g%IS(i,n)%habit)
              case(4)
                g%IS(i,n)%r=xlen
              case(5)
                g%IS(i,n)%e=xlen
              case(6)
                g%IS(i,n)%r=xlen
                g%IS(i,n)%e=xlen
              end select

              if(g%MS(i,n)%a_len>g%MS(i,n)%c_len) then
                g%MS(i,n)%a_len=min(xlen,g%MS(i,n)%a_len)
                g%MS(i,n)%c_len=g%MS(i,n)%a_len*g%IS(i,n)%phi_ic
              else
                g%MS(i,n)%c_len=min(xlen,g%MS(i,n)%c_len)
                g%MS(i,n)%a_len=g%MS(i,n)%c_len/g%IS(i,n)%phi_ic
              endif

              g%IS(i,n)%d=g%MS(i,n)%a_len*g%IS(i,n)%psi_ic

!!c              if(i.eq.8.and.n.eq.60) then
!!c                write(*,*) "error2-2:",i,n,em,g%MS(i,n)%a_len,g%MS(i,n)%c_len,g%IS(i,n)%den_ip,den_min,&
!!c                     g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip
!!c              endif
            else
              ! case of pristine crystals
              g%MS(i,n)%a_len=(g%IS(i,n)%V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0+g%IS(i,n)%phi_ic**2.0)
              g%MS(i,n)%c_len=g%MS(i,n)%a_len*g%IS(i,n)%phi_ic
              g%IS(i,n)%d=g%MS(i,n)%a_len*g%IS(i,n)%psi_ic

              select case(g%IS(i,n)%habit)
              case(4)
                g%IS(i,n)%r=g%IS(i,n)%semi_aip
              case(5)
                g%IS(i,n)%e=g%IS(i,n)%semi_aip
              case(6)
                g%IS(i,n)%r=g%IS(i,n)%semi_aip
                g%IS(i,n)%e=g%IS(i,n)%semi_aip
              end select
              g%IS(i,n)%V_ic=g%IS(i,n)%V_cs
            end if
          end if

          ! for total ice particle model
          if(g%IS(i,n)%is_mod(2)==1) then
            den_max=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_w*fdenmx
          elseif(g%IS(i,n)%is_mod(2)==2) then
            den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_w*fdenmx
          end if
!org          call den_ck3

          if(ierror2>0) then
            V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
            V_space=max(0.0_PS,V_ip-m_dry/den_i)
            ak3=1.0_PS+max(m_mlt-V_space*den_w,0.0_PS)/V_ip
            g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
            g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
            g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs
            g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
          endif

          ! check if the density is larger than the maximum value
!org          call den_ck4(em)
          i_den_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(g%MS(i,n)%den-den_max)))
          em=i_den_gt_denmax
          if(em>0) then
            g%IS(i,n)%V_csw=g%MS(i,n)%mean_mass/den_max
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_csw,g%MS(i,n)%semi_a,g%MS(i,n)%semi_c)
            g%MS(i,n)%den=den_max
          endif
        end if

      case(3,4)

        g%IS(i,n)%den_ip=m_dry/g%IS(i,n)%V_cs
        if(iswitch==1) then
          if(g%IS(i,n)%is_mod(2)==1) then
            den_max=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_i
          elseif(g%IS(i,n)%is_mod(2)==2) then
            den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_i
          end if

          ! check if the density is larger than the maximum value
!org          call den_ck1(em)
          i_denip_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(g%IS(i,n)%den_ip-den_max)))
          em=i_denip_gt_denmax
          ierror2=max(ierror2,i_denip_gt_denmax)
          if(em==1) then
            g%IS(i,n)%V_cs=m_dry/den_max
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
            g%IS(i,n)%den_ip=den_max
          endif

          ! check if the density is smaller than the minimum value
!org          call den_ck2(em)
          i_denip_lt_denmin=0.5*(1.0-sign(1.0_PS,(g%IS(i,n)%den_ip-den_min)-(-1.0e-4_PS*den_min)))
          em=i_denip_lt_denmin
          ierror2=max(ierror2,i_denip_lt_denmin)
          if(em==1) then
            g%IS(i,n)%V_cs=m_dry/den_min
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
            g%IS(i,n)%den_ip=den_min

            call cal_halfmaxdim_ip(xlen,g%IS(i,n)%is_mod(2),g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
            if(g%IS(i,n)%phi_ic<1.0) then
              g%MS(i,n)%a_len=min(xlen,g%MS(i,n)%a_len)
              g%MS(i,n)%c_len=g%IS(i,n)%phi_ic*g%MS(i,n)%a_len
            else
              g%MS(i,n)%c_len=min(xlen,g%MS(i,n)%c_len)
              g%MS(i,n)%a_len=g%MS(i,n)%c_len/g%IS(i,n)%phi_ic
            endif
            g%IS(i,n)%d=g%MS(i,n)%a_len*g%IS(i,n)%psi_ic
            g%IS(i,n)%V_ic=coef4pi3*g%MS(i,n)%a_len**3.0*(1.0_PS+g%IS(i,n)%phi_ic**2.0)**1.5
          endif
        end if

        g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
        if(iswitch==1) then
          if(g%IS(i,n)%is_mod(2)==1) then
            den_max=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_w*fdenmx
          elseif(g%IS(i,n)%is_mod(2)==2) then
            den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_w*fdenmx
          end if
!org          call den_ck3
          if(ierror2==1) then
            V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
            V_space=max(0.0_PS,V_ip-m_dry/den_i)
            ak3=1.0_PS+max(m_mlt-V_space*den_w,0.0_PS)/V_ip
            g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
            g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
            g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs
            g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
          endif

          ! check if the density is larger than the maximum value
!org          call den_ck4(em)
          i_den_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(g%MS(i,n)%den-den_max)))
          em=i_den_gt_denmax
          if(em>0) then
            g%IS(i,n)%V_csw=g%MS(i,n)%mean_mass/den_max
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_csw,g%MS(i,n)%semi_a,g%MS(i,n)%semi_c)
            g%MS(i,n)%den=den_max
          endif
        end if

      case default
        ! for graupel

        g%IS(i,n)%den_ip=m_dry/g%IS(i,n)%V_cs
        if(iswitch==1) then

          if(iswitch_grp==1) then
            ! This is because the aspect ratio is accurately not predicted by _rim5, so that
            ! den_max is not really correct.
            if(g%IS(i,n)%is_mod(2)==1) then
              den_max=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_i
            elseif(g%IS(i,n)%is_mod(2)==2) then
              den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_i
            end if
!org            call den_ck1(em)
            i_denip_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(g%IS(i,n)%den_ip-den_max)))
            em=i_denip_gt_denmax
            ierror2=max(ierror2,i_denip_gt_denmax)
            if(em==1) then
              g%IS(i,n)%V_cs=m_dry/den_max
              call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
              g%IS(i,n)%den_ip=den_max
            endif
          end if
!org          call den_ck2(em)
          i_denip_lt_denmin=0.5*(1.0-sign(1.0_PS,(g%IS(i,n)%den_ip-den_min)-(-1.0e-4_PS*den_min)))
          em=i_denip_lt_denmin
          ierror2=max(ierror2,i_denip_lt_denmin)
          if(em==1) then
            g%IS(i,n)%V_cs=m_dry/den_min
            call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_cs,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
            g%IS(i,n)%den_ip=den_min

            call cal_halfmaxdim_ip(xlen,g%IS(i,n)%is_mod(2),g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip)
            if(g%IS(i,n)%phi_ic<1.0) then
              g%MS(i,n)%a_len=min(xlen,g%MS(i,n)%a_len)
              g%MS(i,n)%c_len=g%IS(i,n)%phi_ic*g%MS(i,n)%a_len
            else
              g%MS(i,n)%c_len=min(xlen,g%MS(i,n)%c_len)
              g%MS(i,n)%a_len=g%MS(i,n)%c_len/g%IS(i,n)%phi_ic
            endif
            g%IS(i,n)%d=g%MS(i,n)%a_len*g%IS(i,n)%psi_ic
            g%IS(i,n)%V_ic=coef4pi3*g%MS(i,n)%a_len**3.0*(1.0_PS+g%IS(i,n)%phi_ic**2.0)**1.5
          endif
        end if

        g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
        if(iswitch==1) then
!org          call den_ck3
          if(ierror2==1) then
            V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
            V_space=max(0.0_PS,V_ip-m_dry/den_i)
            ak3=1.0_PS+max(m_mlt-V_space*den_w,0.0_PS)/V_ip
            g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
            g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
            g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs
            g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
          endif
          if(iswitch_grp==1) then
            if(g%IS(i,n)%is_mod(2)==1) then
              den_max=1.5_PS*g%IS(i,n)%phi_cs/(1.0_PS+g%IS(i,n)%phi_cs**2)**1.5*den_w*fdenmx
            else
              den_max=min(g%IS(i,n)%phi_cs,g%IS(i,n)%phi_cs**(-2))*den_w*fdenmx
            end if
!org            call den_ck4(em)
            i_den_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(g%MS(i,n)%den-den_max)))
            em=i_den_gt_denmax
            if(em>0) then
              g%IS(i,n)%V_csw=g%MS(i,n)%mean_mass/den_max
              call cal_semiac_ip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%V_csw,g%MS(i,n)%semi_a,g%MS(i,n)%semi_c)
              g%MS(i,n)%den=den_max
            endif
          end if
        end if
      end select

     end if non_zero_if
    enddo
    enddo

!!$   contains

!!$    subroutine den_ck1(em)
!!$      integer :: em
!!$      em=0
!!$      if(g%IS(i,n)%den_ip-den_max>1.0e-4*den_max) then
!!$!!c      if(g%IS(i,n)%den_ip>den_max) then
!!$!!c         write(*,*) from,g%IS(i,n)%habit,g%IS(i,n)%sh_type
!!$!!c         write(*,'("cal_bulk_density:error 1, bf, semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$
!!$         em=1
!!$         ierror2(in)=1
!!$!!c         write(*,'("cal_bulk_density:error 1, af, semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$      end if
!!$    end subroutine den_ck1

!!$    subroutine den_ck2(em)
!!$      integer :: em
!!$      em=0
!!$!!c      if(g%IS(i,n)%den_ip<den_min) then
!!$      if(g%IS(i,n)%den_ip-den_min<-1.0e-4*den_min) then
!!$!!c         write(*,*) from,g%IS(i,n)%habit,g%IS(i,n)%sh_type
!!$!!c         write(*,'("cal_bulk_density:error 2, bf, semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$
!!$         em=1
!!$         ierror2(in)=1
!!$!!c         write(*,'("cal_bulk_density:error 2, af, semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$      end if
!!$    end subroutine den_ck2

!!$    subroutine den_ck3
!!$      if(ierror2(in)==1) then
!!$!!c      if(den>den_w.or.ierror2==1) then
!!$!!c         write(*,*) from,g%IS(i,n)%habit,g%IS(i,n)%sh_type
!!$!!c         write(*,'("cal_bulk_density:error 3, bf, semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$!!c         end if
!!$
!!$         V_ip=get_vip(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
!!$         V_space=max(0.0_PS,V_ip-m_dry/den_i)
!!$         ak3=1.0_PS+max(m_mlt-V_space*den_w,0.0_PS)/V_ip
!!$         g%IS(i,n)%V_csw=ak3*g%IS(i,n)%V_cs
!!$         g%MS(i,n)%semi_a=ak3**(1.0/3.0)*g%IS(i,n)%semi_aip
!!$         g%MS(i,n)%semi_c=g%MS(i,n)%semi_a*g%IS(i,n)%phi_cs
!!$         g%MS(i,n)%den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
!!$!!c         write(*,'("cal_bulk_density:error 3, af, semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$      end if
!!$    end subroutine den_ck3

!!$    subroutine den_ck4(em)
!!$      integer :: em
!!$      em=0
!!$      if(g%MS(i,n)%den-den_max>1.0e-4*den_max) then
!!$!!c         write(*,*) from,g%IS(i,n)%habit,g%IS(i,n)%sh_type
!!$!!c         write(*,'("cal_bulk_density:error 4, bf, semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$
!!$         em=1
!!$
!!$!!c         write(*,'("cal_bulk_density:error 4, af, semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw",20ES15.6)') semi_a,semi_c,den,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%den_ip,g%MS(i,n)%mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,g%IS(i,n)%V_cs,g%IS(i,n)%V_csw
!!$
!!$!!c         if(V_space>1.0e-6) then
!!$!!c         ! increase V_ip to make V_space to hold the water, then some of the melt water has to be decreased.
!!$!!c         den_ism=m_dry/V_ip
!!$!!c         if(g%MS(i,n)%mean_mass<=m_mlt.or.den_ism-den_i>den_i*1.0e-4) then
!!$!!c            write(*,*) "den_ck4>woops",g%MS(i,n)%mean_mass,m_mlt,den_ism,V_ip
!!$!!c         end if
!!$!!c
!!$!!c         dV_ip=(g%MS(i,n)%mean_mass/den_i+(1.0_PS/den_w-1.0_PS/den_i)*m_mlt-V_ip)/&
!!$!!c                     ((1.0_PS/den_w-1.0_PS/den_i)*den_ism+1.0_PS)
!!$!!c         if(dV_ip<=0.0_PS) then
!!$!!c            write(*,*) "den_ck4>something not right:",V_ip,dV_ip,g%MS(i,n)%mean_mass,m_mlt,den_ism,g%IS(i,n)%semi_aip,g%IS(i,n)%semi_cip,g%IS(i,n)%phi_cs
!!$!!c!!c            stop
!!$!!c            return
!!$!!c         end if
!!$!!c         m_mlt=m_mlt-den_ism*dV_ip
!!$!!c         m_rim=m_rim+den_ism*dV_ip
!!$!!c
!!$!!c         V_ip=V_ip+dV_ip
!!$!!c         g%IS(i,n)%semi_aip=(V_ip/get_coef_ip(g%IS(i,n)%is_mod(2))/g%IS(i,n)%phi_cs)**(1.0/3.0)
!!$!!c         g%IS(i,n)%semi_cip=g%IS(i,n)%semi_aip*g%IS(i,n)%phi_cs
!!$!!c         g%IS(i,n)%V_cs=get_vcs(g%IS(i,n)%is_mod(2),g%IS(i,n)%phi_cs,g%IS(i,n)%semi_aip)
!!$!!c         g%IS(i,n)%V_csw=g%IS(i,n)%V_cs
!!$!!c         semi_a=g%IS(i,n)%semi_aip
!!$!!c         semi_c=g%IS(i,n)%semi_cip
!!$!!c         end if
!!$!!c         den=g%MS(i,n)%mean_mass/g%IS(i,n)%V_csw
!!$!!c         if(g%IS(i,n)%habit/=6) then
!!$!!c         end if
!!$!!c         if(den>den_w) then
!!$!!c            write(*,*) "cal_bulk_density>something is wrong:",den,semi_a,semi_c,g%IS(i,n)%V_csw,V_ip,V_space,ak3,m_mlt
!!$!!c         end if
!!$      end if
!!$    end subroutine den_ck4

  end subroutine cal_bulk_density3_vec

  subroutine cal_bulk_density3_vec2( &
       den,den_ip,den_ic, &
       alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
       semi_aip,semi_cip,phi_cs,v_cs,semi_a,semi_c,v_csw, &
       nbin,L,icond3,habit,sh_type, &
       mean_mass,m_ic,m_rm,m_ag,m_mlt,&
       is_mod,iswitch,iswitch_grp)
    use class_Ice_Shape, only: &
       get_vip, &
       get_vcs, &
       cal_semiac_ip, &
       cal_halfmaxdim_ip
    use mod_amps_utility, only: &
       acos_m
    !
    integer, intent(in)    ::  nbin,L,iswitch,iswitch_grp
    integer,intent(in),dimension(mxnbin+1,*) :: icond3
    integer,dimension(mxnbin+1,*), intent(in)    ::  habit,sh_type
    real(PS),dimension(mxnbin+1,*), intent(in) :: m_ic,m_ag,m_rm,m_mlt,mean_mass
    !
    real(PS),dimension(mxnbin+1,*), intent(inout) :: den,den_ip,den_ic
    real(PS),dimension(mxnbin+1,*), intent(inout) :: alen,clen,dlen,rlen,elen, &
            phi_ic,psi_ic,v_ic,&
            semi_aip,semi_cip,phi_cs,v_cs,semi_a,semi_c,v_csw
    integer,dimension(2,mxnbin+1,*), intent(inout)  :: is_mod
    !character (len=*) :: from
    !
    real(PS) :: den_max,v_ic_hex,v_space,v_ip,ak3,m_dry!, phi_cs_max

    ! assume that the possible minimum density is 1.0e-4
    real(PS),parameter :: den_min=1.0e-4
    ! assume that the possible minimum density of hex ice crystal is 1.0e-4
    ! The hex column with dendritic arms (phi=20, psi=0.9) can reach
    ! 0.0002832.
    real(PS),parameter :: den_min_hex=1.0e-4

    ! fraction of maximum possible ice-water mixture
    real(PS),parameter :: fdenmx=0.9999

    ! assumption for planar and irregular polycrystals
    real(PS),parameter :: spx_p=0.25
    real(PS) :: phi_ic1,xlen
    real(PS) :: V_cs_c1,semi_aip_c1,semi_cip_c1
    real(PS) :: V_cs_c2,semi_aip_c2,semi_cip_c2
    !
!!!    integer,dimension((mxnbin+1)*LMAX) :: ierror1,ierror2
    integer :: ierror1,ierror2
!    integer,dimension((mxnbin+1)*LMAX) :: ierror3
    integer :: i_denip_gt_denmax,i_den_gt_denmax,i_denip_lt_denmin
    integer :: i,n,em

!    do in=1,nbin*L
!      n=(in-1)/nbin+1
!      i=in-(n-1)*nbin
    do n = 1, L
    do i = 1, nbin

!      ierror3(in)=0

 non_zero_if: if(icond3(i,n)==1) then

      ierror1=0
      ierror2=0

      ! 1. calculate bulk crystal density
      ! pristine crystal and rimed crystals
      v_ic_hex=coef4pi3*(alen(i,n)**2+clen(i,n)**2)**1.5
      den_ic(i,n)=m_ic(i,n)/v_ic_hex

      ! maximum possible bulk sphere density of pristine hexagonal crystal
      den_max=coef3sq3*phi_ic(i,n)*den_i*(1.0-psi_ic(i,n))/&
            (coef4pi3*(1.0+phi_ic(i,n)**2.0)**1.5)

!!!      write(*,*) "ck den_max0:",i,n,den_max,phi_ic(i,n),psi_ic(i,n)

      if(den_ic(i,n)/den_max-1.0>0.1) then

        den_ic(i,n)=den_max
        V_ic_hex=m_ic(i,n)/den_max

        alen(i,n)=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic(i,n)**2.0)
        clen(i,n)=alen(i,n)*phi_ic(i,n)
        dlen(i,n)=alen(i,n)*psi_ic(i,n)

        ierror1=1
      end if
      if(den_ic(i,n)<den_min_hex) then
        den_ic(i,n)=den_min_hex
        V_ic_hex=m_ic(i,n)/den_min_hex

        alen(i,n)=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic(i,n)**2.0)
        clen(i,n)=alen(i,n)*phi_ic(i,n)
        dlen(i,n)=alen(i,n)*psi_ic(i,n)

        ierror1=1
      end if

      ! 2. calculate bulk sphere density for dry ice particle and wet ice particle
      ierror2=0

      m_dry=m_ic(i,n)+m_ag(i,n)+m_rm(i,n)
      select case(sh_type(i,n))
      case(1,2)

        den_ip(i,n)=m_dry/V_cs(i,n)
        if(debug .and. V_cs(i,n)<1.0e-30_PS) then
          write(*,*) "density3_vec2: V_cs<1.0e-30",i,n,sh_type(i,n),habit(i,n) &
                   ,ierror1,is_mod(2,i,n),V_cs(i,n),m_ic(i,n),alen(i,n),clen(i,n),v_ic(i,n)
        endif

        if(is_mod(2,i,n)==1) then
          if(habit(i,n)<=3) then
            if(ierror1==1) then
              semi_aip(i,n)=alen(i,n)
              semi_cip(i,n)=clen(i,n)
              phi_cs(i,n)=semi_cip(i,n)/semi_aip(i,n)
              v_ic(i,n)=V_ic_hex
              V_cs(i,n)=V_ic_hex

              den_ip(i,n)=m_dry/V_cs(i,n)

              V_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
              V_space=max(0.0_PS,V_ip-(mean_mass(i,n)-m_mlt(i,n))/den_i)
              ak3=1.0_PS+max(m_mlt(i,n)/den_w-V_space,0.0_PS)/V_ip
              V_csw(i,n)=ak3*V_cs(i,n)

            end if
          else
            if(den_ip(i,n)>=den_i) then
              !
              ! assume it is sphere
              ! this may happen because the empirical equation used for these habits
              ! can produce density more than den_i in small range.
              !
              v_ic(i,n)=m_dry/den_i
              V_cs(i,n)=v_ic(i,n)
              den_ip(i,n)=den_i

              semi_aip(i,n)=(V_cs(i,n)/coef4pi3)**(1.0/3.0)
              semi_cip(i,n)=semi_aip(i,n)
              phi_cs(i,n)=1.0_PS

              if(habit(i,n)==4) then
                rlen(i,n)=semi_aip(i,n)
              elseif(habit(i,n)==5) then
                elen(i,n)=semi_aip(i,n)
              elseif(habit(i,n)==6) then
                elen(i,n)=semi_aip(i,n)
                rlen(i,n)=elen(i,n)
              end if

!tmp              write(*,'("cal_bulk_density:error 1_2, a_len,c_len,dlen,m_ic,m_mlt",10ES15.6)') &
!tmp                         alen,clen,dlen,m_ic,m_mlt,mean_mass,semi_aip,semi_cip
              is_mod(1,i,n)=2
              is_mod(2,i,n)=2
            endif
          endif
        else
          !if(is_mod(2,i,n)==2) then
          if(den_ip(i,n)*0.9999_PS>den_i) then
            !
            ! assume it is sphere
            !
            V_cs(i,n)=m_dry/den_i
            den_ip(i,n)=den_i

            semi_aip(i,n)=(V_cs(i,n)/coef4pi3)**(1.0/3.0)
            semi_cip(i,n)=semi_aip(i,n)
            phi_cs(i,n)=1.0_PS

          endif
        endif

        if(habit(i,n)<=3) then
          phi_ic1=phi_ic(i,n)
        else
          phi_ic1=spx_p
        endif

        if(is_mod(2,i,n)==1) then
          den_max=1.5_PS*phi_cs(i,n)/(1.0_PS+phi_cs(i,n)**2)**1.5*den_i
        elseif(is_mod(2,i,n)==2) then
          den_max=min(phi_cs(i,n),phi_cs(i,n)**(-2))*den_i
        end if
        V_cs_c1=m_dry/den_max
        V_cs_c2=m_dry/den_min

        call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs_c1,semi_aip_c1,semi_cip_c1)
        call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs_c2,semi_aip_c2,semi_cip_c2)

        den(i,n)=mean_mass(i,n)/V_csw(i,n)

        if(iswitch==1) then

          ! check if the density is larger than the maximum value
          i_denip_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(den_ip(i,n)-den_max)))

          ! check if the density is smaller than the minimum value
          i_denip_lt_denmin=0.5*(1.0-sign(1.0_PS,(den_ip(i,n)-den_min)-(-1.0e-4_PS*den_min)))

          em=1*i_denip_gt_denmax+&
             2*(1-i_denip_gt_denmax)*i_denip_lt_denmin
          ! note: the minimum value condition was previously only applied for rimed particles

          ierror2=max(ierror2,em)

          if(em==1) then
            V_cs(i,n)=V_cs_c1
            semi_aip(i,n)=semi_aip_c1
            semi_cip(i,n)=semi_cip_c1
            den_ip(i,n)=den_max

          elseif(em==2) then
            V_cs(i,n)=V_cs_c2
            semi_aip(i,n)=semi_aip_c2
            semi_cip(i,n)=semi_cip_c2
            den_ip(i,n)=den_min

          endif

          if(em>0) then
            if(sh_type(i,n)==2) then
              ! case of rimed crystals
              if(phi_ic1<1.0) then
                V_ic(i,n)=V_cs(i,n)*((1.0_PS+phi_ic1*phi_ic1)/(1.0_PS+phi_cs(i,n)*phi_cs(i,n)))**1.5
              else
                V_ic(i,n)=V_cs(i,n)*((1.0_PS+1.0_PS/phi_ic1/phi_ic1)/&
                    (1.0_PS+1.0_PS/phi_cs(i,n)/phi_cs(i,n)))**1.5
              endif
              xlen=(V_ic(i,n)/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic1*phi_ic1)

              select case(habit(i,n))
              case(4)
                rlen(i,n)=xlen
              case(5)
                elen(i,n)=xlen
              case(6)
                rlen(i,n)=xlen
                elen(i,n)=xlen
              end select

              if(alen(i,n)>clen(i,n)) then
                alen(i,n)=min(xlen,alen(i,n))
                clen(i,n)=alen(i,n)*phi_ic(i,n)
              else
                clen(i,n)=min(xlen,clen(i,n))
                alen(i,n)=clen(i,n)/phi_ic(i,n)
              endif

              dlen(i,n)=alen(i,n)*psi_ic(i,n)

            else
              ! case of pristine crystals
              alen(i,n)=(V_cs(i,n)/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic(i,n)**2.0)
              clen(i,n)=alen(i,n)*phi_ic(i,n)
              dlen(i,n)=alen(i,n)*psi_ic(i,n)

              select case(habit(i,n))
              case(4)
                rlen(i,n)=semi_aip(i,n)
              case(5)
                elen(i,n)=semi_aip(i,n)
              case(6)
                rlen(i,n)=semi_aip(i,n)
                elen(i,n)=semi_aip(i,n)
              end select
              V_ic(i,n)=V_cs(i,n)
            end if
          end if

          ! for total ice particle model
          if(is_mod(2,i,n)==1) then
            den_max=1.5_PS*phi_cs(i,n)/(1.0_PS+phi_cs(i,n)**2)**1.5*den_w*fdenmx
          elseif(is_mod(2,i,n)==2) then
            den_max=min(phi_cs(i,n),phi_cs(i,n)**(-2))*den_w*fdenmx
          end if
!org          call den_ck3

          if(ierror2>0) then
            V_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
            V_space=max(0.0_PS,V_ip-m_dry/den_i)
            ak3=1.0_PS+max(m_mlt(i,n)-V_space*den_w,0.0_PS)/V_ip
            V_csw(i,n)=ak3*V_cs(i,n)
            semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
            semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)
            den(i,n)=mean_mass(i,n)/V_csw(i,n)
          endif

          ! check if the density is larger than the maximum value
!org          call den_ck4(em)
          i_den_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(den(i,n)-den_max)))
          em=i_den_gt_denmax
          if(em>0) then
            V_csw(i,n)=mean_mass(i,n)/den_max
            call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_csw(i,n),semi_a(i,n),semi_c(i,n))
            den(i,n)=den_max
          endif
        end if

      case(3,4)

        den_ip(i,n)=m_dry/V_cs(i,n)
        if(iswitch==1) then
          if(is_mod(2,i,n)==1) then
            den_max=1.5_PS*phi_cs(i,n)/(1.0_PS+phi_cs(i,n)**2)**1.5*den_i
          else   !  if(is_mod(2,i,n)==2) then
            den_max=min(phi_cs(i,n),phi_cs(i,n)**(-2))*den_i
          end if

          ! check if the density is larger than the maximum value
!org          call den_ck1(em)
          i_denip_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(den_ip(i,n)-den_max)))
          em=i_denip_gt_denmax
          ierror2=max(ierror2,i_denip_gt_denmax)
          if(em==1) then
            V_cs(i,n)=m_dry/den_max
            call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
            den_ip(i,n)=den_max
          endif

          ! check if the density is smaller than the minimum value
!org          call den_ck2(em)
          i_denip_lt_denmin=0.5*(1.0-sign(1.0_PS,(den_ip(i,n)-den_min)-(-1.0e-4_PS*den_min)))
          em=i_denip_lt_denmin
          ierror2=max(ierror2,i_denip_lt_denmin)
          if(em==1) then
            V_cs(i,n)=m_dry/den_min
            call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
            den_ip(i,n)=den_min

            call cal_halfmaxdim_ip(xlen,is_mod(2,i,n),semi_aip(i,n),semi_cip(i,n))
            if(phi_ic(i,n)<1.0) then
              alen(i,n)=min(xlen,alen(i,n))
              clen(i,n)=phi_ic(i,n)*alen(i,n)
            else
              clen(i,n)=min(xlen,clen(i,n))
              alen(i,n)=clen(i,n)/phi_ic(i,n)
            endif
            dlen(i,n)=alen(i,n)*psi_ic(i,n)
            v_ic(i,n)=coef4pi3*alen(i,n)**3.0*(1.0_PS+phi_ic(i,n)**2.0)**1.5
          endif
        end if

        den(i,n)=mean_mass(i,n)/V_csw(i,n)
        if(iswitch==1) then
          if(is_mod(2,i,n)==1) then
            den_max=1.5_PS*phi_cs(i,n)/(1.0_PS+phi_cs(i,n)**2)**1.5*den_w*fdenmx
          else   !  if(is_mod(2,i,n)==2) then
            den_max=min(phi_cs(i,n),phi_cs(i,n)**(-2))*den_w*fdenmx
          end if
!org          call den_ck3
          if(ierror2==1) then
            V_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
            V_space=max(0.0_PS,V_ip-m_dry/den_i)
            ak3=1.0_PS+max(m_mlt(i,n)-V_space*den_w,0.0_PS)/V_ip
            V_csw(i,n)=ak3*V_cs(i,n)
            semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
            semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)
            den(i,n)=mean_mass(i,n)/V_csw(i,n)
          endif

          ! check if the density is larger than the maximum value
!org          call den_ck4(em)
          i_den_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(den(i,n)-den_max)))
          em=i_den_gt_denmax
          if(em>0) then
            V_csw(i,n)=mean_mass(i,n)/den_max
            call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_csw(i,n),semi_a(i,n),semi_c(i,n))
            den(i,n)=den_max
          endif
        end if

      case default
        ! for graupel

        den_ip(i,n)=m_dry/V_cs(i,n)
        if(iswitch==1) then

          if(iswitch_grp==1) then
            ! This is because the aspect ratio is accurately not predicted by _rim5, so that
            ! den_max is not really correct.
            if(is_mod(2,i,n)==1) then
              den_max=1.5_PS*phi_cs(i,n)/(1.0_PS+phi_cs(i,n)**2)**1.5*den_i
            else  ! if(is_mod(2,i,n)==2) then
              den_max=min(phi_cs(i,n),phi_cs(i,n)**(-2))*den_i
            end if
!org            call den_ck1(em)
            i_denip_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(den_ip(i,n)-den_max)))
            em=i_denip_gt_denmax
            ierror2=max(ierror2,i_denip_gt_denmax)
            if(em==1) then
              V_cs(i,n)=m_dry/den_max
              call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
              den_ip(i,n)=den_max
            endif
          end if
!org          call den_ck2(em)
          i_denip_lt_denmin=0.5*(1.0-sign(1.0_PS,(den_ip(i,n)-den_min)-(-1.0e-4_PS*den_min)))
          em=i_denip_lt_denmin
          ierror2=max(ierror2,i_denip_lt_denmin)
          if(em==1) then
            V_cs(i,n)=m_dry/den_min
            call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_cs(i,n),semi_aip(i,n),semi_cip(i,n))
            den_ip(i,n)=den_min

            call cal_halfmaxdim_ip(xlen,is_mod(2,i,n),semi_aip(i,n),semi_cip(i,n))
            if(phi_ic(i,n)<1.0) then
              alen(i,n)=min(xlen,alen(i,n))
              clen(i,n)=phi_ic(i,n)*alen(i,n)
            else
              clen(i,n)=min(xlen,clen(i,n))
              alen(i,n)=clen(i,n)/phi_ic(i,n)
            endif
            dlen(i,n)=alen(i,n)*psi_ic(i,n)
            v_ic(i,n)=coef4pi3*alen(i,n)**3.0*(1.0_PS+phi_ic(i,n)**2.0)**1.5
          endif
        end if

        den(i,n)=mean_mass(i,n)/V_csw(i,n)
        if(iswitch==1) then
!org          call den_ck3
          if(ierror2==1) then
            V_ip=get_vip(is_mod(2,i,n),phi_cs(i,n),semi_aip(i,n))
            V_space=max(0.0_PS,V_ip-m_dry/den_i)
            ak3=1.0_PS+max(m_mlt(i,n)-V_space*den_w,0.0_PS)/V_ip
            V_csw(i,n)=ak3*V_cs(i,n)
            semi_a(i,n)=ak3**(1.0/3.0)*semi_aip(i,n)
            semi_c(i,n)=semi_a(i,n)*phi_cs(i,n)
            den(i,n)=mean_mass(i,n)/V_csw(i,n)
          endif
          if(iswitch_grp==1) then
            if(is_mod(2,i,n)==1) then
              den_max=1.5_PS*phi_cs(i,n)/(1.0_PS+phi_cs(i,n)**2)**1.5*den_w*fdenmx
            else
              den_max=min(phi_cs(i,n),phi_cs(i,n)**(-2))*den_w*fdenmx
            end if
!org            call den_ck4(em)
            i_den_gt_denmax=0.5*(1.0-sign(1.0_PS,1.0e-4_PS*den_max-(den(i,n)-den_max)))
            em=i_den_gt_denmax
            if(em>0) then
              V_csw(i,n)=mean_mass(i,n)/den_max
              call cal_semiac_ip(is_mod(2,i,n),phi_cs(i,n),V_csw(i,n),semi_a(i,n),semi_c(i,n))
              den(i,n)=den_max
            endif
          end if
        end if
      end select

      endif non_zero_if
    enddo
    enddo


  end subroutine cal_bulk_density3_vec2


!!$  subroutine cal_bulk_density(level,token,mean_mass,den,&
!!$       m_ic,den_ic,&
!!$       habit,alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
!!$       sh_type,semi_a,semi_c,phi_cs,v_cs,&
!!$       m_mlt, &     
!!$       from)
!!$
!!$    integer,intent(in) :: level,token,habit,sh_type
!!$    real(PS),intent(in) :: mean_mass
!!$    real(PS),intent(inout) :: den
!!$    real(PS),optional,intent(in) :: m_ic
!!$    real(PS),optional,intent(inout) :: den_ic,alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
!!$         semi_a,semi_c,phi_cs,v_cs
!!$    real(PS),optional,intent(in) :: m_mlt
!!$    character (len=*) :: from
!!$    
!!$    real(PS) :: den_max,v_ic_hex
!!$    integer :: ierror
!!$
!!$    ! 3 sqrt(3), 4pi/3
!!$    real(PS),parameter :: coef3s=5.196152423, coef4pi3=4.18879020478639
!!$
!!$    ! assume that the possible minimum density is 1.0e-5
!!$    real(PS),parameter :: den_min=1.0e-5
!!$
!!$    if(token==1) then
!!$       ! liquid hydrometeors
!!$       ! assume den=1.0
!!$       den=1.0_PS
!!$    elseif(token==2) then
!!$
!!$       ! 1. calculate bulk crystal density
!!$       ! pristine crystal and rimed crystals
!!$       v_ic_hex=coef4pi3*(alen**2+clen**2)**1.5
!!$       den_ic=m_ic/v_ic_hex
!!$
!!$       ! maximum possible bulk sphere density of pristine hexagonal crystal
!!$       den_max=coef3s*phi_ic*den_i*(1.0-psi_ic)/&
!!$            (coef4pi3*(1.0+phi_ic**2.0)**1.5)
!!$
!!$       ierror=0
!!$       if(den_ic/den_max-1.0>0.1) then
!!$          write(*,*) from
!!$          write(*,'("cal_bulk_density:error 1, bf, alen,clen,dlen,m_ic,denic",5ES15.6)') alen,clen,dlen,m_ic,den_ic
!!$
!!$          den_ic=den_max
!!$          V_ic_hex=m_ic/den_max
!!$
!!$
!!$
!!$          alen=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$          clen=alen*phi_ic
!!$          dlen=alen*psi_ic
!!$
!!$          write(*,'("                       1, af alen,clen,dlen,m_ic,denx",5ES15.6)') alen,clen,dlen,m_ic,den_max
!!$          ierror=1
!!$       end if
!!$
!!$       ! 2. calculate bulk sphere density       
!!$       if(sh_type==1) then
!!$          if(habit<=3) then
!!$             den=den_ic
!!$             if(ierror==1) then
!!$                semi_a=alen
!!$                semi_c=clen
!!$                phi_cs=semi_c/semi_a
!!$                V_ic=V_ic_hex
!!$                V_cs=V_ic_hex
!!$             end if
!!$          elseif(habit>=4) then
!!$             den=mean_mass/v_cs
!!$             if(den>den_i) then
!!$                ! assume it is sphere
!!$                write(*,*) from
!!$
!!$                den=den_i
!!$                V_ic=mean_mass/den
!!$                V_cs=V_ic
!!$
!!$                semi_a=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_c=semi_a
!!$                phi_cs=1.0_PS
!!$
!!$                if(habit==4) then
!!$                   rlen=semi_a
!!$                elseif(habit==5) then
!!$                   elen=semi_a
!!$                else
!!$                   elen=semi_a
!!$                   rlen=elen
!!$                end if
!!$
!!$                write(*,*) "cal_bulk_density:error 2, alen,clen,dlen,m_ic",alen,clen,dlen,m_ic
!!$                write(*,*) "cal_bulk_density:error 2, mm,semia,semic",mean_mass,semi_a,semi_c
!!$
!!$             end if
!!$          end if
!!$
!!$       elseif(sh_type==2) then
!!$          den=mean_mass/V_cs
!!$!!c          if(den>den_i) then
!!$          if((mean_mass-m_mlt)/V_cs>den_i) then
!!$             ! assume it is sphere
!!$
!!$
!!$!!c             den=den_i
!!$!!c             V_cs=mean_mass/den_i
!!$             V_cs=(mean_mass-m_mlt)/den_i
!!$             den=mean_mass/V_cs
!!$             semi_a=(V_cs/coef4pi3)**(1.0/3.0)
!!$             semi_c=semi_a
!!$             phi_cs=1.0_PS
!!$
!!$
!!$             alen=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$             clen=alen*phi_ic
!!$             dlen=alen*psi_ic
!!$
!!$             if(habit==4) then
!!$                rlen=semi_a
!!$             elseif(habit==5) then
!!$                elen=semi_a
!!$             else
!!$                rlen=semi_a
!!$                elen=semi_a
!!$             end if
!!$             V_ic=V_cs
!!$
!!$             write(*,*) from
!!$             write(*,*) "cal_bulk_density:error 3, alen,clen,dlen,m_ic",alen,clen,dlen,m_ic
!!$             write(*,*) "cal_bulk_density:error 3, mm,semia,semic",mean_mass,semi_a,semi_c
!!$
!!$          end if
!!$
!!$       elseif(sh_type<=4) then
!!$          den=mean_mass/V_cs
!!$          if((mean_mass-m_mlt)/V_cs>den_i) then
!!$
!!$             write(*,*) from
!!$             write(*,'("cal_bulk_density:error 4, bf, semi_a,semi_c,den",3ES15.6)') semi_a,semi_c,den
!!$             V_cs=(mean_mass-m_mlt)/den_i
!!$             den=mean_mass/V_cs
!!$             semi_a=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0)
!!$             semi_c=semi_a*phi_cs
!!$
!!$             write(*,'("cal_bulk_density:error 4, af, semi_a,semi_c,den",3ES15.6)') semi_a,semi_c,den
!!$          elseif(den<den_min) then
!!$             write(*,*) from
!!$             write(*,'("cal_bulk_density:error 6 bf, den,semi_a,semi_c",3ES15.6)') den,semi_a,semi_c
!!$             den=den_min
!!$             V_cs=mean_mass/den_min
!!$             semi_a=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0_PS+phi_cs**2.0)
!!$             semi_c=semi_a*phi_cs
!!$
!!$             alen=min(semi_a,alen)
!!$             clen=min(semi_c,clen)
!!$             phi_ic=clen/alen
!!$             dlen=alen*psi_ic
!!$             V_ic=coef4pi3*alen**3.0*(1.0_PS+phi_ic**2.0)**1.5
!!$
!!$             write(*,'("cal_bulk_density:error 6 af, den,semi_a,semi_c",3ES15.6)') den,semi_a,semi_c
!!$          end if
!!$       else
!!$          den=mean_mass/V_cs
!!$
!!$          if((mean_mass-m_mlt)/V_cs>den_i) then
!!$             write(*,*) from
!!$             write(*,'("cal_bulk_density:error 5, bf, semi_a,semi_c,den",3ES15.6)') semi_a,semi_c,den
!!$
!!$             V_cs=(mean_mass-m_mlt)/den_i
!!$             den=mean_mass/V_cs
!!$
!!$
!!$             if(phi_cs<1.0) then
!!$                semi_a=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_c=semi_a*phi_cs
!!$             else
!!$                semi_c=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_a=semi_c/phi_cs
!!$             end if
!!$
!!$
!!$
!!$             write(*,'("cal_bulk_density:error 5, af, semi_a,semi_c,den",3ES15.6)') semi_a,semi_c,den
!!$          elseif(den<den_min) then
!!$             write(*,*) from
!!$             write(*,'("cal_bulk_density:error 7 bf, den,semi_a,semi_c",3ES15.6)') den,semi_a,semi_c
!!$             den=den_min
!!$             V_cs=mean_mass/den_min
!!$
!!$             if(phi_cs<1.0) then
!!$                semi_a=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_c=semi_a*phi_cs
!!$             else
!!$                semi_c=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_a=semi_c/phi_cs
!!$             end if
!!$
!!$
!!$             alen=min(semi_a,alen)
!!$             clen=min(semi_c,clen)
!!$             phi_ic=clen/alen
!!$             dlen=alen*psi_ic
!!$             V_ic=coef4pi3*alen**3.0*(1.0_PS+phi_ic**2.0)**1.5
!!$
!!$             write(*,'("cal_bulk_density:error 7 af, den,semi_a,semi_c",3ES15.6)') den,semi_a,semi_c
!!$
!!$          end if
!!$       end if
!!$    end if
!!$  end subroutine cal_bulk_density
!!$  subroutine cal_bulk_density2(level,token,mean_mass,den,&
!!$       m_ic,den_ic,&
!!$       habit,alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
!!$       sh_type,semi_aip,semi_cip,phi_cs,V_cs,den_ip,&
!!$       semi_a,semi_c,V_csw,&
!!$       m_rim,m_agg,m_mlt, &     
!!$       is_mod,iswitch,iswitch_grp,&
!!$       from)
!!$    real(PS),intent(inout) :: den,den_ip
!!$    integer,intent(in) :: level,token,habit,sh_type,iswitch,iswitch_grp
!!$    real(PS),intent(in) :: mean_mass
!!$    real(PS),optional,intent(in) :: m_ic
!!$    real(PS),optional,intent(inout) :: den_ic,alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
!!$         semi_aip,semi_cip,phi_cs,v_cs,semi_a,semi_c,v_csw
!!$    real(PS),optional,intent(in) :: m_mlt,m_rim,m_agg
!!$    integer,dimension(2) :: is_mod
!!$    character (len=*) :: from
!!$    
!!$    real(PS) :: den_max,v_ic_hex,v_space,v_ip,ak3, phi_cs_max,m_dry
!!$    integer :: ierror,ierror2
!!$
!!$    ! assume that the possible minimum density is 1.0e-5
!!$    real(PS),parameter :: den_min=1.0e-5
!!$    ! assume that the possible minimum density of hex ice crystal is 1.0e-4
!!$    ! The hex column with dendritic arms (phi=20, psi=0.9) can reach 
!!$    ! 0.0002832.
!!$    real(PS),parameter :: den_min_hex=1.0e-4
!!$
!!$    ! fraction of maximum possible ice-water mixture
!!$    real(PS),parameter :: fdenmx=0.9999
!!$
!!$    if(token==1) then
!!$       ! liquid hydrometeors
!!$       ! assume den=1.0
!!$       den=1.0_PS
!!$    elseif(token==2) then
!!$
!!$       ! 1. calculate bulk crystal density
!!$       ! pristine crystal and rimed crystals
!!$       v_ic_hex=coef4pi3*(alen**2+clen**2)**1.5
!!$       den_ic=m_ic/v_ic_hex
!!$
!!$       ! maximum possible bulk sphere density of pristine hexagonal crystal
!!$       den_max=coef3sq3*phi_ic*den_i*(1.0-psi_ic)/&
!!$            (coef4pi3*(1.0+phi_ic**2.0)**1.5)
!!$
!!$       ierror=0
!!$       if(den_ic/den_max-1.0>0.1) then
!!$!!c          write(*,*) from
!!$!!c          write(*,'("cal_bulk_density:error 1, bf, alen,clen,dlen,m_ic,denic",5ES15.6)') alen,clen,dlen,m_ic,den_ic
!!$
!!$          den_ic=den_max
!!$          V_ic_hex=m_ic/den_max
!!$
!!$          alen=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$          clen=alen*phi_ic
!!$          dlen=alen*psi_ic
!!$
!!$!!c          write(*,'("                       1, af alen,clen,dlen,m_ic,denx",5ES15.6)') alen,clen,dlen,m_ic,den_max
!!$          ierror=1
!!$       end if
!!$       if(den_ic<den_min_hex) then
!!$!!c          write(*,*) from
!!$!!c          write(*,'("cal_bulk_density:error 1, bf, alen,clen,dlen,m_ic,denic",5ES15.6)') alen,clen,dlen,m_ic,den_ic
!!$
!!$          den_ic=den_min_hex
!!$          V_ic_hex=m_ic/den_min_hex
!!$
!!$          alen=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$          clen=alen*phi_ic
!!$          dlen=alen*psi_ic
!!$
!!$!!c          write(*,'("                       1, af alen,clen,dlen,m_ic,denx",5ES15.6)') alen,clen,dlen,m_ic,den_max
!!$          ierror=1
!!$       end if
!!$
!!$       ! 2. calculate bulk sphere density for dry ice particle and wet ice particle
!!$       ierror2=0
!!$       m_dry=m_ic+m_agg+m_rim
!!$       if(sh_type<=2) then
!!$
!!$          den_ip=m_dry/v_cs
!!$          if(habit<=3) then
!!$             if(ierror==1) then
!!$                semi_aip=alen
!!$                semi_cip=clen
!!$                phi_cs=semi_cip/semi_aip
!!$                V_ic=V_ic_hex
!!$                V_cs=V_ic_hex
!!$             end if
!!$          elseif(habit>=4) then
!!$!!c             if(den_ip>=den_i.or.semi_aip**2+semi_cip**2<4.0e-6) then
!!$             if(den_ip>=den_i) then
!!$                !
!!$                ! assume it is sphere
!!$                ! this may happen because the empirical equation used for these habits
!!$                ! can produce density more than den_i in small range.
!!$                !
!!$                write(*,*) from,habit
!!$
!!$                V_ic=m_dry/den_i
!!$                V_cs=V_ic
!!$                den_ip=den_i
!!$
!!$                semi_aip=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_cip=semi_aip
!!$                phi_cs=1.0_PS
!!$
!!$                if(habit==4) then
!!$                   rlen=semi_aip
!!$                elseif(habit==5) then
!!$                   elen=semi_aip
!!$                elseif(habit==6) then
!!$                   elen=semi_aip
!!$                   rlen=elen
!!$                end if
!!$
!!$                write(*,'("cal_bulk_density:error 1_2, alen,clen,dlen,m_ic,m_mlt",10ES15.6)') &
!!$                     alen,clen,dlen,m_ic,m_mlt,mean_mass,semi_aip,semi_cip
!!$                is_mod(1)=2
!!$                is_mod(2)=2
!!$
!!$             end if
!!$          end if
!!$
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_i
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_i
!!$             end if
!!$             
!!$             call den_ck1
!!$             if(ierror2==1) then
!!$                alen=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$                clen=alen*phi_ic
!!$                dlen=alen*psi_ic
!!$                
!!$                if(habit==4) then
!!$                   rlen=semi_aip
!!$                elseif(habit==5) then
!!$                   elen=semi_aip
!!$                elseif(habit==6) then
!!$                   rlen=semi_aip
!!$                   elen=semi_aip
!!$                end if
!!$                V_ic=V_cs
!!$             end if
!!$          end if
!!$
!!$          den=mean_mass/V_csw
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_w*fdenmx
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_w*fdenmx
!!$             end if
!!$             call den_ck3
!!$             call den_ck4
!!$          end if
!!$       elseif(sh_type<=4) then
!!$
!!$          den_ip=m_dry/v_cs
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_i
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_i
!!$             end if
!!$             call den_ck1
!!$             call den_ck2
!!$          end if
!!$
!!$          den=mean_mass/V_csw
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_w*fdenmx
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_w*fdenmx
!!$             end if
!!$             call den_ck3
!!$             call den_ck4
!!$          end if
!!$       else
!!$
!!$          den_ip=m_dry/v_cs
!!$          if(iswitch==1) then
!!$
!!$             if(iswitch_grp==1) then
!!$                ! This is because the aspect ratio is accurately not predicted by _rim5, so that
!!$                ! den_max is not really correct.
!!$!!c          phi_cs_max=den_ip/den_i
!!$                if(is_mod(2)==1) then
!!$                   den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_i
!!$                elseif(is_mod(2)==2) then
!!$                   den_max=min(phi_cs,phi_cs**(-2))*den_i
!!$                end if
!!$                call den_ck1
!!$             end if
!!$             call den_ck2
!!$          end if
!!$
!!$          den=mean_mass/V_csw
!!$          if(iswitch==1) then
!!$             call den_ck3
!!$             if(iswitch_grp==1) then
!!$                if(is_mod(2)==1) then
!!$                   den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_w*fdenmx
!!$                elseif(is_mod(2)==2) then
!!$                   den_max=min(phi_cs,phi_cs**(-2))*den_w*fdenmx
!!$                end if
!!$                call den_ck4
!!$             end if
!!$          end if
!!$       end if
!!$    end if
!!$   contains
!!$    subroutine den_ck1
!!$      if(den_ip-den_max>1.0e-4*den_max) then
!!$!!c      if(den_ip>den_max) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 1, bf, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$
!!$         V_cs=m_dry/den_max
!!$         call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$         den_ip=den_max
!!$         ierror2=1
!!$!!c         write(*,'("cal_bulk_density:error 1, af, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$      end if
!!$    end subroutine den_ck1
!!$    subroutine den_ck2
!!$!!c      if(den_ip<den_min) then
!!$      if(den_ip-den_min<-1.0e-4*den_min) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 2, bf, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$         V_cs=m_dry/den_min
!!$         call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$         den_ip=den_min
!!$
!!$         alen=min(semi_aip,alen)
!!$         clen=min(semi_cip,clen)
!!$         phi_ic=clen/alen
!!$         dlen=alen*psi_ic
!!$         V_ic=coef4pi3*alen**3.0*(1.0_PS+phi_ic**2.0)**1.5
!!$
!!$         ierror2=1
!!$!!c         write(*,'("cal_bulk_density:error 2, af, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$      end if
!!$    end subroutine den_ck2
!!$    subroutine den_ck3
!!$      if(ierror2==1) then
!!$!!c      if(den>den_w.or.ierror2==1) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 3, bf, semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$!!c         end if
!!$
!!$         V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$         V_space=max(0.0_PS,V_ip-m_dry/den_i)
!!$         ak3=1.0_PS+max(m_mlt-V_space*den_w,0.0_PS)/V_ip
!!$         V_csw=ak3*V_cs
!!$         semi_a=ak3**(1.0/3.0)*semi_aip
!!$         semi_c=semi_a*phi_cs
!!$         den=mean_mass/V_csw
!!$!!c         write(*,'("cal_bulk_density:error 3, af, semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$      end if
!!$    end subroutine den_ck3
!!$    subroutine den_ck4
!!$      if(den-den_max>1.0e-4*den_max) then
!!$         write(*,*) from,habit,sh_type
!!$         write(*,'("cal_bulk_density:error 4-1, bf, semi_a,semi_c,den,semi_aip,semi_cip",20ES15.6)') &
!!$             semi_a,semi_c,den,semi_aip,semi_cip
!!$         write(*,'("cal_bulk_density:error 4-2, bf, den_ip,mean_mass,m_ic,m_mlt,m_rim",20ES15.6)') &
!!$             den_ip,mean_mass,m_ic,m_mlt,m_rim
!!$         write(*,'("cal_bulk_density:error 4-3, bf, V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') &
!!$             V_ic,V_ip,V_space,V_cs,V_csw
!!$
!!$         V_csw=mean_mass/den_max
!!$         call cal_semiac_ip(is_mod(2),phi_cs,v_csw,semi_a,semi_c)
!!$         den=den_max
!!$
!!$         write(*,'("cal_bulk_density:error 4-1, af, semi_a,semi_c,den,semi_aip,semi_cip",20ES15.6)') &
!!$             semi_a,semi_c,den,semi_aip,semi_cip
!!$         write(*,'("cal_bulk_density:error 4-2, af, den_ip,mean_mass,m_ic,m_mlt,m_rim",20ES15.6)') &
!!$             den_ip,mean_mass,m_ic,m_mlt,m_rim
!!$         write(*,'("cal_bulk_density:error 4-3, af, V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') &
!!$             V_ic,V_ip,V_space,V_cs,V_csw
!!$
!!$!!c         if(V_space>1.0e-6) then
!!$!!c         ! increase V_ip to make V_space to hold the water, then some of the melt water has to be decreased.
!!$!!c         den_ism=m_dry/V_ip
!!$!!c         if(mean_mass<=m_mlt.or.den_ism-den_i>den_i*1.0e-4) then
!!$!!c            write(*,*) "den_ck4>woops",mean_mass,m_mlt,den_ism,V_ip
!!$!!c         end if
!!$!!c         
!!$!!c         dV_ip=(mean_mass/den_i+(1.0_PS/den_w-1.0_PS/den_i)*m_mlt-V_ip)/&
!!$!!c                     ((1.0_PS/den_w-1.0_PS/den_i)*den_ism+1.0_PS)
!!$!!c         if(dV_ip<=0.0_PS) then
!!$!!c            write(*,*) "den_ck4>something not right:",V_ip,dV_ip,mean_mass,m_mlt,den_ism,semi_aip,semi_cip,phi_cs
!!$!!c!!c            stop
!!$!!c            return
!!$!!c         end if
!!$!!c         m_mlt=m_mlt-den_ism*dV_ip
!!$!!c         m_rim=m_rim+den_ism*dV_ip
!!$!!c
!!$!!c         V_ip=V_ip+dV_ip
!!$!!c         semi_aip=(V_ip/get_coef_ip(is_mod(2))/phi_cs)**(1.0/3.0)
!!$!!c         semi_cip=semi_aip*phi_cs
!!$!!c         V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$!!c         V_csw=V_cs
!!$!!c         semi_a=semi_aip
!!$!!c         semi_c=semi_cip
!!$!!c         end if  
!!$!!c         den=mean_mass/V_csw
!!$!!c         if(habit/=6) then
!!$!!c         end if
!!$!!c         if(den>den_w) then
!!$!!c            write(*,*) "cal_bulk_density>something is wrong:",den,semi_a,semi_c,V_csw,V_ip,V_space,ak3,m_mlt
!!$!!c         end if
!!$      end if
!!$    end subroutine den_ck4
!!$
!!$  end subroutine cal_bulk_density2
!!$
!!$  subroutine cal_bulk_density3(level,token,mean_mass,den,&
!!$       m_ic,den_ic,&
!!$       habit,alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
!!$       sh_type,semi_aip,semi_cip,phi_cs,V_cs,den_ip,&
!!$       semi_a,semi_c,V_csw,&
!!$       m_rim,m_agg,m_mlt, &     
!!$       is_mod,iswitch,iswitch_grp,&
!!$       id,jd,kd,from)
!!$    real(PS),intent(inout) :: den,den_ip
!!$    integer,intent(in) :: level,token,habit,sh_type,iswitch,iswitch_grp
!!$    integer,intent(in) :: id,jd,kd
!!$    real(PS),intent(in) :: mean_mass
!!$    real(PS),optional,intent(in) :: m_ic
!!$    real(PS),optional,intent(inout) :: den_ic,alen,clen,dlen,rlen,elen,phi_ic,psi_ic,v_ic,&
!!$         semi_aip,semi_cip,phi_cs,v_cs,semi_a,semi_c,v_csw
!!$    real(PS),optional,intent(in) :: m_mlt,m_rim,m_agg
!!$    integer,dimension(2) :: is_mod
!!$    character (len=*) :: from
!!$    
!!$    real(PS) :: den_max,v_ic_hex,v_space,v_ip,ak3, phi_cs_max,m_dry
!!$    integer :: ierror,ierror2
!!$
!!$    ! assume that the possible minimum density is 1.0e-4
!!$    real(PS),parameter :: den_min=1.0e-4
!!$    ! assume that the possible minimum density of hex ice crystal is 1.0e-4
!!$    ! The hex column with dendritic arms (phi=20, psi=0.9) can reach 
!!$    ! 0.0002832.
!!$    real(PS),parameter :: den_min_hex=1.0e-4
!!$
!!$    ! fraction of maximum possible ice-water mixture
!!$    real(PS),parameter :: fdenmx=0.9999
!!$
!!$    if(token==1) then
!!$       ! liquid hydrometeors
!!$       ! assume den=1.0
!!$       den=1.0_PS
!!$    elseif(token==2) then
!!$
!!$       ! 1. calculate bulk crystal density
!!$       ! pristine crystal and rimed crystals
!!$       v_ic_hex=coef4pi3*(alen**2+clen**2)**1.5
!!$       den_ic=m_ic/v_ic_hex
!!$
!!$       ! maximum possible bulk sphere density of pristine hexagonal crystal
!!$       den_max=coef3sq3*phi_ic*den_i*(1.0-psi_ic)/&
!!$            (coef4pi3*(1.0+phi_ic**2.0)**1.5)
!!$
!!$       ierror=0
!!$       if(den_ic/den_max-1.0>0.1) then
!!$!!c          write(*,*) from
!!$!!c          write(*,'("cal_bulk_density:error 1a, bf, id,jd,kd,alen,clen,dlen,m_ic,denic,den_max,phi",3I5,10ES15.6)') &
!!$!!c                     id,jd,kd,alen,clen,dlen,m_ic,den_ic,den_max,clen/alen
!!$
!!$          den_ic=den_max
!!$          V_ic_hex=m_ic/den_max
!!$
!!$          alen=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$          clen=alen*phi_ic
!!$          dlen=alen*psi_ic
!!$
!!$!!c          write(*,'("                       1a, af id,jd,kd,alen,clen,dlen,m_ic,denic,den_mxd,phi",3I5,10ES15.6)') &
!!$!!c                     id,jd,kd,alen,clen,dlen,m_ic,den_ic,den_max,clen/alen
!!$          ierror=1
!!$       end if
!!$       if(den_ic<den_min_hex) then
!!$!!c          write(*,*) from
!!$!!c          write(*,'("cal_bulk_density:error 1b, bf, id,jd,kd,alen,clen,dlen,m_ic,denic,phi",3I5,10ES15.6)') &
!!$!!c                   id,jd,kd,alen,clen,dlen,m_ic,den_ic,clen/alen
!!$
!!$          den_ic=den_min_hex
!!$          V_ic_hex=m_ic/den_min_hex
!!$
!!$          alen=(V_ic_hex/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$          clen=alen*phi_ic
!!$          dlen=alen*psi_ic
!!$
!!$!!c          write(*,'("                       1b, af id,jd,kd,alen,clen,dlen,m_ic,denic,phi",3I5,10ES15.6)') &
!!$!!c                    id,jd,kd,alen,clen,dlen,m_ic,den_ic,clen/alen
!!$          ierror=1
!!$       end if
!!$
!!$       ! 2. calculate bulk sphere density for dry ice particle and wet ice particle
!!$       ierror2=0
!!$       m_dry=m_ic+m_agg+m_rim
!!$       if(sh_type<=2) then
!!$
!!$          den_ip=m_dry/v_cs
!!$
!!$          if(is_mod(2)==1) then
!!$             if(habit<=3) then
!!$                if(ierror==1) then
!!$                   semi_aip=alen
!!$                   semi_cip=clen
!!$                   phi_cs=semi_cip/semi_aip
!!$                   V_ic=V_ic_hex
!!$                   V_cs=V_ic_hex
!!$
!!$                   den_ip=m_dry/v_cs
!!$
!!$                   V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$                   V_space=max(0.0_PS,V_ip-(mean_mass-m_mlt)/den_i)
!!$                   ak3=1.0_PS+max(m_mlt/den_w-V_space,0.0_PS)/V_ip
!!$                   V_csw=ak3*V_cs
!!$
!!$                end if
!!$             elseif(habit>=4) then
!!$!!c             if(den_ip>=den_i.or.semi_aip**2+semi_cip**2<4.0e-6) then
!!$                if(den_ip>=den_i) then
!!$                   !
!!$                   ! assume it is sphere
!!$                   ! this may happen because the empirical equation used for these habits
!!$                   ! can produce density more than den_i in small range.
!!$                   !
!!$!!c                   write(*,*) from,habit
!!$
!!$                   V_ic=m_dry/den_i
!!$                   V_cs=V_ic
!!$                   den_ip=den_i
!!$
!!$                   semi_aip=(V_cs/coef4pi3)**(1.0/3.0)
!!$                   semi_cip=semi_aip
!!$                   phi_cs=1.0_PS
!!$   
!!$                   if(habit==4) then
!!$                      rlen=semi_aip
!!$                   elseif(habit==5) then
!!$                      elen=semi_aip
!!$                   elseif(habit==6) then
!!$                      elen=semi_aip
!!$                      rlen=elen
!!$                   end if
!!$
!!$!!c                   write(*,*) "cal_bulk_density:error 1_2, alen,clen,dlen,m_ic,m_mlt",&
!!$!!c                             alen,clen,dlen,m_ic,m_mlt,mean_mass,semi_aip,semi_cip
!!$
!!$                   is_mod(1)=2
!!$                   is_mod(2)=2
!!$                endif
!!$             endif
!!$          elseif(is_mod(2)==2) then
!!$             if(den_ip*0.9999>den_i) then
!!$                !
!!$                ! assume it is sphere
!!$                !
!!$!!c                write(*,*) from,habit,sh_type
!!$!!c                write(*,'("cal_bulk_density:error 1_2_3, den_ip,a,c,d,m_ic,m_mlt,mm,saip,scip",10ES15.6)') &
!!$!!c                        den_ip,alen,clen,dlen,m_ic,m_mlt,mean_mass,semi_aip,semi_cip
!!$
!!$                V_cs=m_dry/den_i
!!$                den_ip=den_i
!!$
!!$                semi_aip=(V_cs/coef4pi3)**(1.0/3.0)
!!$                semi_cip=semi_aip
!!$                phi_cs=1.0_PS
!!$   
!!$             endif
!!$          endif
!!$
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_i
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_i
!!$             end if
!!$             
!!$             call den_ck1
!!$             if(sh_type==2) call den_ck2
!!$             if(ierror2==1) then
!!$                alen=(V_cs/coef4pi3)**(1.0/3.0)/sqrt(1.0+phi_ic**2.0)
!!$                clen=alen*phi_ic
!!$                dlen=alen*psi_ic
!!$                
!!$                if(habit==4) then
!!$                   rlen=semi_aip
!!$                elseif(habit==5) then
!!$                   elen=semi_aip
!!$                elseif(habit==6) then
!!$                   rlen=semi_aip
!!$                   elen=semi_aip
!!$                end if
!!$                V_ic=V_cs
!!$             end if
!!$          end if
!!$
!!$          den=mean_mass/V_csw
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_w*fdenmx
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_w*fdenmx
!!$             end if
!!$             call den_ck3
!!$             call den_ck4
!!$          end if
!!$       elseif(sh_type<=4) then
!!$
!!$          den_ip=m_dry/v_cs
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_i
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_i
!!$             end if
!!$             call den_ck1
!!$             call den_ck2
!!$          end if
!!$
!!$          den=mean_mass/V_csw
!!$          if(iswitch==1) then
!!$             if(is_mod(2)==1) then
!!$                den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_w*fdenmx
!!$             elseif(is_mod(2)==2) then
!!$                den_max=min(phi_cs,phi_cs**(-2))*den_w*fdenmx
!!$             end if
!!$             call den_ck3
!!$             call den_ck4
!!$          end if
!!$       else
!!$
!!$          den_ip=m_dry/v_cs
!!$          if(iswitch==1) then
!!$
!!$             if(iswitch_grp==1) then
!!$                ! This is because the aspect ratio is accurately not predicted by _rim5, so that
!!$                ! den_max is not really correct.
!!$!!c          phi_cs_max=den_ip/den_i
!!$                if(is_mod(2)==1) then
!!$                   den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_i
!!$                elseif(is_mod(2)==2) then
!!$                   den_max=min(phi_cs,phi_cs**(-2))*den_i
!!$                end if
!!$                call den_ck1
!!$             end if
!!$             call den_ck2
!!$          end if
!!$
!!$          den=mean_mass/V_csw
!!$          if(iswitch==1) then
!!$             call den_ck3
!!$             if(iswitch_grp==1) then
!!$                if(is_mod(2)==1) then
!!$                   den_max=1.5_PS*phi_cs/(1.0_PS+phi_cs**2)**1.5*den_w*fdenmx
!!$                elseif(is_mod(2)==2) then
!!$                   den_max=min(phi_cs,phi_cs**(-2))*den_w*fdenmx
!!$                end if
!!$                call den_ck4
!!$             end if
!!$          end if
!!$       end if
!!$    end if
!!$   contains
!!$    subroutine den_ck1
!!$      if(den_ip-den_max>1.0e-4*den_max) then
!!$!!c      if(den_ip>den_max) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 1, bf, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$
!!$         V_cs=m_dry/den_max
!!$         call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$         den_ip=den_max
!!$         ierror2=1
!!$!!c         write(*,'("cal_bulk_density:error 1, af, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$      end if
!!$    end subroutine den_ck1
!!$    subroutine den_ck2
!!$!!c      if(den_ip<den_min) then
!!$      if(den_ip-den_min<-1.0e-4*den_min) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 2, bf, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$         V_cs=m_dry/den_min
!!$         call cal_semiac_ip(is_mod(2),phi_cs,v_cs,semi_aip,semi_cip)
!!$         den_ip=den_min
!!$
!!$         alen=min(semi_aip,alen)
!!$         clen=min(semi_cip,clen)
!!$         phi_ic=clen/alen
!!$         dlen=alen*psi_ic
!!$         V_ic=coef4pi3*alen**3.0*(1.0_PS+phi_ic**2.0)**1.5
!!$
!!$         ierror2=1
!!$!!c         write(*,'("cal_bulk_density:error 2, af, semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$      end if
!!$    end subroutine den_ck2
!!$    subroutine den_ck3
!!$      if(ierror2==1) then
!!$!!c      if(den>den_w.or.ierror2==1) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 3, bf, semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$!!c         end if
!!$
!!$         V_ip=get_vip(is_mod(2),phi_cs,semi_aip)
!!$         V_space=max(0.0_PS,V_ip-m_dry/den_i)
!!$         ak3=1.0_PS+max(m_mlt-V_space*den_w,0.0_PS)/V_ip
!!$         V_csw=ak3*V_cs
!!$         semi_a=ak3**(1.0/3.0)*semi_aip
!!$         semi_c=semi_a*phi_cs
!!$         den=mean_mass/V_csw
!!$!!c         write(*,'("cal_bulk_density:error 3, af, semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$      end if
!!$    end subroutine den_ck3
!!$    subroutine den_ck4
!!$      if(den-den_max>1.0e-4*den_max) then
!!$!!c         write(*,*) from,habit,sh_type
!!$!!c         write(*,'("cal_bulk_density:error 4, bf, semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$
!!$         V_csw=mean_mass/den_max
!!$         call cal_semiac_ip(is_mod(2),phi_cs,v_csw,semi_a,semi_c)
!!$         den=den_max
!!$
!!$!!c         write(*,'("cal_bulk_density:error 4, af, semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw",20ES15.6)') semi_a,semi_c,den,semi_aip,semi_cip,den_ip,mean_mass,m_ic,m_mlt,m_rim,V_ic,V_ip,V_space,V_cs,V_csw
!!$
!!$!!c         if(V_space>1.0e-6) then
!!$!!c         ! increase V_ip to make V_space to hold the water, then some of the melt water has to be decreased.
!!$!!c         den_ism=m_dry/V_ip
!!$!!c         if(mean_mass<=m_mlt.or.den_ism-den_i>den_i*1.0e-4) then
!!$!!c            write(*,*) "den_ck4>woops",mean_mass,m_mlt,den_ism,V_ip
!!$!!c         end if
!!$!!c         
!!$!!c         dV_ip=(mean_mass/den_i+(1.0_PS/den_w-1.0_PS/den_i)*m_mlt-V_ip)/&
!!$!!c                     ((1.0_PS/den_w-1.0_PS/den_i)*den_ism+1.0_PS)
!!$!!c         if(dV_ip<=0.0_PS) then
!!$!!c            write(*,*) "den_ck4>something not right:",V_ip,dV_ip,mean_mass,m_mlt,den_ism,semi_aip,semi_cip,phi_cs
!!$!!c!!c            stop
!!$!!c            return
!!$!!c         end if
!!$!!c         m_mlt=m_mlt-den_ism*dV_ip
!!$!!c         m_rim=m_rim+den_ism*dV_ip
!!$!!c
!!$!!c         V_ip=V_ip+dV_ip
!!$!!c         semi_aip=(V_ip/get_coef_ip(is_mod(2))/phi_cs)**(1.0/3.0)
!!$!!c         semi_cip=semi_aip*phi_cs
!!$!!c         V_cs=get_vcs(is_mod(2),phi_cs,semi_aip)
!!$!!c         V_csw=V_cs
!!$!!c         semi_a=semi_aip
!!$!!c         semi_c=semi_cip
!!$!!c         end if  
!!$!!c         den=mean_mass/V_csw
!!$!!c         if(habit/=6) then
!!$!!c         end if
!!$!!c         if(den>den_w) then
!!$!!c            write(*,*) "cal_bulk_density>something is wrong:",den,semi_a,semi_c,V_csw,V_ip,V_space,ak3,m_mlt
!!$!!c         end if
!!$      end if
!!$    end subroutine den_ck4
!!$
!!$  end subroutine cal_bulk_density3

  subroutine cal_bulk_density_ap(level,token,den,&
       deps_ap,den_ai,den_as)
    integer,intent(in) :: level,token
    real(PS),intent(in) :: deps_ap,den_ai,den_as
    real(PS),intent(inout) :: den
    
    ! aerosols
    den=den_ai/(1.0_PS-deps_ap*(1.0_PS-den_ai/den_as))
  end subroutine cal_bulk_density_ap

!!$  subroutine cal_bulk_density_liq(level,mm,map,den_ai,den_as,eps_map,den)
!!$    real(PS),intent(inout) :: den
!!$    integer,intent(in) :: level
!!$    real(PS),intent(in) :: mm,map,den_ai,den_as,eps_map
!!$
!!$    real(PS) :: den_ap
!!$
!!$    ! liquid hydrometeors
!!$    if(mm<1.0e-30_PS) then
!!$       den=1.0_PS
!!$    else
!!$       ! calculate density of mixed aerosols
!!$       den_ap=den_ai/(1.0_PS-eps_map*(1.0_PS-den_ai/den_as))
!!$       ! assume that v_d=v_w+v_n where v_w is volume of water and v_n is volume of dry aerosol.
!!$       den=min(den_ap*0.95,mm/((mm-map)/den_w+map/den_ap))
!!$!tmp       den=1.0_PS
!!$    endif
!!$  end subroutine cal_bulk_density_liq

!!$  subroutine print_diag_pq( g, cur_time, ofname )
!!$    type (Group), intent(in) :: g
!!$    real(PS), intent(in)                      :: cur_time
!!$    character (len = *)      :: ofname
!!$    integer                  :: i,n
!!$
!!$200 format( F10.1, I4, 28( 2X, ES17.8E3))
!!$
!!$    open( unit=1, file=ofname)
!!$    if( g%token == 2 ) then
!!$!       write(1,'(100A)') "# 1 time, 2 bin No, 3 len, 4 den, 5 a_len, 6 c_len, 7 vtm, &
!!$!            8 tmp, 9 fv, 10 fac, 11 fh, &
!!$!            12 N_re, 13 mass_t, 14 mass_R, 15 mass_A, 16 CAP, &
!!$!            17 V_cs, 18 BinB, 19 semfi_a, 20 semi_c, 21 d len, 22 r len, &
!!$!            23 v_R, 24 v_A, 25 con"
!!$
!!$       do n=1,g%L
!!$          ! loop over grid points
!!$          if(g%mark_cm(n)==3) cycle
!!$          write(1,*) "# grid number",n
!!$          do i = 1, g%N_BIN
!!$             write(1,200) cur_time, i, g%MS(i,n)%len, g%MS(i,n)%den, g%MS(i,n)%a_len, &
!!$                  g%MS(i,n)%c_len, g%MS(i,n)%vtm, g%MS(i,n)%tmp, &
!!$                  g%MS(i,n)%fv, g%MS(i,n)%fac, g%MS(i,n)%fh, g%MS(i,n)%Nre, &
!!$                  g%MS(i,n)%mass(1), g%MS(i,n)%mass(imr), g%MS(i,n)%mass(ima), &
!!$                  g%MS(i,n)%CAP, g%IS(i,n)%V_cs, g%binb(i), g%MS(i,n)%semi_a, g%MS(i,n)%semi_c, &
!!$                  g%IS(i,n)%d, g%IS(i,n)%r,g%MS(i,n)%vol(1),g%MS(i,n)%vol(2),g%MS(i,n)%con
!!$          end do
!!$          write(1,200) cur_time, (g%N_BIN+1), g%MS(g%N_BIN,n)%len, g%MS(g%N_BIN,n)%den, &
!!$               g%MS(g%N_BIN,n)%a_len, &
!!$               g%MS(g%N_BIN,n)%c_len, g%MS(g%N_BIN,n)%vtm, g%MS(g%N_BIN,n)%tmp, &
!!$               g%MS(g%N_BIN,n)%fv, g%MS(g%N_BIN,n)%fac, g%MS(g%N_BIN,n)%fh, g%MS(g%N_BIN,n)%Nre, &
!!$               g%MS(g%N_BIN,n)%mass(1), g%MS(g%N_BIN,n)%mass(imr), g%MS(g%N_BIN,n)%mass(ima), &
!!$               g%MS(g%N_BIN,n)%CAP, g%IS(g%N_BIN,n)%V_cs, g%binb(g%N_binb), &
!!$               g%MS(g%N_BIN,n)%semi_a, g%MS(g%N_BIN,n)%semi_c, &
!!$               g%IS(g%N_BIN,n)%d, g%IS(g%N_BIN,n)%r,g%MS(g%N_BIN,n)%vol(1),g%MS(g%N_BIN,n)%vol(2),g%MS(g%N_BIN,n)%con
!!$          write(1,*) " "
!!$       end do
!!$    else
!!$!       write(1,'(100A)') "# 1 time, 2 bin No, 3 len, 4 den, 5 a_len, 6 c_len, 7 vtm, &
!!$!            8 tmp, 9 fv, 10 fac, 11 fh, &
!!$!            12 N_re, 13 mass_t, 14 mass_R, 15 mass_A, 16 CAP, &
!!$!            17 V_cs, 18 BinB, 19 semfi_a, 20 semi_c, 21 d len, 22 r len"
!!$
!!$       do n=1,g%L
!!$          ! loop over grid points
!!$          if(g%mark_cm(n)==3) cycle
!!$          write(1,*) "# grid number",n
!!$
!!$          do i = 1, g%N_BIN
!!$             write(1,200) cur_time, i, g%MS(i,n)%len, g%MS(i,n)%den, g%MS(i,n)%a_len, &
!!$                  g%MS(i,n)%c_len, g%MS(i,n)%vtm, g%MS(i,n)%tmp, &
!!$                  g%MS(i,n)%fv, g%MS(i,n)%fac, g%MS(i,n)%fh, g%MS(i,n)%Nre, &
!!$                  g%MS(i,n)%mass(1), 0.0_PS, 0.0_PS, &
!!$                  g%MS(i,n)%CAP, 0.0_PS, g%binb(i), 0.0_PS, 0.0_PS, &
!!$                  0.0_PS,0.0_PS
!!$          end do
!!$          write(1,200) cur_time, (g%N_BIN+1), g%MS(g%N_BIN,n)%len, g%MS(g%N_BIN,n)%den, &
!!$               g%MS(g%N_BIN,n)%a_len, &
!!$               g%MS(g%N_BIN,n)%c_len, g%MS(g%N_BIN,n)%vtm, g%MS(g%N_BIN,n)%tmp, &
!!$               g%MS(g%N_BIN,n)%fv, g%MS(g%N_BIN,n)%fac, g%MS(g%N_BIN,n)%fh, &
!!$               g%MS(g%N_BIN,n)%Nre, &
!!$               g%MS(g%N_BIN,n)%mass(1), 0.0_PS, 0.0_PS,&
!!$               g%MS(g%N_BIN,n)%CAP, 0.0_PS, &
!!$               g%binb(g%N_binb), 0.0_PS, 0.0_PS, 0.0_PS, 0.0_PS
!!$          write(1,*) " "
!!$       end do
!!$    end if
!!$    close(1)
!!$  end subroutine print_diag_pq

!!$  subroutine print_n(g, ofname)
!!$    ! +++ print the concentration distribution (#/cm^3/g) +++
!!$    type (Group), intent(in)    :: g
!!$    character(len=*)            :: ofname
!!$    real(PS)                    :: dummy1, dummy2
!!$    integer                     :: i,n
!!$
!!$    open( unit=1, file=ofname)
!!$
!!$    dummy1 = g%binb(1)
!!$    dummy2 = g%binb(1)/100.0
!!$    do n=1,g%L
!!$       ! loop over grid points
!!$       if(g%mark_cm(n)==3) cycle
!!$       write(1,*) "# grid number",n
!!$
!!$       i=1
!!$       if( dummy1 >= g%binb(i+1) ) then
!!$          i = i + 1
!!$          if( i > g%N_BIN ) exit
!!$          dummy1 = g%binb(i)
!!$          dummy2 = g%binb(i)/100.0
!!$       end if
!!$       if( g%org_dtype == 1 ) then
!!$          write(1,*) dummy1, &
!!$               g%MS(i,n)%p(1) + g%MS(i,n)%p(3)*( dummy1 - g%MS(i,n)%p(2))
!!$       else if( g%org_dtype == 2 ) then
!!$          if( g%MS(i,n)%dis_type == 2 ) then
!!$             write(1,*) dummy1, &
!!$                  g%MS(i,n)%p(1)*dummy1**2 + g%MS(i,n)%p(2)*dummy1 + &
!!$                  g%MS(i,n)%p(3)
!!$          else if( g%MS(i,n)%dis_type == 1 ) then
!!$             if( g%MS(i,n)%p(1) > 0.0_PS ) then
!!$                ! --- case of non-negative bin ---
!!$                write(1,*) dummy1, &
!!$                     g%MS(i,n)%p(1) + g%MS(i,n)%p(3)*(dummy1-g%MS(i,n)%p(2))
!!$             else if( g%MS(i,n)%p(1) == -1.0_PS .OR. &
!!$                  g%MS(i,n)%p(1) == -2.0_PS ) then
!!$                write(1,*) dummy1, max(g%MS(i,n)%p(3)*&
!!$                     (real(dummy1,DS)-g%MS(i,n)%p(2)), 0.0d+0)
!!$             end if
!!$          end if
!!$       else if( g%org_dtype == 3 ) then
!!$          if( g%MS(i,n)%dis_type == 3 ) then
!!$             write(*,*) "print_n> dis_type 3"
!!$             stop
!!$!             write(1,*) dummy1, &
!!$!                  g%MS(i,n)%p(1)*dummy1**3 + g%MS(i,n)%p(2)*dummy1**2 + &
!!$!                  g%MS(i,n)%p(3)*dummy1 + g%MS(i,n)%p(4)
!!$          else if( g%MS(i,n)%dis_type == 1 ) then
!!$             if( g%MS(i,n)%p(1) > 0.0_PS ) then
!!$                ! --- case of non-negative bin ---
!!$                write(1,*) dummy1, &
!!$                     g%MS(i,n)%p(1) + g%MS(i,n)%p(3)*&
!!$                     (dummy1-g%MS(i,n)%p(2))
!!$             else if( g%MS(i,n)%p(1) == -1.0_PS .OR. &
!!$                  g%MS(i,n)%p(1) == -2.0_PS ) then
!!$                write(1,*) dummy1, &
!!$                     max(g%MS(i,n)%p(3)*(real(dummy1,DS)-g%MS(i,n)%p(2)), 0.0d+0)
!!$             end if
!!$          end if
!!$       end if
!!$       dummy1 = dummy1 + dummy2
!!$       write(1,*) " "
!!$    end do
!!$    close(1)
!!$  end subroutine print_n

!!$  subroutine cal_ratio_vol( g, nV, ratio_V)
!!$    ! volume of solid hydrometeors consist of
!!$    !    volume of representative (collector) ice crystal (v_ice)
!!$    !    + volume of riming + volume of aggregation
!!$    ! NOTE: v_ice is not a prognostic variable.
!!$    !       Therefore, ratio_V is alwasy less than 1.
!!$    type (Group), intent(in)   :: g
!!$    real(PS), dimension(:)            :: nV
!!$    real(PS), dimension(:)            :: ratio_V
!!$    !integer, intent(in)        :: level
!!$    integer     :: i
!!$    if( g%token == 2 ) then
!!$       do i = 1, g%N_vol
!!$          ratio_V(i) = nV(i+1+g%N_axis)/nV(1)
!!$       end do
!!$!!c       if( sum(ratio_V) >= 1.0_PS ) then
!!$!!c          write(*,100) sum(ratio_V), (ratio_V(i), i=1,g%N_vol)
!!$!!c100       format(" cal_ratio_vol > something wrong! sum:",6(1X,ES15.8))
!!$!!c       end if
!!$    end if
!!$  end subroutine cal_ratio_vol

!=======================================================================================
! definition of collection kernels
!=======================================================================================
!!$  function collection_kernel_gol(mass1, mass2) result(p)
!!$    real (PS), intent(in)     :: mass1, mass2
!!$    real (PS)                 :: p,b
!!$!!c    b = 1500.0_PS ! cm^3/g/s
!!$    b = 1530.0_PS ! cm^3/g/s
!!$    p = b*(mass1 + mass2)
!!$  end function collection_kernel_gol

!!$  subroutine cal_collection_kernel_func_gol(g_1, g_2, n,KC)
!!$    type (Group), intent(in)      :: g_1, g_2
!!$    real (PS), dimension(:,:)     :: KC
!!$    integer,intent(in)            :: n
!!$    integer                       :: i, j, jmax
!!$    KC = 0.0_PS
!!$    do i = g_1%N_BIN, 1, -1
!!$       jmax = i
!!$       do j= jmax, 1, -1
!!$          if(  g_1%MS(i,n)%con <= 0.0_PS .or. g_2%MS(j,n)%con <= 0.0_PS ) cycle
!!$          KC(i,j) = g_2%MS(j,n)%con * &
!!$               collection_kernel_gol( g_1%MS(i,n)%mean_mass, &
!!$               g_2%MS(j,n)%mean_mass) * g_1%dt
!!$
!!$       end do
!!$    end do
!!$  end subroutine cal_collection_kernel_func_gol

!!c  subroutine analytical_sol_coal_gol(g, total_time, ofname)
!!c    use DFPORT
!!c    ! **********************************************************************
!!c    ! anlytical solution of collision-coalescence process for Golovin's
!!c    ! kernel.
!!c    ! **********************************************************************
!!c    type (Group), intent(in)         :: g
!!c    integer, parameter               :: DP = SELECTED_REAL_KIND(15,307)
!!c    real(PS), intent(in)             :: total_time
!!c    ! mean mass (g)
!!c    real(DP), parameter              :: m_0 = 4.189e-09_DP
!!c    real(DP), parameter              :: N_0 = 239.0_DP
!!c    real(DP), parameter              :: b = 1530.0
!!c!!c    real(DP), parameter              :: m_0 = 3.33333333333333e-09_DP
!!c!!c    real(DP), parameter              :: N_0 = 300.0_DP
!!c!!c    real(DP), parameter              :: b = 1500.0
!!c    character (len = *)              :: ofname
!!c    real(DP), pointer, dimension(:)  :: m_total, n_total
!!c    integer                          :: i
!!c    real(DP)                         :: xstep
!!c    real(DP)                         :: x1, x2, m1, m2, TN, TM, tau,s, n1, n2
!!c    real(DP)                         :: dum1, dum2, L
!!c    real(DP)                         :: besout
!!c    real(DP), external               :: DBSI1
!!c!!c    complex, parameter               :: c1 = (0.0, -1.570796327)
!!c!!c    complex, parameter               :: c2 = (0.0, 1.570796327)
!!c    allocate( n_total(g%N_BIN))
!!c    allocate( m_total(g%N_BIN))
!!c
!!c    ! +++ initialize +++
!!c    TN = 0.0_DP
!!c    TM = 0.0_DP
!!c    n_total = 0.0_DP
!!c    m_total = 0.0_DP
!!c
!!c!!c    c1 = (0.0, -PI/2.0)
!!c!!c    c2 = (0.0, PI/2.0)
!!c
!!c    L = N_0 * m_0
!!c
!!c    x1 = g%binb(1)
!!c    xstep = x1/1000.0
!!c    x2 = x1 + xstep
!!c
!!c    i = 1
!!c    do
!!c       if( g%binb(i+1) <= x1 ) then
!!c          i = i + 1
!!c          x1 = g%binb(i)
!!c          xstep = x1/1000.0
!!c          x2 = x1 + xstep
!!c          !          write(*,*) "Now calculating bin ", i
!!c          if( i > g%N_BIN ) exit
!!c       end if
!!c
!!c       tau = 1.0 - exp(-L*b*total_time)
!!c
!!c       dum1 = log(3.0*x1/(4.0*PI))/3.0
!!c       s = x1/m_0
!!c!!c       besout = DBSI1(2.0_PS*sqrt(tau)*s)
!!c!!c       besout = real(exp(c1))*DBESJ1(2.0_PS*sqrt(tau)*s*exp(c2))
!!c!!c       besout = real(exp(c1))*DBESJ1(2.0_PS*sqrt(tau)*s*real(exp(c2)))
!!c!!c       m1 = (3.0_PS*L*s/sqrt(tau)) * (1.0_PS-tau) * besout *&
!!c!!c           exp( - (1.0_PS + tau))
!!c
!!c       m1 = (3.0_PS*L/2.0_PS/sqrt(PI))* sqrt(s)*&
!!c            exp( - ((sqrt(tau)-1.0_PS)**2.0)*s - L*b*total_time)
!!c       n1 = m1/(3.0*(x1**2.0))
!!c
!!c       dum2 = log(3.0*x2/(4.0*PI))/3.0
!!c       s = x2/m_0
!!c!!c       besout = DBSI1(2.0_PS*sqrt(tau)*s)
!!c!!c       besout = real(exp(c1))*DBESJ1(2.0_PS*sqrt(tau)*s*exp(c2))
!!c!!c       besout = real(exp(c1))*DBESJ1(2.0_PS*sqrt(tau)*s*real(exp(c2)))
!!c!!c       besout = exp(c1)*DBESJ1(2.0_PS*sqrt(tau)*s*exp(c2))
!!c!!c       m2 = (3.0_PS*L*s/sqrt(tau)) * (1.0_PS-tau) * besout *&
!!c!!c           exp( - (1.0_PS + tau))
!!c       m2 = (3.0_PS*L/2.0_PS/sqrt(PI))* sqrt(s)*&
!!c            exp( - ((sqrt(tau)-1.0_PS)**2.0)*s - L*b*total_time)
!!c       n2 = m2/(3.0*(x2**2.0))
!!c
!!c
!!c       n_total(i) = n_total(i) + (n1+n2)*(x2-x1)/2.0
!!c       m_total(i) = m_total(i) + (m1+m2)*(dum2-dum1)/2.0
!!c
!!c       x1 = x1 + xstep
!!c       x2 = x2 + xstep
!!c    end do
!!c
!!c    do i=1, g%N_BIN
!!c       TN = TN + n_total(i)
!!c       TM = TM + m_total(i)
!!c    end do
!!c
!!c    open( unit=1, file=ofname)
!!c    write(1,*) "# total concentration: ", TN
!!c    write(1,*) "# total mass: ",TM
!!c    do i=1, g%N_BIN
!!c       write(1,*) i, n_total(i), m_total(i)/TM
!!c    end do
!!c    close(1)
!!c
!!c    deallocate (n_total)
!!c    deallocate (m_total)
!!c
!!c  end subroutine analytical_sol_coal_gol

!!$  subroutine cal_Collision_Efficiency( g_1, i, g_2, j,n,E_c )
!!$    use mod_amps_utility, only: getdrpdrp, getcrydrp, getgpxdrp
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the collision efficiency.
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    type (Group), intent(in)               :: g_1, g_2
!!$    integer, intent(in)                    :: i, j,n
!!$    ! collection efficiency
!!$    real(PS)       :: E_c
!!$
!!$
!!$!!c    write(*,*) "habit",g_1%IS(i,n)%sh_type
!!$
!!$    if( ( g_1%token == 1 .and. g_2%token == 1 ) .or. &
!!$         ( g_1%token == 1 .and. g_2%token == 11 ) ) then
!!$       E_c = getdrpdrp(real(g_1%MS(i,n)%Nre,PS_KIND), real(g_2%MS(j,n)%len/g_1%MS(i,n)%len,PS_KIND))
!!$!!c       E_c=1.0_PS
!!$       if(E_c>15.0) then
!!$          write(*,*) "E_c is really large, set to 15.0", E_c
!!$          E_c=15.0_PS
!!$       endif
!!$
!!$    else if( ( g_1%token == 2 .and. g_2%token == 1  ) .or. &
!!$         ( g_1%token == 2 .and. g_2%token == 11  ) ) then
!!$       ! --- case of a ice crystal collecting a rain drop ---
!!$       if( g_1%IS(i,n)%sh_type <= 2 ) then
!!$          if(g_1%IS(i,n)%habit==0) then
!!$             write(*,*) g_1%MS(i,n)%con,g_1%MS(i,n)%mass(1)
!!$          end if
!!$          E_c = getcrydrp(g_1%IS(i,n)%habit, real(g_2%MS(j,n)%Nre,PS_KIND),real(g_1%MS(i,n)%Nre,PS_KIND))
!!$       else if( g_1%IS(i,n)%sh_type >= 3 ) then
!!$          ! --- graupel ---
!!$          E_c = getgpxdrp(real(g_1%MS(i,n)%den,PS_KIND), &
!!$               real(g_1%MS(i,n)%Nre,PS_KIND),&
!!$               real(g_2%MS(j,n)%len*0.5/max(g_1%MS(i,n)%semi_a,g_1%MS(i,n)%semi_c),PS_KIND))
!!$       end if
!!$!!c       write(*,'(2I3,5ES16.9)') i,j,E_c
!!$    else if( g_1%token == 2 .and. g_2%token == 2  ) then
!!$       ! --- case of a frozen hydrometeor collectiong a frozen hydrometeor ---
!!$       E_c=1.0_PS
!!$    end if
!!$
!!$    E_c = max(E_c, 0.0_PS)
!!$!!c    write(*,*) "E_c finish"
!!$  end subroutine cal_Collision_Efficiency

  subroutine cal_sig_sf(D_0,R,Nx,H_s,mu_s,sig_s)
    use mod_amps_utility, only: &
       zbrent
    real(DS), intent(in) :: D_0,R,H_s,mu_s,Nx!,D_coal
    real(DS), intent(inout) :: sig_s
!!c    real(DS) :: zbrent,bsig
    !real(DS) :: bsig
    integer,parameter :: ITER=10
    integer :: i

    sig_s=1.0_DS/(H_s*coedsq2p)

    if(R<1.0e-20_DS) return


!!c    do i=1,ITER
!!c       bsig=sig_s
!!c       sig_s=1.0_DS/(H_s*coedsq2p)/&
!!c           (getznorm2((D_coal-mu_s)/sig_s )-getznorm2((D_0-mu_s)/sig_s ))
!!c       if(abs((bsig-sig_s)/sig_s)<0.01_DS) then
!!c          exit
!!c       end if
!!c    end do
    do i=1,ITER
!!c       sig_s=zbrent(FSIG,sig_s*1.0e-8,sig_s*10.0_RP,1.0e-4_DS)
       sig_s=zbrent(1,0.0_DS,Nx,H_s,D_0,mu_s,sig_s,0.0_DS,0.0_DS,&
            sig_s*1.0e-8_DS,sig_s*10.0_DS,1.0e-4_DS)

       if(sig_s==-999.9_DS) then
          sig_s=1.0_DS/(H_s*coedsq2p)/10.0**real(i,PS_KIND)
       else
          exit
       end if
    end do


!!$  contains
!!$    function FSIG(x) result(out)
!!$      real(DS) :: x,out
!!$
!!$!!c      out=1.0_DS-(getznorm2((D_coal-mu_s)/x )-getznorm2((D_0-mu_s)/x))
!!$!!c         out=1.0_DS-getznorm2((D_coal-mu_s)/x )
!!$
!!$      out=x-Nx/H_s/coedsq2p/(&
!!$           1.0_DS-&
!!$           getznorm2((D_0-mu_s)/x))
!!$
!!$    end function FSIG
  end subroutine cal_sig_sf

  subroutine cal_Hmusig(D_0,R,lin_mu,P_mode,Nx,H,mu,sig)
    use mod_amps_utility, only: &
       zbrent
    real(DS),intent(in) :: D_0,R,lin_mu,P_mode,Nx
    real(DS),intent(inout) :: H,mu,sig
    integer,parameter :: ITER=10
    integer :: i
!!c    real(DS) :: zbrent,osig
    real(DS) :: osig

    sig=10.0_DS*lin_mu
    if(Nx<=1.0e-20.or.P_mode<=1.0e-20.or.R<=1.0e-20) then
       H=0.0_DS
       mu=0.0_DS
       return
    end if




    do i=1,ITER
       osig=sig
!!c       sig=zbrent(FSIG2,sig*1.0e-5,sig*10.0_RP,1.0e-4_DS)
       sig=zbrent(2,P_mode,Nx,H,D_0,lin_mu,sig,0.0_DS,0.0_DS,&
            sig*1.0e-5,sig*10.0_RP,1.0e-4_DS)
       if(sig==-999.9_DS) then
          sig=osig*1.5_RP
       else
          exit
       end if
    end do

    H=P_mode*lin_mu*exp(0.5_DS*sig**2)
    mu=log(lin_mu)+sig**2

!!$  contains
!!$    function FSIG2(x) result(out)
!!$      real(DS) :: x,out
!!$
!!$      H=P_mode*lin_mu*exp(0.5_DS*x**2)
!!$      mu=log(lin_mu)+x**2
!!$!!c      out=x-(Nx/H)*0.797884560802865_RP/(1.0_DS+&
!!$!!c           2.0_DS*getznorm2(sq_twod*(mu-dlog(D_0))/(sq_twod*x))-1.0_DS  )
!!$      out=x-Nx/H/coedsq2p/(&
!!$           1.0_DS-&
!!$           getznorm2((dlog(D_0)-mu)/x))
!!$
!!$    end function FSIG2
!!$
!!$
  end subroutine cal_Hmusig



!!$  subroutine cal_coef_mat(N_BIN, distype, binb, A, n_nzero, index_bin)
!!$    ! **********************************************************************
!!$    ! Calculate the coefficient matrix to obtain the parameters
!!$    ! of the distribution which is not linear
!!$    ! **********************************************************************
!!$    integer, intent(in)       :: N_BIN, n_nzero
!!$    real(PS), dimension(:)    :: binb
!!$    real(PS), dimension(:,:)  :: A
!!$
!!$    integer,  dimension(:)    :: index_bin
!!$    ! total number of unknown parameters
!!$    integer  :: tn
!!$
!!$    ! smallest bin number with nonzero con and mass
!!$    integer  :: min_bin
!!$
!!$    ! type of distribution
!!$    integer :: distype
!!$
!!$    integer :: i,j!, var_Status
!!$
!!$    ! +++ Allocate the memory for change of mass and concentration +++
!!$    !    allocate( A(t_n,t_n), stat = var_Status)
!!$    !    if(var_Status /= 0 ) stop "Memory not available for A &
!!$    !         in cal_coef_mat"
!!$
!!$    if( distype == 2 ) then
!!$       ! +++ case of parabolic approx. +++
!!$       tn = 3*N_BIN
!!$
!!$       ! initialize the coefficient matrix
!!$       do i=1, tn
!!$          do j=1, tn
!!$             A(i,j) = 0.0
!!$          end do
!!$       end do
!!$
!!$       do i=1, N_BIN
!!$          if( index_bin(i) /= 0 ) then
!!$             min_bin = i
!!$             exit
!!$          end if
!!$       end do
!!$
!!$       j=1
!!$       do i=1, N_BIN
!!$          if( index_bin(i) == 0 ) cycle
!!$          A(j,(j-1)*3+1) = ( binb(i+1)**3.0 - binb(i)**3.0 )/3.0
!!$          A(j,(j-1)*3+2) = ( binb(i+1)**2.0 - binb(i)**2.0)/2.0
!!$          A(j,(j-1)*3+3) = binb(i+1) - binb(i)
!!$          A(j+n_nzero,(j-1)*3+1) = ( binb(i+1)**4.0 - binb(i)**4.0)/4.0
!!$          A(j+n_nzero,(j-1)*3+2) = A(j,(j-1)*3+1)
!!$          A(j+n_nzero,(j-1)*3+3) = A(j,(j-1)*3+2)
!!$
!!$
!!$          if ( j <= n_nzero .AND. j > 1) then
!!$             if( index_bin(i-1) /= 0 ) then
!!$                A(j+2*n_nzero,(j-1)*3+1) = binb(i)**2.0
!!$                A(j+2*n_nzero,(j-1)*3+2) = binb(i)
!!$                A(j+2*n_nzero,(j-1)*3+3) = 1.0
!!$                A(j+2*n_nzero,(j-1)*3-2) = - A(j+2*n_nzero,(j-1)*3+1)
!!$                A(j+2*n_nzero,(j-1)*3-1) = - A(j+2*n_nzero,(j-1)*3+2)
!!$                A(j+2*n_nzero,(j-1)*3) = - A(j+2*n_nzero,(j-1)*3+3)
!!$             else if( index_bin(i-1) == 0 ) then
!!$                A(j+2*n_nzero,(j-1)*3+1) = binb(i)**2.0
!!$                A(j+2*n_nzero,(j-1)*3+2) = binb(i)
!!$                A(j+2*n_nzero,(j-1)*3+3) = 1.0
!!$             end if
!!$          else if ( j == 1 ) then
!!$             A(j+2*n_nzero,(j-1)*3+1) = binb(i)**2.0
!!$             A(j+2*n_nzero,(j-1)*3+2) = binb(i)
!!$             A(j+2*n_nzero,(j-1)*3+3) = 1.0
!!$          end if
!!$          j = j + 1
!!$       end do
!!$    else if( distype == 3 ) then
!!$       ! +++ case of parabolic approx. +++
!!$       tn = 4*N_BIN
!!$
!!$       ! initialize the coefficient matrix
!!$       do i=1, tn
!!$          do j=1, tn
!!$             A(i,j) = 0.0
!!$          end do
!!$       end do
!!$
!!$       do i=1, N_BIN
!!$          if( index_bin(i) /= 0 ) then
!!$             min_bin = i
!!$             exit
!!$          end if
!!$       end do
!!$
!!$
!!$       do i=1, N_BIN
!!$          if( index_bin(i) == 0 ) then
!!$             cycle
!!$          else
!!$             j=index_bin(i)
!!$          end if
!!$          A(j,(j-1)*4+1) = ( binb(i+1)**4.0 - binb(i)**4.0)/4.0
!!$          A(j,(j-1)*4+2) = ( binb(i+1)**3.0 - binb(i)**3.0 )/3.0
!!$          A(j,(j-1)*4+3) = ( binb(i+1)**2.0 - binb(i)**2.0)/2.0
!!$          A(j,(j-1)*4+4) = binb(i+1) - binb(i)
!!$
!!$          A(j+n_nzero,(j-1)*4+1) = ( binb(i+1)**5.0 - binb(i)**5.0)/5.0
!!$          A(j+n_nzero,(j-1)*4+2) = A(j,(j-1)*4+1)
!!$          A(j+n_nzero,(j-1)*4+3) = A(j,(j-1)*4+2)
!!$          A(j+n_nzero,(j-1)*4+4) = A(j,(j-1)*4+3)
!!$       end do
!!$
!!$       ! +++ condition of continuous curve C0 +++
!!$       j=1
!!$       do i=1, N_BIN+1
!!$          if ( 1 < j .AND. j < n_nzero+1 ) then
!!$             if( index_bin(i-1) /= 0.0_PS .AND. index_bin(i) == 0.0_PS ) then
!!$                A(j+2*n_nzero,(j-1)*4+1) = binb(i)**3.0
!!$                A(j+2*n_nzero,(j-1)*4+2) = binb(i)**2.0
!!$                A(j+2*n_nzero,(j-1)*4+3) = binb(i)
!!$                A(j+2*n_nzero,(j-1)*4+4) = 1.0
!!$             else if( index_bin(i-1) == 0.0_PS .AND. index_bin(i) /= 0.0_PS ) then
!!$                A(j+2*n_nzero,(j-1)*4+1) = binb(i)**3.0
!!$                A(j+2*n_nzero,(j-1)*4+2) = binb(i)**2.0
!!$                A(j+2*n_nzero,(j-1)*4+3) = binb(i)
!!$                A(j+2*n_nzero,(j-1)*4+4) = 1.0
!!$             else if( index_bin(i-1) == 0.0_PS .AND. index_bin(i) == 0.0_PS ) then
!!$                cycle
!!$             else
!!$                A(j+2*n_nzero,(j-1)*4+1) = binb(i)**3.0
!!$                A(j+2*n_nzero,(j-1)*4+2) = binb(i)**2.0
!!$                A(j+2*n_nzero,(j-1)*4+3) = binb(i)
!!$                A(j+2*n_nzero,(j-1)*4+4) = 1.0
!!$                A(j+2*n_nzero,(j-1)*4-3) = - A(j+2*n_nzero,(j-1)*4+1)
!!$                A(j+2*n_nzero,(j-1)*4-2) = - A(j+2*n_nzero,(j-1)*4+2)
!!$                A(j+2*n_nzero,(j-1)*4-1) = - A(j+2*n_nzero,(j-1)*4+3)
!!$                A(j+2*n_nzero,(j-1)*4) = - A(j+2*n_nzero,(j-1)*4+4)
!!$             end if
!!$          else if ( j == 1 ) then
!!$             A(j+2*n_nzero,(j-1)*4+1) = binb(i)**3.0
!!$             A(j+2*n_nzero,(j-1)*4+2) = binb(i)**2.0
!!$             A(j+2*n_nzero,(j-1)*4+3) = binb(i)
!!$             A(j+2*n_nzero,(j-1)*4+4) = 1.0
!!$          else if( j == n_nzero+1 ) then
!!$             A(j+2*n_nzero,(j-1)*4-3) = binb(i)**3.0
!!$             A(j+2*n_nzero,(j-1)*4-2) = binb(i)**2.0
!!$             A(j+2*n_nzero,(j-1)*4-1) = binb(i)
!!$             A(j+2*n_nzero,(j-1)*4) = 1.0
!!$          end if
!!$          j = j + 1
!!$       end do
!!$
!!$
!!$       ! +++ condition of continuous gradient C1 +++
!!$       j=2
!!$       do i=2, N_BIN
!!$          if( index_bin(i-1) == 0.0_PS .OR. index_bin(i) == 0.0_PS ) then
!!$             cycle
!!$          else
!!$             A(j+3*n_nzero,(j-1)*4+1) = 3.0_PS*binb(i)**2.0
!!$             A(j+3*n_nzero,(j-1)*4+2) = 2.0_PS*binb(i)
!!$             A(j+3*n_nzero,(j-1)*4+3) = 1.0_PS
!!$             A(j+3*n_nzero,(j-1)*4+4) = 0.0_PS
!!$             A(j+3*n_nzero,(j-1)*4-3) = - A(j+3*n_nzero,(j-1)*4+1)
!!$             A(j+3*n_nzero,(j-1)*4-2) = - A(j+3*n_nzero,(j-1)*4+2)
!!$             A(j+3*n_nzero,(j-1)*4-1) = - A(j+3*n_nzero,(j-1)*4+3)
!!$             A(j+3*n_nzero,(j-1)*4) = - A(j+3*n_nzero,(j-1)*4+4)
!!$          end if
!!$          j = j + 1
!!$       end do
!!$    end if
!!$  end subroutine cal_coef_mat

!!$  subroutine weighting_quality3( g, nN, NM, nQ, nmtend)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! This subroutine finishes weighting of length and volume variables
!!$    ! The volume dimension is used for length.
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    type (Group), intent(inout) :: g
!!$    real(PS),   dimension(:)    :: nN
!!$    real(PS),   dimension(:,:)  :: nM
!!$    real(PS),   dimension(:,:)  :: nQ
!!$    real(PS),   dimension(:)    :: nmtend
!!$    ! axis ratio
!!$    real(PS)                    :: phi
!!$    ! mean mass
!!$    real(PS)                    :: mean_mass
!!$    ! possible minimum length by considering the density
!!$    real(PS)                    :: min_alen
!!$    ! possible maximum density of ice
!!$    real(PS), parameter         :: den_max = 0.91668
!!$
!!$    integer                     :: i,j
!!$
!!$    if( g%token == 1 ) then
!!$       ! --- case of liquid phase ---
!!$       return
!!$    else if( g%token == 2 ) then
!!$       ! --- case of solid phase ---
!!$       do i=1, g%N_BIN
!!$          if( nN(i) == 0.0_PS .OR. nM(i, 1) == 0.0_PS ) cycle
!!$          do j=1, 2
!!$             ! weighting by concentration
!!$             nQ(i,j) = nQ(i,j)/nN(i)
!!$             nQ(i,j) = nQ(i,j)**(1.0/3.0)
!!$!!c             ! weighting by mass
!!$!!c             nQ(i,j) = nQ(i,j)/nM(i,1)
!!$!!c             nQ(i,j) = nQ(i,j)**(1.0/3.0)
!!$          end do
!!$          do j=1, g%N_vol
!!$             ! weighting by concentration
!!$             nQ(i,2+j) = nQ(i,2+j)/nN(i)
!!$!!c             ! weighting by mass
!!$!!c             nQ(i,j) = nQ(i,j)/nM(i,1)
!!$!!c             nQ(i,j) = nQ(i,j)**(1.0/3.0)
!!$          end do
!!$          nmtend(i) = nmtend(i)/nN(i)
!!$
!!$          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$          ! check the minimum possible length
!!$          phi = nQ(i,2)/nQ(i,1)
!!$          mean_mass = nM(i,1)/nN(i)
!!$          min_alen = (3.0_PS*mean_mass/(4.0_PS*PI*phi*den_max))**(1.0/3.0)
!!$          if( nQ(i,1) < min_alen ) then
!!$!!c             write(*,*) "weighting_quality3 > the length reached minimum possible &
!!$!!c                  length at ", i
!!$             nQ(i,1) = min_alen
!!$             nQ(i,2) = min_alen*phi
!!$          end if
!!$          ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$       end do
!!$    end if
!!$  end subroutine weighting_quality3

!!$  subroutine print_Ice_Shape(g, cur_time, ofname)
!!$    type (Group), intent(in)   :: g
!!$    real(PS), intent(in)               :: cur_time
!!$    character (len = *)                :: ofname
!!$    integer                            :: i,n
!!$    !
!!$300 format( F8.1, I4, 3( 2X, ES17.8E3), 2(I2), ES17.8E3)
!!$    !
!!$    open( unit=1, file=ofname)
!!$
!!$    write(1,*) "# (1) time, (2) bin No, (3) a', (4) c', (5) d, (6) habit, (7) sh_type, (8) BinB "
!!$
!!$    do n=1,g%L
!!$       ! loop over grid points
!!$       if(g%mark_cm(n)==3) cycle
!!$       write(1,*) "# grid number",n
!!$       do i = 1, g%N_BIN
!!$          write(1,300) cur_time, i, g%IS(i,n)%a, g%IS(i,n)%c, g%IS(i,n)%d, g%IS(i,n)%habit, &
!!$               g%IS(i,n)%sh_type, g%binb(i)
!!$       end do
!!$       write(1,300) cur_time, (g%N_BIN+1), g%IS(g%N_BIN,n)%a, g%IS(g%N_BIN,n)%c, &
!!$            g%IS(g%N_BIN,n)%d, &
!!$            g%IS(g%N_BIN,n)%habit, &
!!$            g%IS(g%N_BIN,n)%sh_type, g%binb(g%N_BIN)
!!$       write(1,*) " "
!!$    end do
!!$    close(1)
!!$  end subroutine print_Ice_Shape



!!c  subroutine cat_agg_graupel(g, V_cs, level)
!!c    type (Group), intent(in)   :: g
!!c    integer, intent(in)    ::  level
!!c    ! Volume of circumscribing spheroid
!!c    real(PS), pointer, dimension(:)        :: V_cs
!!c    integer                                :: i
!!c
!!c    if( level == 1) then
!!c       return
!!c    else if( level == 2 .or. level == 3 ) then
!!c       do i = 1, g%N_BIN
!!c          if( g%MS(i)%con <= 0.0_PS ) cycle
!!c          if( g%MS(i)%vol(1)/g%MS(i)%con >= &
!!c              ( V_cs(i) - g%IS(i,n)%V_ic )) then
!!c             g%IS(i,n)%habit = 7
!!c          else
!!c             if( g%IS(i,n)%habit == 1) then
!!c                g%IS(i,n)%habit == 4
!!c             else if( g%IS(i,n)%habit == 2) then
!!c                g%IS(i,n)%habit == 5
!!c             else if( g%IS(i,n)%habit == 3) then
!!c                g%IS(i,n)%habit == 6
!!c             end if
!!c          end if
!!c       end do
!!c    else if( level == 4 .or. level == 5 ) then
!!c       do i = 1, g%N_BIN
!!c          if( g%MS(i)%con <= 0.0_PS ) cycle
!!c          if( g%MS(i)%vol(1)/g%MS(i)%con >= &
!!c              ( V_cs(i) - g%MS(i)%vol(2)/g%MS(i)%con - g%IS(i,n)%V_ic )) then
!!c             g%IS(i,n)%habit = 7
!!c          else
!!c             if( g%IS(i,n)%habit == 1) then
!!c                g%IS(i,n)%habit == 4
!!c             else if( g%IS(i,n)%habit == 2) then
!!c                g%IS(i,n)%habit == 5
!!c             else if( g%IS(i,n)%habit == 3) then
!!c                g%IS(i,n)%habit == 6
!!c             end if
!!c          end if
!!c       end do
!!c    end if
!!c
!!c
!!c  end subroutine cat_agg_graupel

!!$  function mod_par( A, p, q) result(out)
!!$    real(PS), intent(in)        :: p, q, A
!!$    real(PS)                    :: out, dum1
!!$    dum1 = (q**(A+1)-1.0)/(A+1.0)
!!$    out = ( dum1*((q-1.0)**2.0)-6.0*(p-(q+1.0)/2.0)*( &
!!$         dum1*(q+1.0)-2.0*(q**(A+2.0)-1.0)/(A+2.0)) )/ &
!!$         (p**A)*((q-1.0)**3.0)
!!$  end function mod_par

!!$  function F_m( g, p, i, n) result(out)
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! Integrate mass over concenration/mass
!!$    !
!!$    ! \int m^p n(m) dm
!!$    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    type (Group), intent(in)  :: g
!!$    ! order of moment, p
!!$    real (PS), intent(in)        :: p
!!$    ! bin number you are calculating
!!$    integer, intent(in)          :: i,n
!!$    real (PS)       :: out
!!$    ! power
!!$    real (PS)       :: P1, P2
!!$    ! right and left boundaries of integration
!!$    real (PS)       :: left_bd, right_bd
!!$
!!$    if( g%MS(i,n)%dis_type == 1 ) then
!!$       ! --- case of linear distribution ---
!!$       P1 = p + 1.0_PS
!!$       P2 = p + 2.0_PS
!!$       if( g%MS(i,n)%p(1) >= 0.0_PS ) then
!!$          left_bd = g%binb(i)
!!$          right_bd = g%binb(i+1)
!!$       else if( g%MS(i,n)%p(1) == -1.0_PS ) then
!!$          left_bd = g%MS(i,n)%p(2)
!!$          right_bd = g%binb(i+1)
!!$       else if( g%MS(i,n)%p(1) == -2.0_PS ) then
!!$          left_bd = g%binb(i)
!!$          right_bd = g%MS(i,n)%p(2)
!!$       end if
!!$
!!$       out = ( max(g%MS(i,n)%p(1),0.0d+0) -g%MS(i,n)%p(3)*g%MS(i,n)%p(2) ) * &
!!$            (1.0_PS/P1)*( right_bd**P1 - left_bd**P1 ) + &
!!$            g%MS(i,n)%p(3)*(1.0_PS/P2)*( right_bd**P2 - left_bd**P2 )
!!$    end if
!!$  end function F_m

!!$  subroutine cal_total_conmass(g)
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! calculate the total concentration and mass for rain spectrum and
!!$    ! put them into 1st bin.
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    ! case of bulk water parameterization, this should be rain cat.
!!$    type (Group), intent(inout)        :: g
!!$    integer                            :: i,n
!!$
!!$    if( g%token /= 12 ) then
!!$       return
!!$    end if
!!$    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$    do n=1,g%L
!!$       do i = 2, g%N_BIN
!!$          g%MS(1,n)%con = g%MS(1,n)%con + g%MS(i,n)%con
!!$          g%MS(1,n)%mass(1) = g%MS(1,n)%mass(1) + g%MS(i,n)%mass(1)
!!$       end do
!!$    end do
!!$end subroutine cal_total_conmass

!!c  subroutine cal_devide_conmass(g, mdr)
!!c    ! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    ! devide the whole spectrum into bins and calculate concentration and mass
!!c    ! for each bin.
!!c    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    type (Group), intent(inout)        :: g
!!c    type (Vec_Group), optional          :: mdr
!!c    integer                            :: i
!!c    real (PS)                          :: lambda, N_0
!!c    ! equivalent diameteor at the bin limits, and its parameter
!!c    real (PS)                          :: D_1, D_2, t_1, t_2
!!c    ! scaling diameter, normalization factor for truncated distribution
!!c    real (PS)                          :: D_n, s
!!c
!!c    ! get scaling diameter (cm)
!!!    D_n = get_interp1(mdr, g%MS(1)%mass(1)/g%MS(1)%con)
!!c    ! normalization factor
!!c    D_1 = (6.0_PS*g%binb(1)/(PI*den_w))**(1.0/3.0)
!!c    D_2 = (6.0_PS*g%binb(g%N_binb)/(PI*den_w))**(1.0/3.0)
!!c    s = exp(-D_1/D_n)-exp(-D_2/D_n)
!!c
!!c    ! slope (mm^-1) of MP
!!c    lambda = 0.1_PS/D_n
!!!    lambda = 0.1_PS*(den_w*PI*g%MS(1)%con/g%MS(1)%mass(1))**(1.0/3.0)
!!c    ! intercept (m^-3 mm^-1)
!!c    N_0 = (lambda * (g%MS(1)%con/s)) * 1.0e+6_PS
!!c
!!c    do i = 1, g%N_BIN
!!c       ! +++ calculate the diameteor at bin boundaries +++
!!c       D_1 = (6.0_PS*g%binb(i)/(PI*den_w))**(1.0/3.0)
!!c       D_2 = (6.0_PS*g%binb(i+1)/(PI*den_w))**(1.0/3.0)
!!c       ! +++ change the unit into mm +++
!!c       D_1 = D_1*10.0_PS
!!c       D_2 = D_2*10.0_PS
!!c
!!c       t_1 = D_1*lambda
!!c       t_2 = D_2*lambda
!!c       g%MS(i,n)%con = (N_0/lambda) * ( exp(-lambda*D_1) - exp(-lambda*D_2))
!!c
!!c       g%MS(i,n)%mass(1) = (t_1**3.0+3.0_PS*(t_1**2.0)+6.0_PS*t_1+6.0_PS)*exp(-t_1)&
!!c            - (t_2**3.0+3.0_PS*(t_2**2.0)+6.0_PS*t_2+6.0_PS)*exp(-t_2)
!!c       g%MS(i,n)%mass(1) = (PI/6.0_PS)*0.001_PS*(N_0/(lambda**4.0)) * g%MS(i,n)%mass(1)
!!c
!!c       ! +++ change the unit into cm^-3 from m^-3 +++
!!c       g%MS(i,n)%con = g%MS(i,n)%con/1000000.0_PS
!!c       g%MS(i,n)%mass(1) = g%MS(i,n)%mass(1)/1000000.0_PS
!!c    end do
!!c  end subroutine cal_devide_conmass

!!$  subroutine print_out( g,ag, cur_time,output_format,ID,JD,KD,iproc,istrt)
!!$!   use omp_lib
!!$    type (Group), intent(in)       :: g
!!$    ! thermo variable object
!!$    type (AirGroup) :: ag
!!$    real(PS), intent(in)     :: cur_time
!!$    character(len=16),intent(in) :: output_format
!!$    integer,intent(in) :: iproc,istrt
!!$    integer :: ID(g%L),JD(g%L),KD(g%L)
!!$
!!$    ! output file names
!!$    character(len=20)  :: string_prefix1, string_prefix2,string_prefix3, string_prefix4
!!$    character(len=20)  :: string_prefix5,string_prefix6
!!$    character(len=20)  :: string_postfix
!!$    character(len=6)   :: string_time
!!$    character(len=46)  :: ofname,ofname2
!!$    real(PS)           :: digit
!!$
!!$    integer            :: inum, jnum,i,ifunit
!!$    character(len=2) :: cproc
!!$
!!$    ! +++ make names of output files +++
!!$    !!        write(string_time, *) int(cur_time/60.0_PS)
!!$
!!$    if( g%token == 2 ) then
!!$       string_prefix1 = "cm_s_"
!!$       string_prefix2 = "dg_s_"
!!$       string_prefix3 = "ice_"
!!$       string_prefix4 = "n2s_"
!!$       string_prefix5 = "n3s_"
!!$       string_prefix6 = "mat_s_"
!!$    else if( g%token == 11 ) then
!!$       string_prefix1 = "cm_c_"
!!$       string_prefix2 = "dg_c_"
!!$       string_prefix4 = "n2c_"
!!$       string_prefix5 = "n3c_"
!!$       string_prefix6 = "mat_c_"
!!$    else if( g%token == 1 .or.  g%token == 12) then
!!$       string_prefix1 = "cm_r_"
!!$       string_prefix2 = "dg_r_"
!!$       string_prefix4 = "n2r_"
!!$       string_prefix5 = "n3r_"
!!$       string_prefix6 = "mat_r_"
!!$    else if( g%token == 3 ) then
!!$       string_prefix1 = "cm_a_"
!!$       string_prefix2 = "dg_a_"
!!$       string_prefix4 = "n2a_"
!!$       string_prefix5 = "n3a_"
!!$       string_prefix6 = "mat_a_"
!!$    end if
!!$    string_time = "000000"
!!$!!c    string_postfix="m.dat"          ! in minites
!!$    string_postfix="s.dat"          ! in seconds
!!$
!!$
!!$!!c    inum = int(cur_time/60.0_PS)
!!$    inum = floor(cur_time+1.0e-5)
!!$    digit = 1.0
!!$    do
!!$       inum = inum/10
!!$       if( inum /= 0 ) then; digit = digit + 1.0
!!$       else if( inum == 0 ) then; exit
!!$       end if
!!$    end do
!!$
!!$!!c    write(*,*) "print_out bf inum"
!!$!!c    inum = int(cur_time/60.0_PS)
!!$    inum = floor(cur_time+1.0e-5)
!!$    do
!!$       jnum = inum/int(10.0**(floor(digit+1.0e-5)-1))
!!$       inum = inum - jnum*int(10.0**(floor(digit+1.0e-5)-1))
!!$       string_time(6-int(digit)+1:6-int(digit)+1) = achar(jnum+48)
!!$       digit = digit - 1.0
!!$       if( digit <= 0.0 ) exit
!!$    end do
!!$
!!$
!!$
!!$!!c    ofname = trim(string_prefix1) // trim(string_time)
!!$!!c    ofname = trim(ofname) // trim(string_postfix)
!!$!!c    call print_con_mass( g, cur_time, ofname)
!!$
!!$
!!$!!c    ofname = trim(string_prefix2) // trim(string_time)
!!$!!c    ofname = trim(ofname) // trim(string_postfix)
!!$!!c    call print_diag_pq( g, cur_time, ofname )
!!$
!!$!!c    if( g%token == 2 ) then
!!$!!c        ofname = trim(string_prefix3) // trim(string_time)
!!$!!c        ofname = trim(ofname) // trim(string_postfix)
!!$!!c        call print_Ice_Shape( g, cur_time, ofname)
!!$!!c    end if
!!$!!c    if( g%org_dtype /= 0 ) then
!!$!!c       ofname = trim(string_prefix4) // trim(string_time)
!!$!!c       ofname = trim(ofname) // trim(string_postfix)
!!$!!c       call print_n_2( g, cur_time, ofname)
!!$!!c
!!$    ! add processor number
!!$    write(cproc,'(I2)') iproc
!!$    do i=1,2
!!$      if(cproc(i:i).eq.' ') cproc(i:i)='0'
!!$    enddo
!!$    ifunit=601+iproc
!!$
!!$    ofname = trim(string_prefix5) // trim(string_time)
!!$    ofname = trim(ofname) // trim(string_postfix)//cproc
!!$!!c    call print_n_3( g, cur_time, ofname,ID,JD,KD,istrt,ifunit)
!!$!!c    end if
!!$
!!$    ofname = 'r' // trim(string_prefix6) // trim(string_time)
!!$    ofname = trim(ofname) // trim(string_postfix)//cproc
!!$
!!$!!c    write(*,*) "print_out bf rmat"
!!$
!!$    select case(output_format)
!!$    case('binary')
!!$      ofname2= 'b'// ofname
!!$      call print_brmatlab(g,ag,cur_time,ofname2,ID,JD,KD,istrt,ifunit)
!!$    case default
!!$      call print_rmatlab(g,ag,cur_time,ofname,ID,JD,KD,istrt,ifunit)
!!$    end select
!!$    if( g%token == 2 ) then
!!$       ofname = 'i' // trim(string_prefix6) // trim(string_time)
!!$       ofname = trim(ofname) // trim(string_postfix)//cproc
!!$       ofname2= 'b'// ofname
!!$       select case(output_format)
!!$       case('binary')
!!$         call print_bimatlab(g,ofname2,ID,JD,KD,istrt,ifunit)
!!$       case default
!!$         call print_imatlab(g,ofname,ID,JD,KD,istrt,ifunit)
!!$       end select
!!$    endif
!!$  end subroutine print_out
!!$  subroutine print_out_ap( g,ag, cur_time,output_format,ID,JD,KD,iproc,istrt,nc)
!!$    ! number of categores for the group
!!$    integer, intent(in) :: nc,iproc,istrt
!!$    type (Group), dimension(nc)       :: g
!!$    ! thermo variable object
!!$    type (AirGroup) :: ag
!!$    real(PS), intent(in)     :: cur_time
!!$    character(len=16),intent(in) :: output_format
!!$    integer :: ID(g(nc)%L),JD(g(nc)%L),KD(g(nc)%L)
!!$
!!$    ! output file names
!!$    character(len=20)  :: string_prefix1, string_prefix2,string_prefix3, string_prefix4
!!$    character(len=20)  :: string_prefix5,string_prefix6
!!$    character(len=20)  :: string_postfix
!!$    character(len=6)   :: string_time
!!$    character(len=46)  :: ofname,ofname2
!!$    real(PS)           :: digit
!!$
!!$    integer            :: inum, jnum,ic,i,ifunit
!!$    character(len=2) :: cproc
!!$
!!$    ! +++ make names of output files +++
!!$    !!        write(string_time, *) int(cur_time/60.0_PS)
!!$    ! add processor number
!!$    write(cproc,'(I2)') iproc
!!$    do i=1,2
!!$      if(cproc(i:i).eq.' ') cproc(i:i)='0'
!!$    enddo
!!$    ifunit=601+iproc
!!$
!!$    do ic=1,nc
!!$       if( g(ic)%token == 2 ) then
!!$          string_prefix1 = "cm_s"
!!$          string_prefix2 = "dg_s"
!!$          string_prefix3 = "ice"
!!$          string_prefix4 = "n2s"
!!$          string_prefix5 = "n3s"
!!$          string_prefix6 = "mat_s"
!!$       else if( g(ic)%token == 11 ) then
!!$          string_prefix1 = "cm_c"
!!$          string_prefix2 = "dg_c"
!!$          string_prefix4 = "n2c"
!!$          string_prefix5 = "n3c"
!!$          string_prefix6 = "mat_c"
!!$       else if( g(ic)%token == 1 .or.  g(ic)%token == 12) then
!!$          string_prefix1 = "cm_r"
!!$          string_prefix2 = "dg_r"
!!$          string_prefix4 = "n2r"
!!$          string_prefix5 = "n3r"
!!$          string_prefix6 = "mat_r"
!!$       else if( g(ic)%token == 3 ) then
!!$          string_prefix1 = "cm_a"
!!$          string_prefix2 = "dg_a"
!!$          string_prefix4 = "n2a"
!!$          string_prefix5 = "n3a"
!!$          string_prefix6 = "mat_a"
!!$       end if
!!$       string_prefix1=trim(string_prefix1)//achar(ic+48)//'_'
!!$       string_prefix2=trim(string_prefix2)//achar(ic+48)//'_'
!!$       string_prefix3=trim(string_prefix3)//achar(ic+48)//'_'
!!$       string_prefix4=trim(string_prefix4)//achar(ic+48)//'_'
!!$       string_prefix5=trim(string_prefix5)//achar(ic+48)//'_'
!!$       string_prefix6=trim(string_prefix6)//achar(ic+48)//'_'
!!$       string_time = "000000"
!!$!!c       string_postfix="m.dat"          ! in minites
!!$       string_postfix="s.dat"          ! in seconds
!!$
!!$
!!$!!c    inum = int(cur_time/60.0_PS)
!!$       inum = floor(cur_time+1.0e-5)
!!$       digit = 1.0
!!$       do
!!$          inum = inum/10
!!$          if( inum /= 0 ) then; digit = digit + 1.0
!!$          else if( inum == 0 ) then; exit
!!$          end if
!!$       end do
!!$!!c    inum = int(cur_time/60.0_PS)
!!$       inum = floor(cur_time+1.0e-5)
!!$       do
!!$          jnum = inum/int(10.0**(floor(digit+1.0e-5)-1))
!!$          inum = inum - jnum*int(10.0**(floor(digit+1.0e-5)-1))
!!$          string_time(6-int(digit)+1:6-int(digit)+1) = achar(jnum+48)
!!$          digit = digit - 1.0
!!$          if( digit <= 0.0 ) exit
!!$       end do
!!$
!!$!!c    ofname = trim(string_prefix1) // trim(string_time)
!!$!!c    ofname = trim(ofname) // trim(string_postfix)
!!$!!c    call print_con_mass( g, cur_time, ofname)
!!$
!!$
!!$!!c    ofname = trim(string_prefix2) // trim(string_time)
!!$!!c    ofname = trim(ofname) // trim(string_postfix)
!!$!!c    call print_diag_pq( g, cur_time, ofname )
!!$
!!$!!c    if( g(ic)%token == 2 ) then
!!$!!c        ofname = trim(string_prefix3) // trim(string_time)
!!$!!c        ofname = trim(ofname) // trim(string_postfix)
!!$!!c        call print_Ice_Shape( g, cur_time, ofname)
!!$!!c    end if
!!$!!c    if( g(ic)%org_dtype /= 0 ) then
!!$!!c       ofname = trim(string_prefix4) // trim(string_time)
!!$!!c       ofname = trim(ofname) // trim(string_postfix)
!!$!!c       call print_n_2( g, cur_time, ofname)
!!$!!c
!!$!!c       ofname = trim(string_prefix5) // trim(string_time)
!!$!!c       ofname = trim(ofname) // trim(string_postfix)
!!$!!c       call print_n_3( g, cur_time, ofname)
!!$!!c    end if
!!$
!!$       ofname = 'r' // trim(string_prefix6) // trim(string_time)
!!$       ofname = trim(ofname) // trim(string_postfix)//cproc
!!$
!!$       select case(output_format)
!!$       case('binary')
!!$         ofname2= 'b'// ofname
!!$         call print_brmatlab(g(ic),ag,cur_time,ofname2,ID,JD,KD,istrt,ifunit)
!!$       case default
!!$         call print_rmatlab(g(ic),ag,cur_time,ofname,ID,JD,KD,istrt,ifunit)
!!$       end select
!!$
!!$       if( g(ic)%token == 2 ) then
!!$          ofname = 'i' // trim(string_prefix6) // trim(string_time)
!!$          ofname = trim(ofname) // trim(string_postfix)
!!$
!!$          select case(output_format)
!!$          case('binary')
!!$             ofname2= 'b'// ofname
!!$             call print_bimatlab(g(ic),ofname,ID,JD,KD,istrt,ifunit)
!!$          case default
!!$             call print_imatlab(g(ic),ofname,ID,JD,KD,istrt,ifunit)
!!$          end select
!!$       end if
!!$    end do
!!$  end subroutine print_out_ap

!!$  subroutine print_2Dvar(g_1,g_2,cur_time,ivar,X2D)
!!$    type (Group),intent(in)      :: g_1,g_2
!!$    real(PS), intent(in)     :: cur_time
!!$    character(len=2) :: ivar
!!$    real(PS),dimension(:,:) :: X2D
!!$    ! output file names
!!$    character(len=20)  :: string_prefix1!,string_prefix2
!!$    character(len=20)  :: string_postfix
!!$    character(len=6)   :: string_time
!!$    character(len=46)  :: ofname!,ofname2
!!$    real(PS)           :: digit
!!$
!!$    integer            :: i,j,inum,jnum!,ic
!!$    ! +++ make names of output files +++
!!$    !!        write(string_time, *) int(cur_time/60.0_PS)
!!$
!!$    if(ivar=="KC") then
!!$       if(g_1%token==2.and.g_2%token==2) then
!!$          string_prefix1 = "KC_ss"
!!$       elseif(g_1%token==1.and.g_2%token==1) then
!!$          string_prefix1 = "KC_rr"
!!$       else
!!$          string_prefix1 = "KC_sr"
!!$       end if
!!$    elseif(ivar=="EO") then
!!$       if(g_1%token==2.and.g_2%token==2) then
!!$          string_prefix1 = "EO_ss"
!!$       elseif(g_1%token==1.and.g_2%token==1) then
!!$          string_prefix1 = "EO_rr"
!!$       else
!!$          string_prefix1 = "EO_sr"
!!$       end if
!!$    elseif(ivar=="EC") then
!!$       if(g_1%token==2.and.g_2%token==2) then
!!$          string_prefix1 = "EC_ss"
!!$       elseif(g_1%token==1.and.g_2%token==1) then
!!$          string_prefix1 = "EC_rr"
!!$       else
!!$          string_prefix1 = "EC_sr"
!!$       end if
!!$    elseif(ivar=="VD") then
!!$       if(g_1%token==2.and.g_2%token==2) then
!!$          string_prefix1 = "VD_ss"
!!$       elseif(g_1%token==1.and.g_2%token==1) then
!!$          string_prefix1 = "VD_rr"
!!$       else
!!$          string_prefix1 = "VD_sr"
!!$       end if
!!$    elseif(ivar=="CA") then
!!$       if(g_1%token==2.and.g_2%token==2) then
!!$          string_prefix1 = "CA_ss"
!!$       elseif(g_1%token==1.and.g_2%token==1) then
!!$          string_prefix1 = "CA_rr"
!!$       else
!!$          string_prefix1 = "CA_sr"
!!$       end if
!!$    end if
!!$
!!$
!!$    string_prefix1=trim(string_prefix1)//'_'
!!$    string_time = "000000"
!!$!!c       string_postfix="m.dat"          ! in minites
!!$    string_postfix="s.dat"          ! in seconds
!!$
!!$
!!$!!c    inum = int(cur_time/60.0_PS)
!!$    inum = int(cur_time)
!!$    digit = 1.0
!!$    do
!!$       inum = inum/10
!!$       if( inum /= 0 ) then; digit = digit + 1.0
!!$       else if( inum == 0 ) then; exit
!!$       end if
!!$    end do
!!$!!c    inum = int(cur_time/60.0_PS)
!!$    inum = int(cur_time)
!!$    do
!!$       jnum = inum/int(10.0**(digit-1))
!!$       inum = inum - jnum*int(10.0**(digit-1))
!!$       string_time(6-int(digit)+1:6-int(digit)+1) = achar(jnum+48)
!!$       digit = digit - 1.0
!!$       if( digit <= 0.0 ) exit
!!$    end do
!!$
!!$    ofname = trim(string_prefix1) // trim(string_time)
!!$    ofname = trim(ofname) // trim(string_postfix)
!!$    open(1,file=ofname)
!!$    do i=1,g_1%N_BIN
!!$       write(1,100) (X2D(i,j),j=1,g_2%N_BIN)
!!$    end do
!!$    close(1)
!!$
!!$100 format(100ES15.6)
!!$  end subroutine print_2Dvar

!!c  subroutine ini_marker( g)
!!c    type (Group), intent(inout)       :: g
!!c    integer    :: i
!!c
!!c    do i = 1, g(ic)%N_BIN
!!c       g(ic)%MS(i,n)%mark = 1
!!c    end do
!!c  end subroutine ini_marker

!!c  subroutine ini_tendency( g)
!!c    type (Group), intent(inout)        :: g
!!c    integer  :: i, j
!!c    do i = 1, g(ic)%N_BIN
!!c       g(ic)%MS(i,n)%dmassdt = 0.0_PS
!!c       g(ic)%MS(i,n)%dcondt = 0.0_PS
!!c       g(ic)%MS(i,n)%dvoldt = 0.0_PS
!!c    end do
!!c  end subroutine ini_tendency

!!$  function get_total_WC( g_1, g_2, g_3, n) result(sum)
!!$    type (Group), intent(in)        :: g_1, g_2, g_3
!!$    integer       :: n
!!$    real (PS)     :: sum
!!$    integer  :: i!, j
!!$    sum = 0.0_PS
!!$    do i = 1, g_1%N_BIN
!!$       sum = sum + g_1%MS(i,n)%mass(1)
!!$    end do
!!$    do i = 1, g_2%N_BIN
!!$       sum = sum + g_2%MS(i,n)%mass(1)
!!$    end do
!!$    do i = 1, g_3%N_BIN
!!$       sum = sum + g_3%MS(i,n)%mass(1)
!!$    end do
!!$  end function get_total_WC

!!$  subroutine prod_ma_cooling( gr, ag)
!!$    !_______________________________________________________________________
!!$    !     GROWTH OF CLOUD WATER BY VAPOR DEPOSITION...THIS IS ESSENTIALLY
!!$    !     DIAGNOSTIC GROWTH WITH MAINTAINS 0% SUPERSATURATION.
!!$    !_______________________________________________________________________
!!$    !
!!$    !     This routine calculates the mixing ratio tendency of cloud water
!!$    !     as a parcel moves upward (or downward) along a moist adiabat.
!!$    !
!!$    !     to reduce the growth of cloud water by
!!$    !     amoun of deposition onto other condensates
!!$    !
!!$    !
!!$    !     This calculation updates a previous tendency by reducing it
!!$    !     as a result of competition with other process which consumw
!!$    !     vapor.
!!$    !
!!$    !     This calculation is derived from a formulation described by
!!$    !     Tripoli and Cotton (1980):
!!$    !
!!$    type (Group), intent(inout)   :: gr
!!$    ! thermo variable object
!!$    type (AirGroup), intent(in)  :: ag
!!$    real (PS), parameter             :: g = 980.0
!!$    ! gas constant of dry air, ergs/deg/g
!!$    real (PS), parameter             :: R = 2.87e+6
!!$    ! specific heat of dry air  (eng/g/K)
!!$    real (PS), parameter             :: Cp = 1.0e+7
!!$    real (PS)        :: ALDCPT, Mp
!!$    integer :: n
!!$    ! type of process
!!$    integer              :: pro_type
!!$
!!$    pro_type=7
!!$    do n=1,gr%L
!!$       if( gr%MS(1,n)%mass(rmt) > 0.0_PS) then
!!$          ALDCPT = 0.611_PS*L_e/(Cp*ag%TV(n)%T)
!!$          gr%MS(1,n)%dmassdt(rmt,pro_type) = ag%TV(n)%W*g*ag%TV(n)%rv_sat(1)&
!!$               /(ag%TV(n)%T*(1.0_PS+0.61_PS*ag%TV(n)%rv)*R)*(ALDCPT-1.0_PS)&
!!$               /(ALDCPT*L_e*ag%TV(n)%rv_sat(1)/(R*ag%TV(n)%T) + 1.0_PS)
!!$          gr%MS(1,n)%dmassdt(rmt,pro_type) = gr%MS(1,n)%dmassdt(rmt,pro_type)*ag%TV(n)%den
!!$
!!$          Mp=gr%MS(1,n)%mass(rmt)+gr%MS(1,n)%dmassdt(rmt,pro_type)
!!$          if(Mp>gr%MS(1,n)%umt*gr%MS(1,n)%con) then
!!$             write(*,*) "Mp is larger than limit of rain 1"
!!$             stop
!!$          end if
!!$!!c          !_______________________________________________________________________
!!$!!c          !     COMPUTE SUPERSATURATION ASSUMING THERMAL EQUILIBRIUM, THEN
!!$!!c          !     GET A NEW CLOUD WATER TEMPERATURE AND SATURATION MIXING RATIO
!!$!!c          !_______________________________________________________________________
!!$!!c          !
!!$!!c
!!$!!c          ag%TV(n)%s_v(1) = gr%MS(1,n)%dmassdt(rmt,1)&
!!$!!c               /(2.0_PS*PI*ag%TV(n)%GTP(1)*gr%MS(1,n)%con*gr%MS(1,n)%len)
!!$!!c
!!$!!c          !
!!$!!c          !    Now we need to recalculate the cloud droplet temperature:
!!$!!c          !
!!$!!c          !
!!$!!c          !    So the cloud droplet temperature can be recalculated as:
!!$!!c          !
!!$!!c          gr%MS(1,n)%tmp = ag%TV(n)%T + L_e*ag%TV(n)%GTP(1)*ag%TV(n)%s_v(1)/ag%TV(n)%k_a
!!$!!c          !
!!$!!c          !     In order to represent the supersaturation for deposition/sorption
!!$!!c          !     ice nucleation, we adjust the
!!$!!c          !     saturation mixing ratio over the droplet according to new
!!$!!c          !     temperature:
!!$!!c          call renew_sat(ag,gr%MS(1,n)%tmp,n,0)
!!$
!!$
!!$       end if
!!$    end do
!!$  end subroutine prod_ma_cooling

!!$  subroutine cal_supsat(gc,ag,n)
!!$    !_______________________________________________________________________
!!$    !     COMPUTE SUPERSATURATION ASSUMING THERMAL EQUILIBRIUM, THEN
!!$    !     GET A NEW CLOUD WATER TEMPERATURE AND SATURATION MIXING RATIO
!!$    !_______________________________________________________________________
!!$    !
!!$    type (Group), intent(inout)         :: gc
!!$    type (AirGroup), intent(inout)      :: ag
!!$    integer,intent(in)   :: n
!!$
!!$    !integer   :: i
!!$
!!$    if( gc%MS(1,n)%mass(1) > 0.0_PS) then
!!$       !
!!$       !         First case is when the air is saturated and so
!!$       !         cloud water exists
!!$       !
!!$       ag%TV(n)%s_v(1) = gc%MS(1,n)%dmassdt(1,1)&
!!$            /(2.0_PS*PI*ag%TV(n)%GTP(1)*gc%MS(1,n)%con*gc%MS(1,n)%len)
!!$
!!$       !
!!$       !    Now we need to recalculate the cloud droplet temperature:
!!$       !
!!$       !
!!$       !    So the cloud droplet temperature can be recalculated as:
!!$       !
!!$       gc%MS(1,n)%tmp = ag%TV(n)%T + L_e*ag%TV(n)%GTP(1)*ag%TV(n)%s_v(1)/ag%TV(n)%k_a
!!$       !
!!$       !     In order to represent the supersaturation for deposition/sorption
!!$       !     ice nucleation, we adjust the
!!$       !     saturation mixing ratio over the droplet according to new
!!$       !     temperature:
!!$       call renew_sat(ag,gc%MS(1,n)%tmp,n,0)
!!$
!!$    else
!!$       !
!!$       !         This is the more common case-when air is not saturated
!!$       !         and is sub-saturated:
!!$       !
!!$       !         the supersaturation is already calculated at the construction
!!$       !         of the AirGroup object
!!$    end if
!!$  end subroutine cal_supsat

!!c  subroutine cal_convmat(th_var, gc, gr, gs, cnvmat)
!!c    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    ! contruct conversion matrix
!!c    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    ! conversion matrix
!!c    !   this is defined as a positive definite tendency.
!!c    ! - argument 1 : variable, 2: from,  3 : to
!!c    ! - ID
!!c    !   vapor 1, cloud droplets 2, rain group 3
!!c    !   solid hydrometeor 4
!!c    real(PS), pointer, dimension(:,:)        :: cnvmat
!!c    real(PS)                  :: sum_tend
!!c    integer                   :: i, j
!!c    !
!!c    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    ! from vapor to cloud droplets
!!c    ! - vapor deposition process
!!c    cnvmat(1,2) = max(gc%MS(1,n)%dmassdt(1,1), 0.0_PS)
!!c
!!c    ! from vapor to rain group
!!c    ! - vapor deposition process
!!c    sum_tend =0.0_PS
!!c    do i = 1, gr%N_BIN
!!c       sum_tend = sum_tend + max( gr%MS(i,n)%dmassdt(rmt,1), 0.0_PS)
!!c    end do
!!c    cnvmat(1,3) = sum_tend
!!c
!!c    ! from vapor to solid hydrometeor group
!!c    ! - vapor deposition process
!!c    ! - sorption/deposition ice nucleation process
!!c    sum_tend =0.0_PS
!!c    do i = 1, gs%N_BIN
!!c       sum_tend = sum_tend + max( gs%MS(i,n)%dmassdt(imt,1),0.0_PS) &
!!c            + max( gs%MS(i,n)%dmassdt(imt,7), 0.0_PS)
!!c    end do
!!c    cnvmat(1,4) = sum_tend
!!c    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c
!!c    ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!c    ! from cloud droplets to vapor
!!c    ! - vapor deposition process
!!c    cnvmat(2,1) = max( -gc%MS(1)%dmassdt(1,1), 0.0_PS)
!!c
!!c    ! from cloud droplets to rain group
!!c    ! - auto conversion
!!c    cnvmat(2,3) = max( gr%MS(1)%dmassdt(1,1), 0.0_PS)
!!c
!!c    ! from cloud droplets to solid hydrometeor group
!!c    cnvmat(2,4) = max( gs%MS(1)%dmassdt(1,8), 0.0_PS)
!!c
!!c  end subroutine cal_convmat

end module mod_amps_core
